// CustomPage.ets Scan barcodes using the custom UI.
import { curves, display, promptAction, router } from '@kit.ArkUI';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { scanCore, scanBarcode, customScan } from '@kit.ScanKit';
import { AsyncCallback, BusinessError } from '@kit.BasicServicesKit';
import { xComDisplay, getXComDisplay } from '../utils/Common';
import { PermissionsUtil } from '../utils/PermissionsUtil';
import { abilityAccessCtrl, Permissions } from '@kit.AbilityKit';

const TAG: string = 'ScanKit customScanPage';
let setInterFlag: number;
let toResultPage: number;

@Extend(Row)
function scanSizes(position: scanBarcode.ScanCodeRect, xDisplay: xComDisplay) {
  .width(position.right - position.left)
  .height(position.bottom - position.top)
  .position({ x: position.left + xDisplay.offsetX, y: position.top + xDisplay.offsetY })
}

@Extend(Image)
function scanCenter(position: scanBarcode.ScanCodeRect, xDisplay: xComDisplay) {
  .width(40)
  .height(40)
  .markAnchor({ x: 20, y: 20 })
  .position({
    x: (position.left + position.right) / 2 + xDisplay.offsetX,
    y: (position.top + position.bottom) / 2 + xDisplay.offsetY
  })
}

@Extend(Button)
function button() {
  .backgroundColor($r('sys.color.ohos_id_color_text_primary_activated'))
  .fontColor(Color.White)
  .align(Alignment.Center)
  .type(ButtonType.Capsule)
  .margin({ bottom: 10 })
  .width(200)
  .height(40)
  .borderRadius(20)
}

@Extend(Row)
function btnRow() {
  .backgroundColor($r('sys.color.ohos_id_color_text_primary_activated'))
  .align(Alignment.Center)
  .margin({ bottom: 10 })
  .width(200)
  .height(40)
  .borderRadius(20)
  .justifyContent(FlexAlign.Center)
}

@Extend(Text)
function btnTextRow() {
  .fontColor(Color.White)
  .align(Alignment.Center)
  .height(40)
}

@Extend(Row)
function angleSizes(x: number, y: number, borderOption: BorderOptions, xDisplay: xComDisplay) {
  .width(20)
  .height(20)
  .border(borderOption)
  .borderColor($r('sys.color.comp_background_list_card'))
  .position({ x: x + xDisplay.offsetX, y: y + xDisplay.offsetY })
}

@Entry
@Component
struct CustomScanPage {
  @State userGrant: boolean = false // Whether the camera permission has been requested.
  @State surfaceId: string = '' // ID generated by xComponent.
  @State isShowScanResult: boolean = false // Whether the barcode has been detected in the image.
  @State isFlashLightEnable: boolean = false // Whether the flash light has been turned on.
  @State isSensorLight: boolean = false // Light conditions in the current environment.
  @State isStopCamera: boolean = false // Whether the camera stream is stopped.
  @State zoomValue: number = 1 // Preview stream zoom ratio.
  @State setZoomValue: number = 1 // Whether to display the preview stream zoom ratio.
  @State count: number = 0
  @State isShowFrameResult: boolean = true // Whether to display the framework result.
  @State scaleValue: number = 1 // Screen zoom ratio.
  @State pinchValue: number = 1 // Two-finger zoom ratio.
  private displayHeight: number = 0 // Screen height.
  private displayWidth: number = 0 // Screen width.
  @State xComDisplay: xComDisplay = {
    // Style of the xComponent, including the width, height, X-axis offset, and Y-axis offset.
    width: 360,
    height: 640,
    offsetX: 0,
    offsetY: 0
  }
  // Initialize viewControl parameters.
  @State viewControl: customScan.ViewControl =
    { width: this.xComDisplay.width, height: this.xComDisplay.height, surfaceId: this.surfaceId }
  @State scanCodeRectCallback: Array<scanBarcode.ScanCodeRect> = [] // Position of the barcode image, returned in a callback. The position type is scanBarcode.ScanCodeRect.
  @State scanCodeRect: Array<scanBarcode.ScanResult> = []
  @State scanCodeRectLength: number = 0
  @State scanCodeRectFrameCallback: Array<scanBarcode.ScanCodeRect> = [] // Position of the barcode image in YUV data, returned in frameCallback. The position type is scanBarcode.ScanCodeRect.
  @State scanLineY: string = '0'
  private mXComponentController: XComponentController = new XComponentController()
  private callback: AsyncCallback<Array<scanBarcode.ScanResult>> = async (error: BusinessError, result:
    Array<scanBarcode.ScanResult>) => {
    if (error) {
      hilog.error(0x0001, TAG, `Failed to get ScanResult by callback. Code: ${error.code}, message: ${error.message}`);
      return;
    }
    this.scanCodeRect = result;
    this.scanCodeRectCallback = [];
    this.scanCodeRectLength = 0;
    this.showScanResult(result);
  }
  // Camera preview stream (YUV) returned in frameCallback.
  private frameCallback: AsyncCallback<customScan.ScanFrame> =
    async (error: BusinessError, frameResult: customScan.ScanFrame) => {
      if (error || !this.isShowFrameResult) {
        hilog.error(0x0001, TAG, `frameCallback failed, code: ${error.code}, message: ${error.message}`);
      } else {
        customScan.off('lightingFlash');
        hilog.info(0x0001, TAG, `frameCallback width: ${frameResult.width}, height: ${frameResult.height}`);
        // The YUV data is updated frequently. You can modify this.count++ % to change the update frequency.
        if ((this.count++ % 1) === 0) {
          let ratio: number;
          ratio = this.xComDisplay.width / frameResult.height;
          if (frameResult.scanCodeRects && frameResult.scanCodeRects.length > 0) {
            this.scanCodeRectFrameCallback = [];
            // Position of the barcode image in YUV data. The position type is scanBarcode.ScanCodeRect.
            frameResult.scanCodeRects?.forEach((item: scanBarcode.ScanCodeRect) => {
              let reactConverts: scanBarcode.ScanCodeRect = {
                left: (frameResult.height - item.bottom) * ratio,
                top: item.left * ratio,
                right: (frameResult.height - item.top) * ratio,
                bottom: item.right * ratio
              };
              this.scanCodeRectFrameCallback.push(reactConverts);
            })
          }
        }
      }
    };

  aboutToAppear(): void {
    this.setDisplay();
  }

  // Display the page.
  async onPageShow() {
    hilog.error(0x0001, TAG, `onPageShow - requestCameraPermission before this.userGrant: ${this.userGrant}`);
    // Apply for the camera permission.
    const permissions: Array<Permissions> = ['ohos.permission.CAMERA'];
    let grantStatus = await PermissionsUtil.checkAccessToken(permissions[0]);
    if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
      // The user has granted the permission, and your app can continue barcode scanning.
      this.userGrant = true;
    } else {
      let grantStatus = await PermissionsUtil.reqPermissionsFromUser()
      let length: number = grantStatus.length;
      for (let i = 0; i < length; i++) {
        if (grantStatus[i] === 0) {
          // If the user grants the permission, your app can continue barcode scanning.
          hilog.info(0x0001, TAG, `requestPermissionsFromUser success`);
          this.userGrant = true;
          break;
        }
      }
    }
    if (this.userGrant) {
      // Check whether the device is foldable.
      if (display.isFoldable()) {
        this.foldStatusSubscribe();
      }
    }
  }

  // Hide the page.
  async onPageHide() {
    this.userGrant = false;
    this.isFlashLightEnable = false;
    this.isSensorLight = false;
    this.customOffLightingFlash();
    clearTimeout(setInterFlag);
    // Stop and release camera streams when the scanning UI disappears or is hidden.
    await this.customScanRelease();
  }

  aboutToDisappear(): void {
    if (display.isFoldable()) {
      // Cancel the foldable screen status change listener.
      display.off('foldStatusChange');
    }
  }

  // Customize the back button and scanning prompt on the top of the scanning UI.
  @Builder
  TopTool() {
    Column() {
      Flex({ direction: FlexDirection.Row, justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {
        Image($rawfile('scan_back.svg'))
          .fillColor(Color.Black)
          .width(30)
          .height(30)
          .objectFit(ImageFit.Contain)
          .onClick(async () => {
            router.back();
          })
      }.padding({ left: 24, right: 24, top: 24 })

      Column() {
        Text($r('app.string.Scan_barcode'))
        Text($r('app.string.Scan_barcode_tips'))
      }.margin({ left: 24, right: 24, top: 24 })
    }
    .height(146)
    .width('100%')
    .margin({ top: 24 })
  }

  build() {
    Stack() {
      if (this.userGrant) {
        Column() {
          // XComponent of the preview stream.
          XComponent({
            id: 'componentId',
            type: XComponentType.SURFACE,
            controller: this.mXComponentController
          })
            .onLoad(async () => {
              hilog.info(0x0001, TAG, 'Succeeded in loading, onLoad is called.');
              // Obtain surfaceId of XComponent.
              this.surfaceId = this.mXComponentController.getXComponentSurfaceId();
              hilog.info(0x0001, TAG, `Succeeded in getting surfaceId: ${this.surfaceId}`);
              // Start camera streams.
              this.customScanInit();
            })
            .width(this.xComDisplay.width)
            .height(this.xComDisplay.height)
            .position({ x: this.xComDisplay.offsetX, y: this.xComDisplay.offsetY })
        }
        .height('100%')
        .width('100%')
      }

      // Scanning line animation (which can be replaced). It is displayed when no scanning result is already detected.
      if(this.scanCodeRectLength === 0) {
        Column() {
          Image($rawfile('scan_shadow.png')).width('100%')
            .position({ x: 0, y: this.scanLineY })
            .rotate({
              x: 1,
              angle: 180,
              centerX: 0,
              centerY: 0
            })
        }
        .position({ x: '10%', y: '35%' })
        .width('80%')
        .height('30%')
      }

      // Customize the layout.
      Column() {
        this.TopTool()
        Column() {
        }
        .layoutWeight(1)
        .width('100%')

        Column() {
          // Flash light button, which is available only after camera streams are started.
          Button('FlashLight').button()
            .onClick(() => {
              // Open or close the flash light based on the flash light status.
              try {
                if (customScan.getFlashLightStatus()) {
                  customScan.closeFlashLight();
                  this.isFlashLightEnable = false;
                } else {
                  customScan.openFlashLight();
                  this.isFlashLightEnable = true;
                }
              } catch (error) {
                hilog.error(0x0001, TAG, `Failed to flashLight. Code: ${error.code}, message: ${error.message}`);
              }
            })
            .visibility((this.userGrant && this.scanCodeRectLength === 0) ? Visibility.Visible : Visibility.None)

          // Rescan button.
          Button('Scan').button()
            .onClick(() => {
              // Reset scanning options.
              this.scanCodeRectCallback = [];
              this.scanCodeRectFrameCallback = [];
              this.isShowScanResult = false;
              this.scanCodeRectLength = 0;
              this.scanLineY = '0%';
              clearTimeout(toResultPage);
              this.customScanInit();
            })
            .visibility(this.isShowScanResult ? Visibility.Visible : Visibility.None)

          if (this.userGrant && !this.isShowScanResult) {
            Button(this.isShowFrameResult ? 'Close frameYUV' : 'Open frameYUV').button()
              .onClick(() => {
                // Reset scanning options.
                this.scanCodeRectCallback = [];
                this.scanCodeRectFrameCallback = [];
                this.isShowFrameResult = !this.isShowFrameResult;
                clearTimeout(toResultPage);
              })
          }

          if (this.userGrant && !this.isShowScanResult) {
            Row() {
              Row() {
                Text($r('app.string.decode_zoom_current')).btnTextRow()
                Text('' + this.setZoomValue).btnTextRow()
              }
              .btnRow()
              .onClick(() => {
                // Set the camera zoom ratio.
                if (!this.isShowScanResult) {
                  if (this.zoomValue) {
                    this.setZoomValue = this.zoomValue;
                    customScan.setZoom(this.zoomValue);
                  } else {
                    this.setZoomValue = customScan.getZoom();
                  }
                }
              })
            }
            .margin({ bottom: 10 })

            Row() {
              TextInput({ placeholder: $r('app.string.decode_zoom_enter') })
                .width(200)
                .type(InputType.Number)
                .borderWidth(1)
                .backgroundColor(Color.White)
                .onChange(value => {
                  this.zoomValue = Number(value);
                })
            }
          }
        }
        .height(250)
      }
      .width('100%')
      .height('100%')

      // YUV data of the camera preview stream. If the scanning is successful, the four corners of the recognized barcode image are displayed, which are consistent with the peripheral area of the xComponent.
      if (this.isShowFrameResult) {
        ForEach(this.scanCodeRectFrameCallback, (item: scanBarcode.ScanCodeRect) => {
          // Area box of the barcode image in the YUV data.
          // Upper left corner.
          Row()
            .angleSizes(item.left, item.top, { width: { left: 3, top: 3 } }, this.xComDisplay)
            .markAnchor({ x: 0, y: 0 })
          // Upper right corner.
          Row()
            .angleSizes(item.right, item.top, { width: { right: 3, top: 3 } }, this.xComDisplay)
            .markAnchor({ x: 20, y: 0 })
          // Lower right corner.
          Row()
            .angleSizes(item.right, item.bottom, { width: { right: 3, bottom: 3 } }, this.xComDisplay)
            .markAnchor({ x: 20, y: 20 })
          // Lower left corner.
          Row()
            .angleSizes(item.left, item.bottom, { width: { left: 3, bottom: 3 } }, this.xComDisplay)
            .markAnchor({ x: 0, y: 20 })
          // Blue center point of the barcode image in the YUV data. The point can be displayed by setting the value of opacity.
          Image($rawfile('scan_selected.svg'))
            .scanCenter(item, this.xComDisplay)
            .opacity(0)
        }, (item: scanBarcode.ScanCodeRect, index: number) => {
          return index + '__' + JSON.stringify(item);
        })
      }

      // Position of the barcode image after successful scanning, which aligns with the peripheral area of the xComponent.
      if (this.scanCodeRectCallback.length > 0) {
        ForEach(this.scanCodeRectCallback, (item: scanBarcode.ScanCodeRect, index: number) => {
          // Barcode image area. You can set the background color of the Row area.
          Row() {
          }.scanSizes(item, this.xComDisplay)

          // Blue center point of the barcode image. When multiple barcodes are recognized, you need to tap the center point of the one you need and proceed.
          Image(this.scanCodeRectLength > 1 ? $rawfile('scan_selected2.svg') : $rawfile('scan_selected.svg'))
            .scanCenter(item, this.xComDisplay)
            .onClick(() => {
              let result: Array<scanBarcode.ScanResult> = [];
              let scanResult: scanBarcode.ScanResult = {
                scanType: this.scanCodeRect[index].scanType,
                originalValue: this.scanCodeRect[index].originalValue,
                scanCodeRect: this.scanCodeRect[index].scanCodeRect
              }
              result.push(scanResult);
              router.replaceUrl({
                url: 'pages/CustomResultPage',
                params: {
                  result: result
                }
              });
            })
        }, (item: scanBarcode.ScanCodeRect, index: number) => {
          return index + '__' + JSON.stringify(item);
        })
      }

    }
    // You are advised to set camera streams to the full screen mode.
    .width('100%')
    .height('100%')
    .onClick((event: ClickEvent) => {
      // Whether the scanning result has been obtained.
      if (this.scanCodeRectLength > 0) {
        return;
      }
      // When the user taps on the screen, obtain the tap position coordinates (x,y) and set the camera focus.
      let x1 = vp2px(event.displayY) / (this.displayHeight + 0.0);
      let y1 = 1.0 - (vp2px(event.displayX) / (this.displayWidth + 0.0));
      hilog.info(0x0001, TAG, `onLoad setFocusPoint x1: ${x1}, y1: ${y1}`);
      try {
        customScan.setFocusPoint({ x: x1, y: y1 });
      } catch (error) {
        hilog.error(0x0001, TAG, `Failed to setFocusPoint. Code: ${error.code}, message: ${error.message}`);
      }
      // Set the focus mode to continuous auto-focus.
      setTimeout(() => {
        try {
          customScan.resetFocus();
        } catch (error) {
          hilog.error(0x0001, TAG, `Failed to resetFocus. Code: ${error.code}, message: ${error.message}`);
        }
      }, 200);
    })
  }

  // Scanning result returned in a callback.
  async showScanResult(result: Array<scanBarcode.ScanResult>) {
    this.scanCodeRectLength = result.length;
    if (result.length > 0) {
      this.customScanStop();
      clearTimeout(toResultPage);
      // Position of the barcode image, which is of the type scanBarcode.ScanCodeRect.
      result.forEach((item: scanBarcode.ScanResult) => {
        if (item.scanCodeRect) {
          this.scanCodeRectCallback.push(item.scanCodeRect);
        }
      })
      // Stop displaying the message indicating that no barcode is recognized after the barcode is actually recognized.
      clearTimeout(setInterFlag);
      // Print the test result. You can process the obtained result accordingly.
      hilog.info(0x0001, TAG, `Succeeded in getting ScanResult.`);
      this.isShowScanResult = true;
      if (this.scanCodeRectLength === 1) {
        toResultPage = setTimeout(() => {
          router.replaceUrl({
            url: 'pages/CustomResultPage',
            params: {
              result: result
            }
          });
        }, 1000);
      }
    }
  }

  // Obtain the screen size.
  setDisplay() {
    // Obtain the xComponent style attributes, including width, height, offsetX, and offsetY.
    this.xComDisplay = getXComDisplay();
  }

  // Initialize custom barcode scanning.
  customScanInit() {
    if (!this.userGrant) {
      return;
    }
    this.isStopCamera = false;
    let options: scanBarcode.ScanOptions = {
      scanTypes: [scanCore.ScanType.ALL],
      enableMultiMode: true, // Whether to enable the function of scanning multiple barcodes.
      enableAlbum: true // Whether to display the gallery button.
    }
    // Initialize options for custom barcode scanning.
    try {
      customScan.init(options);
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to init scan. Code: ${error.code}, message: ${error.message}`);
    }
    this.viewControl = {
      width: this.xComDisplay.width,
      height: this.xComDisplay.height,
      surfaceId: this.surfaceId
    }
    // Start camera streams and obtain scanning result using a callback. YUV-based recognition applies for comprehensive scenarios that may include barcode scanning and object recognition.
    try {
      customScan.start(this.viewControl, this.callback, this.frameCallback);
      // Tap the animation.
      animateTo({
        duration: 1500, // Animation duration.
        curve: curves.cubicBezierCurve(0.33, 0, 0.67, 1), // Animation curve.
        delay: 100,
        iterations: -1,
        playMode: PlayMode.Normal,
      }, () => {
        this.scanLineY = '100%';
      });
      // Display a message when no barcode is recognized.
      setInterFlag = setTimeout(() => {
        if (this.userGrant && this.scanCodeRectLength === 0) {
          promptAction.showToast({
            message: $r('app.string.Scan_diaLog_not_found'),
            duration: 2000
          });
        }
      }, 5000);
      this.customOnLightingFlash();
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to start scan. Code: ${error.code}, message: ${error.message}`);
    }
  }

  // Stop camera streams.
  async customScanStop(): Promise<void> {
    if (!this.isStopCamera) {
      try {
        this.isStopCamera = true;
        customScan.stop((error: BusinessError) => {
          if (error) {
            this.isStopCamera = false;
            hilog.error(0x0001, TAG, `Failed to stop scan. Code: ${error.code}, message: ${error.message}`);
            return;
          }
          hilog.info(0x0001, TAG, 'Succeeded in stopping scan.');
        })
      } catch (error) {
        hilog.error(0x0001, TAG, `Failed to stop customScan. Code: ${error.code}, message: ${error.message}`);
      }
    }
  }

  // Release camera streams.
  async customScanRelease(): Promise<void> {
    await this.customScanStop();
    try {
      customScan.release((error: BusinessError) => {
        if (error) {
          hilog.error(0x0001, TAG, `Failed to release scan. Code: ${error.code}, message: ${error.message}`);
          return;
        }
        hilog.info(0x0001, TAG, 'Succeeded in releasing scan.');
      })
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to stop scan. Code: ${error.code}, message: ${error.message}`);
    }
  }

  // Register the flash light listener.
  customOnLightingFlash() {
    try {
      customScan.on('lightingFlash', (error, isLightingFlash) => {
        if (error) {
          hilog.error(0x0001, TAG,
            `Failed to on lightingFlash. Code: ${error.code}, message: ${error.message}`);
          return;
        }
        if (isLightingFlash) {
          this.isFlashLightEnable = true;
          customScan.openFlashLight();
        } else {
          if (!customScan.getFlashLightStatus()) {
            this.isFlashLightEnable = false;
            customScan.closeFlashLight();
          }
        }
      });
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to on lightingFlash. Code: ${error.code}, message: ${error.message}`);
    }
  }

  // Deregister the flash light listener.
  customOffLightingFlash() {
    try {
      customScan.off('lightingFlash');
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to off lightingFlash. Code: ${error.code}, message: ${error.message}`);
    }
  }

  // Listen to the status change of the foldable screen, and release and restart of camera streams.
  foldStatusSubscribe(): void {
    try {
      display.on('foldStatusChange', async (foldStatus: display.FoldStatus) => {
        // 1: expanded; 2: collapsed. When the status changes, the width and height need to be calculated again.
        if (foldStatus === display.FoldStatus.FOLD_STATUS_EXPANDED ||
          foldStatus === display.FoldStatus.FOLD_STATUS_FOLDED) {
          this.scanCodeRectCallback = [];
          this.scanCodeRectFrameCallback = [];
          clearTimeout(toResultPage);
          clearTimeout(setInterFlag);
          // Release camera streams.
          this.customScanRelease();
          // Restart camera streams.
          setTimeout(() => {
            this.setDisplay();
            this.customScanInit();
          }, 300);
        }
      })
    } catch (error) {
      hilog.error(0x0001, TAG, `Failed to foldStatusChange. Code: ${error.code}, message: ${error.message}`);
    }
  }
}