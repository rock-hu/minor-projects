/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

// NOLINTNEXTLINE(readability-function-size)
void panda::bytecodeopt::BytecodeGen::VisitEcma(panda::compiler::GraphVisitor *visitor, Inst *inst_base)
{
    ASSERT(inst_base->IsIntrinsic());
    auto inst = inst_base->CastToIntrinsic();
    auto enc = static_cast<BytecodeGen *>(visitor);

    switch (inst->GetIntrinsicId()) {
% instructions = Panda::instructions.select{|b| b.namespace == "ecmascript"}
% if instructions.first && instructions.first.intrinsic_name
%   instructions = instructions.group_by(&:intrinsic_name)
% else
%   instructions = instructions.group_by(&:opcode)
% end
% instructions.each do |intrinsic_name, group|
%     inst = group.first
%     next if inst.properties.include?("jump")
%     opcode = inst.opcode.upcase
%     params_arr = inst.operands
%     group.each do |i|
%       intr_id = i.opcode.upcase
       case compiler::RuntimeInterface::IntrinsicId::<%= intr_id %>:
%     end
       {
%     if inst.acc.include?("in")
            auto acc_src = inst->GetSrcReg(inst->GetInputsCount() - 2);
            if (acc_src != compiler::ACC_REG_ID) {
                DoLda(acc_src, enc->result_);
            }
%     end
%     params_str = ""
%     vreg_index = 0
%     imm_index = 0
%     id_index = 0
%     input_index = 0
%     params_arr.each do |param|
%       if param.reg?
            auto v<%= vreg_index %> = inst->GetSrcReg(<%= input_index %>);
%           params_str = params_str + "v#{vreg_index}, "
%         vreg_index = vreg_index + 1
%         input_index = input_index + 1
%       elsif param.id?
%         if param.method_id?
            ASSERT(inst->HasImms() && inst->GetImms().size() > <%= imm_index %>); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id<%= id_index %> = static_cast<uint32_t>(inst->GetImms()[<%= imm_index %>]);
            auto bc_id<%= id_index %> = enc->ir_interface_->GetMethodIdByOffset(ir_id<%= id_index %>);
%           params_str = params_str + "bc_id#{id_index}, "
%         elsif param.string_id?
            ASSERT(inst->HasImms() && inst->GetImms().size() > <%= imm_index %>); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id<%= id_index %> = static_cast<uint32_t>(inst->GetImms()[<%= imm_index %>]);
            auto bc_id<%= id_index %> = enc->ir_interface_->GetStringIdByOffset(ir_id<%= id_index %>);
%           params_str = params_str + "bc_id#{id_index}, "
%         elsif param.literalarray_id?
            ASSERT(inst->HasImms() && inst->GetImms().size() > <%= imm_index %>); // NOLINTNEXTLINE(readability-container-size-empty)
            auto ir_id<%= id_index %> = static_cast<uint32_t>(inst->GetImms()[<%= imm_index %>]);
            auto bc_id<%= id_index %> = enc->ir_interface_->GetLiteralArrayByOffset(ir_id<%= id_index %>);
%           params_str = params_str + "bc_id#{id_index}, "
%         end
%         id_index = id_index + 1
%         imm_index = imm_index + 1
%       elsif param.imm?
           ASSERT(inst->HasImms() && inst->GetImms().size() > <%= imm_index %>); // NOLINTNEXTLINE(readability-container-size-empty)
%          if inst.properties.include?("jump")
%            params_str += "LabelName(inst->GetBasicBlock()->GetTrueSuccessor()->GetId()), "
%          else
            auto imm<%= imm_index %> = static_cast<uint32_t>(inst->GetImms()[<%= imm_index %>]);
%           params_str = params_str + "imm#{imm_index}, "
%           imm_index = imm_index + 1
%         end
%       end
%     end
%     if params_arr.length > 0
%       params_str = params_str.chop
%       params_str = params_str.chop
%     end
            enc->result_.emplace_back(pandasm::Create_<%= inst.asm_token %>(<%= params_str %>));
%     if inst.acc.include?("out")
            auto acc_dst = inst->GetDstReg();
            if (acc_dst != compiler::ACC_REG_ID) {
                DoSta(inst->GetDstReg(), enc->result_);
            }
%     end
            break;
        }
% end
        default:
            enc->success_ = false;
            LOG(ERROR,COMPILER) << "Unsupported ecma opcode";
    }
}
