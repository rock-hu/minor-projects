/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

Graph* GenerateIntrinsicOperation(Inst* inst) {
    auto graph = CreateGraphWithOneBasicBlock();
    auto intrinsic_inst = inst->CastToIntrinsic();
    switch (intrinsic_inst->GetIntrinsicId()) {
% Compiler::intrinsics.each do |intrinsic|
%   next unless intrinsic.has_impl?
            case RuntimeInterface::IntrinsicId::<%= intrinsic.entrypoint_name %>:
                intrinsic_inst->AllocateInputTypes(&allocator_, <%= intrinsic.arguments.length() %>);
% intrinsic.arguments.each_with_index do |arg, i|
                    intrinsic_inst->AppendInput(CreateParamInst(graph, DataType::<%= arg %>, <%= i %>));
                    intrinsic_inst->AddInputType(DataType::<%= arg %>);
% end
                break;
% end
        default:
            UNREACHABLE();
    }
    ASSERT(graph->GetVectorBlocks().size() > 2);
    auto block = graph->GetVectorBlocks()[2];
    if (inst->RequireState()) {
        auto save_state = graph->CreateInstSaveState();
        block->AppendInst(save_state);  
        inst->AppendInput(save_state);
    }    
    block->AppendInst(inst);
    Inst* ret = nullptr;
    if (inst->GetType() == DataType::VOID) {
        ret = graph->CreateInstReturnVoid();
    } else {
        ret = graph->CreateInstReturn();
        ret->SetType(inst->GetType());
        ret->SetInput(0, inst);
    }
    block->AppendInst(ret);
    return graph;
}
