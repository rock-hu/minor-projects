# Object Type Propagation
## Overview
**Object Type Propagation** - analysis which tries to deduce classes of instructions with reference type.

## Rationality
Get as much type information as possible from control- and data-flow graphs. This is used later in [Inlining](inlining.md) and [Object Type Check Elimination](object_type_check_elimination_doc.md)

## Dependencies
* RPO
* Loop analysis

## Algorithm
* Visit blocks in RP Order. For each block:
    * merge `BasicBlockState`s for already computed predecessors to find `BasicBlockState` for the **beginning** of the block
    * if block is loop header, visit the whole loop ([Visiting Loops](#visiting-loops))
    * visit each instruction in the block to find `BasicBlockState` for the **end** of the block ([Visiting Instructions](#Visiting-Instructions))
* Write computed `ObjectTypeInfo`s to `Inst`s in graph

### Visiting Instructions
Instruction visit consists of two parts:

1. **AliasVisitor** part - here we track object creations, object moves (i.e. `Phi` instructions) and Loads/Stores.
    * There is special processing of Load/Store instructions with non-immediate indices (like `a[x]` and unlike `a[3]` or `a.field`). We have unique `Pointer::CreateUnknownOffset` offset, which corresponds to all such offsets. Unknown offset may alias with any other (constant or unknown) offset, so real refs corresponding to fixed offset `f`in `a` are union `a[f] | a[UNKNOWN]` (makes sence only for arrays)
2. **TypePropagationVisitor** part - here we update `TypeInfo`s we have (stored in `TypedRefSet`s)

### Visiting Loops
To visit loop, we get all instructions in it (i. e. recursively traverse inner loops) and then traverse `copy`-edges generated by `AliasVisitor` to find `RefSet`s corresponding to instructions in loop header, and also to find which instructions can escape during loop execution.

## Pseudocode
Helper structs we have:
```cpp
    // Unique id of some object. Objects with different IDs are never equal
    // Each instruction in graph can be assigned a set of Refs
    using Ref = uint32_t;

    // Set represented as sorted vector
    class VectorSet {
        Vector<Ref> data;
    }

    // Set represented as either sorted vector or bit vector
    class SmallSet {
        (VectorSet | BitVector) data;
    }

    // SmallSet with TypeInfo common for all refs in set
    class TypedRefSet : SmallSet {
        ObjectTypeInfo typeInfo;
    }

    // We use Pointer from AliasVisitor without Object field to represent offset
    using Offset = Pointer;

    class BasicBlockState {
        // states of objects in the end of this BB (or in the current point of it if it's currently visited BB)
        Map<(Ref, Offset), TypedRefSet> fieldRefs;
        // escaped refs in the end of this BB
        RefSet escaped; // TypedRefSet in real code
    }

    class ObjectTypePropagationVisitor {
        // K-th state corresponds to BB with id K - the end of the BB or the current position inside
        Vector<BasicBlockState *> states;
        // ObjectTypeInfo (Class + boolean, meaning exact class or may be superclass) - of all refs.
        Vector<ObjectTypeInfo> refInfos;
        // RefSets for reference-typed instructions in graph. Are independent from current BB (valid while inst is valid),
        // so are stored only once for each inst
        ArenaMap<const Inst *, ArenaTypedRefSet> instRefSets_;
    }
```

## Examples
    TODO

## Links
Source code:
 - [object_type_propagation.h](../optimizer/analysis/object_type_propagation.h)
 - [object_type_propagation.cpp](../optimizer/analysis/object_type_propagation.cpp)
 - [typed_ref_set.h](typed_ref_set.h)
