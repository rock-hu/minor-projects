/**
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!
// NOLINTNEXTLINE(readability-function-size)
Graph* GenerateIntrinsicOperation(Inst* inst) {
    auto graph = CreateGraphWithOneBasicBlock();
    auto intrinsicInst = inst->CastToIntrinsic();
    switch (intrinsicInst->GetIntrinsicId()) {
% Compiler::intrinsics.each do |intrinsic|
%   next unless intrinsic.has_impl?
            case RuntimeInterface::IntrinsicId::<%= intrinsic.entrypoint_name %>: {
                size_t inputsCount = <%= intrinsic.arguments.length() %>;
                if (inst->RequireState()) {
                    inputsCount++;
                }
                intrinsicInst->AllocateInputTypes(&allocator_, inputsCount);
% intrinsic.arguments.each_with_index do |arg, i|
                    intrinsicInst->AppendInput(CreateParamInst(graph, DataType::<%= arg %>, <%= i %>));
                    intrinsicInst->AddInputType(DataType::<%= arg %>);
% end
                break;
            }
% end
        default:
            UNREACHABLE();
    }
    AdjustFlags(intrinsicInst->GetIntrinsicId(), inst);
    ASSERT(graph->GetVectorBlocks().size() > 2);
    auto block = graph->GetVectorBlocks()[2];
    if (inst->RequireState()) {
        auto saveState = graph->CreateInstSaveState();
        saveState->SetMethod(reinterpret_cast<RuntimeInterface::MethodPtr>(runtime_.METHOD));
        block->AppendInst(saveState);
        inst->AppendInput(saveState);
        inst->CastToIntrinsic()->AddInputType(DataType::NO_TYPE);
    }
    block->AppendInst(inst);
    Inst* ret = nullptr;
    if (inst->GetType() == DataType::VOID) {
        ret = graph->CreateInstReturnVoid();
    } else {
        ret = graph->CreateInstReturn(inst->GetType(), INVALID_PC, inst);
    }
    block->AppendInst(ret);
    return graph;
}
