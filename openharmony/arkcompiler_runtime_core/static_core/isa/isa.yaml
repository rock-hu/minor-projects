# Copyright (c) 2021-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---

chapters:
  - name: General Design
    text: >
      VM is register-based with a dedicated accumulator register that serves as an implicit operand to instructions.

  - name: Registers
    text: >
      Registers are wide enough to hold a single reference when working with objects.
      When used for primitive types, register width is considered to be 64 bits.
      When used for object types, registers must be considered wide enough to hold a reference to an object.
      The scope of a register is a *function frame* (also known as *activation record*). If an instruction defines not all 64
      bits of a register, then the undefined bits are not accessed in a verified code.
      Register field width in instruction encoding can be 4 (16 addressable registers), 8 (256 registers) or
      16 (65536 registers) bits.

  - name: Accumulator
    text: >
      *Accumulator* is a special register which is used implicitly by instructions as a source and/or destination operand.
      The main goal of using accumulator is to improve encoding density without losing much in performance. Therefore,
      the general intuition regarding accumulator usage is to utilize accumulator as much as possible by taking it as
      a source from a previous instruction result and passing it to the next instruction in its destination operand.
      Moreover, when an instruction has more than one source operand, the shorter-living value must be passed
      through accumulator. However, instruction variations that do not write into accumulator are also introduced
      if it gives advantage. For example, arguments for the`call.range` instruction can be moved register-to-register.

  - name: Calling Sequence
    text: >
      A new function frame is created upon the execution of call bytecode. All necessary arguments are copied from the
      caller frame to the top of the callee frame. E.g., the last argument is placed in the register with the largest
      index, and the first argument is placed in the register with the index that equals the size of the frame subtracted
      by the number of arguments. The accumulator value is considered *undefined*; it is not read in the verified bytecode.
      Upon return, the callee frame is destroyed. If a function return value is non-void, then it is passed to the caller
      via accumulator. Otherwise, the accumulator content in the caller frame is considered *undefined*; it is not
      read in the verified bytecode.

  - name: Supported Primitive Types
    text: |
      VM supports operations on registers with i32 and i64 integral values. However, 8-bit and 16-bit integral values
      can be loaded/stored into records and arrays with corresponding bytecodes. In that case, VM extends/truncates the
      value to match storage size with i32. Similarly, passing an 8-bit or 16-bit value to a function can be emulated by
      passing a value, which is zero or sign-extended to i32.
      VM supports operations on registers with f32 and f64 values, which correspond to the IEEE-754 single and double precision
      floating-point representations.
      Primitive data type of a register is not tracked by VM and is interpreted by separate bytecodes.
      Integral values are not inherently signed or unsigned. Their signedness is interpreted by bytecodes as well.
      If bytecode treats a register value as a signed integer, then it uses two's complement representation.
      If bytecode treats a register value as an unsigned integer, then the bytecode is denoted by using the u32/u64 notation.
      It is not always possible to denote the type of result for moves, loads and stores, because it depends on the type of the
      source object. If it is not possible to denote the type of result, then bNN notation is used, where NN is the bit size of
      the result. Therefore, for example, b64 is a union of f64 and i64.

      ### Floating-point literals

      Decimal floating-point literals can have the following parts:

      - Sign ('``+``' or '``-`'`),
      - Whole number part,
      - Decimal point,
      - Fractional part,
      - Exponent indicator ('``e``'),
      - Exponent sign,
      - Exponent.

      Decimal floating-point literals must have at least one digit, plus either a decimal point or an exponent part.

      Special values:

      - Positive zero (+0.0, hexadecimal representation is `0x0000000000000000`),
      - Negative zero (-0.0, hexadecimal representation is `0x8000000000000000`),
      - Minimal positive value (4.9E-324, hexadecimal representation is `0x0000000000000001`),
      - Maximal negative value (-4.9E-324, hexadecimal representation is `0x8000000000000001`),
      - Maximal positive value (1.7976931348623157e308, hexadecimal representation is `0x7fefffffffffffff`),
      - Minimal negative value (-1.7976931348623157e308, hexadecimal representation is `0xffefffffffffffff`),
      - Positive infinity (hexadecimal representation is `0x7ff0000000000000`),
      - Negative infinity (hexadecimal representation is `0xfff0000000000000`),
      - Not a number - set of all NaN values (one of hexadecimal representations is `0x7ff8000000000000`).

  - name: Language-Dependent Types
    text: >
      Panda VM supports type hierarchies according to the language it executes. Therefore, creation (or loading
      from a constant pool) of strings, arrays, and exception objects produces objects of types native to the
      language, including inheritance relations.

  - name: Dynamically-Typed Languages Support
    text: >
      Panda VM supports dynamically-typed languages. It represents a dynamic value through a special 'any' value. 'Any' values
      wrap each value itself (both primitive value and object) with its corresponding type info. VM tracks types of registers
      that hold 'any' values, whether primitive or not. Virtual registers and accumulator are wide enough to hold an 'any'
      value. Regular static instructions can also be used when the VM executes a code inside a dynamically-typed language context.

# File format and ISA versioning
min_version: 0.0.0.5
version: 0.0.0.5

properties:
  - tag: type_id
    description: Use an id which resolves into a type constant.
  - tag: method_id
    description: Use an id which resolves into a method constant.
  - tag: static_method_id
    description: Use an id which resolves into a static method constant.
  - tag: string_id
    description: Use an id which resolves into a string constant.
  - tag: literalarray_id
    description: Use an id which resolves into a constant literalarray.
  - tag: field_id
    description: Use an id which resolves into an instance field reference.
  - tag: static_field_id
    description: Use an id which resolves into a static field reference.
  - tag: short_long_range
    description: Instruction is used to pass arguments, exists in short, long and range forms.
  - tag: call
    description: Pass control to the callee method.
  - tag: call_virt
    description: Pass control to the callee method via virtual call.
  - tag: return
    description: Pass control to the caller method.
  - tag: suspend
    description: Suspend current method and pass control to the caller one.
  - tag: jump
    description: Pass control to another bytecode in a current method.
  - tag: conditional
    description: Operate based on computed condition, otherwise is no operation.
  - tag: float
    description: Perform floating point operation.
  - tag: dynamic
    description: Operates on 'any' values.
  - tag: maybe_dynamic
    description: May operate on 'any' values depending on language context.
  - tag: language_type
    description: Creates objects of type depending on language context.
  - tag: initialize_type
    description: May initialize type instance during execution.
  - tag: init_obj
    description: Calls the object initialization function.
exceptions:
  - tag: x_none
    description: Bytecode doesn't throw exceptions.
  - tag: x_null
    description: Bytecode throws NullPointerException in case of null reference as a source.
  - tag: x_bounds
    description: Bytecode throws ArrayIndexOutOfBoundsException if index is out of bounds of an array.
  - tag: x_negsize
    description: Bytecode throws NegativeArraySizeException if index is less than zero.
  - tag: x_store
    description: Bytecode throws ArrayStoreException if element isn't instance of array's element type.
  - tag: x_abstract
    description: Bytecode throws AbstractMethodError if resolved method has no implementation.
  - tag: x_arith
    description: Bytecode throws ArithmeticException if the divisor is 0.
  - tag: x_cast
    description: Bytecode throws ClassCastException if type cast failed.
  - tag: x_classdef
    description: Bytecode throws NoClassDefFoundError if type cast failed.
  - tag: x_oom
    description: Bytecode throws OutOfMemoryError if failed to allocate object.
  - tag: x_init
    description: Bytecode throws ExceptionInInitializerError if unexpected exception occurred in a static initializer.
  - tag: x_call
    description: Bytecode may throw an error if an exception occurs in the called bytecode.
  - tag: x_throw
    description: Bytecode's primary role is to throw provided exception object.
  - tag: x_link
    description: Bytecode may throw NoClassDefFoundError if failed to resolve id.
verification:
  - tag: none
    description: Instruction is always valid.
  - tag: v1_array
    description: First operand contains a reference to an array.
  - tag: v1_object
    description: First operand contains a reference to an object (other than array).
  - tag: v1_array_type
    # TODO: specify
    description: First operand contains a reference to an array of elements of type corresponding to bytecode.
  - tag: v1_i32
    description: First operand contains a value of i32 type.
  - tag: v1_type
    description: First operand contains a value of type corresponding to bytecode.
  - tag: v1_obj_or_null
    description: First operand contains a reference to an object or null.
  - tag: v2_i32
    description: Second operand contains a value of i32 type.
  - tag: v2_object
    description: Second operand contains a reference to an object (other than array).
  - tag: v2_type
    description: Second operand contains a value of type corresponding to bytecode.
  - tag: acc_i32
    description: Accumulator contains a value of i32 type.
  - tag: acc_type
    description: Accumulator contains a value of type corresponding to bytecode.  # TODO: specify
  - tag: acc_return_type
    # TODO: specify, including assignment compatibility (see Java 'areturn')
    description: Accumulator type is compatible with method return type.
  - tag: v1_throw_type
    description: First operand contains a reference to an instance of class Throwable or of a subclass of Throwable.
  - tag: acc_obj_or_null
    description: Accumulator contains a reference to an object or null.
  - tag: type_id_array
    description: Type_id operand must correspond to an array type.
  - tag: type_id_object
    description: Type_id operand must correspond to an object type (other than array).
  - tag: type_id_any_object
    description: Type_id operand must correspond to any object type.
  - tag: type_id_class
    description: Type_id operand must correspond to a Class type.
  - tag: method_id_static
    description: Method_id must resolve to a static method or into initializer for a type other than one-dimensional array.
  - tag: method_id_non_static
    description: Method_id must resolve to a non-static method.
  - tag: method_id_non_abstract
    description: Method_id must resolve to a method that has implementation.
  - tag: method_id_accessible
    description: Method_id must resolve to a method which is accessible.
  - tag: constant_string_id
    description: Id must resolve into a constant-pool string.
  - tag: constant_literalarray_id
    description: Id must resolve into a constant literalarray.
  - tag: compatible_arguments
    description: Arguments provided to a method must be of compatible types.  # TODO: specify compatibility
  - tag: method_init_obj
    description: Method_id must resolve into initializer for a type other than one-dimensional array.
  - tag: branch_target
    description: Branch target should point to a beginning of an instruction of the same method.
  - tag: field_id_non_static
    description: Field_id must resolve to a non-static object field.
  - tag: field_id_static
    description: Field_id must resolve to a static field.
  - tag: field_id_size
    description: Field_id must resolve to a field of size corresponding to bytecode.
  - tag: valid_in_dynamic_context
    description: Instruction valid only for dynamically-typed language context.

prefixes:
  - name: bit
    description: Bit operations.
    opcode_idx: 0xef
  - name: unsigned
    description: Unsigned operations.
    opcode_idx: 0xee
  - name: cast
    description: Cast operations.
    opcode_idx: 0xed
  - name: f32
    description: IEEE-754 single precision floating-point operations.
    opcode_idx: 0xec

# Define elements allowed to be used in a profile description.
profiles_schema: {}

# Profiles should be specified in an ISA description for a specific language.
profiles: []

namespaces:
  - namespace: core
    used_instructions: []

groups:
  - title: No operation
    description: Perform an operation without behavior.
    exceptions:
      - x_none
    verification:
      - none
    pseudo: |
      skip
    instructions:
      - sig: nop
        acc: none
        format: [op_none]
        opcode_idx: [0x0]

  - title: Move register-to-register
    description: Move values between registers.
    exceptions:
      - x_none
    verification:
      - v2_type
    pseudo: |
      vd = vs
    instructions:
      - sig: mov v1:out:b32, v2:in:b32
        acc: none
        format: [op_v1_4_v2_4, op_v1_8_v2_8, op_v1_16_v2_16]
        opcode_idx: [0x1, 0x2, 0x3]
      - sig: mov.64 v1:out:b64, v2:in:b64
        acc: none
        format: [op_v1_4_v2_4, op_v1_16_v2_16]
        opcode_idx: [0x4, 0x5]
      - sig: mov.obj v1:out:ref, v2:in:ref
        acc: none
        format: [op_v1_4_v2_4, op_v1_8_v2_8, op_v1_16_v2_16]
        opcode_idx: [0x6, 0x7, 0x8]

  - title: Move immediate-to-register
    description: >
      Move integer immediate into a register. For short formats immediate is sign-extended to operand size.
    exceptions:
      - x_none
    verification:
      - none
    pseudo: >
      vd = imm
    instructions:
      - sig: movi v:out:i32, imm:i32
        acc: none
        format: [op_v_4_imm_4, op_v_8_imm_8, op_v_8_imm_16, op_v_8_imm_32]
        opcode_idx: [0x9, 0xa, 0xb, 0xc]
      - sig: movi.64 v:out:i64, imm:i64
        acc: none
        format: [op_v_8_imm_64]
        opcode_idx: [0xd]
      - sig: fmovi v:out:f32, imm:f32
        acc: none
        prefix: f32
        format: [pref_op_v_8_imm_32]
        opcode_idx: [0x0]
        properties: [float]
      - sig: fmovi.64 v:out:f64, imm:f64
        acc: none
        format: [op_v_8_imm_64]
        opcode_idx: [0xe]
        properties: [float]

  - title: Move null reference into the register
    description: Move null reference into the register.
    exceptions:
      - x_none
    verification:
      - none
    pseudo: >
      vd = null
    instructions:
      - sig: mov.null v:out:ref
        acc: none
        format: [op_v_8]
        opcode_idx: [0xf]

  - title: Load accumulator from the register
    description: Moves register content into accumulator.
    exceptions:
      - x_none
    verification:
      - v1_type
    pseudo: |
      acc = vs
    instructions:
      - sig: lda v:in:b32
        acc: out:b32
        format: [op_v_8]
        opcode_idx: [0x10]
      - sig: lda.64 v:in:b64
        acc: out:b64
        format: [op_v_8]
        opcode_idx: [0x11]
      - sig: lda.obj v:in:ref
        acc: out:ref
        format: [op_v_8]
        opcode_idx: [0x12]

  - title: Load accumulator from immediate
    description: >
      Load immediate into accumulator. For short formats immediate is sign-extended to operand size.
    exceptions:
      - x_none
    verification:
      - none
    pseudo: |
      acc = imm
    instructions:
      - sig: ldai imm:i32
        acc: out:i32
        format: [op_imm_8, op_imm_16, op_imm_32]
        opcode_idx: [0x13, 0x14, 0x15]
      - sig: ldai.64 imm:i64
        acc: out:i64
        format: [op_imm_64]
        opcode_idx: [0x16]
      - sig: fldai imm:f32
        acc: out:f32
        prefix: f32
        format: [pref_op_imm_32]
        opcode_idx: [0x1]
        properties: [float]
      - sig: fldai.64 imm:f64
        acc: out:f64
        format: [op_imm_64]
        opcode_idx: [0x17]
        properties: [float]

  - title: Load accumulator from string constant pool
    description: >
      Load string specified by id into accumulator. In dynamically-typed language context
      load string as 'any' value.
    properties:
      - string_id
      - language_type
      - maybe_dynamic
    exceptions:
      - x_oom
    verification:
      - constant_string_id
    pseudo: |
      acc = load(id)
    instructions:
      - sig: lda.str string_id
        acc: out:ref
        format: [op_id_32]
        opcode_idx: [0x18]

  - title: Create and initialize new constant array
    description: >
      Create a new single-dimensional constant literal array and put a reference to it into register.
    properties:
      - literalarray_id
    exceptions:
      - x_oom
    verification:
      - constant_literalarray_id
    pseudo: |
      arr = load(id)
      if arr == nullptr then
        throw OutOfMemoryError
      end
      v = arr
    instructions:
      - sig: lda.const v:out:ref, literalarray_id
        acc: none
        format: [op_v_8_id_16]
        opcode_idx: [0x19]

  - title: Load accumulator from type constant pool
    description: Load type specified by id into accumulator.
    properties:
      - type_id
      - language_type
    exceptions:
      - x_link
    verification:
      - type_id_class
    pseudo: |
      type = load(id)
      if type == nullptr then
        throw NoClassDefFoundError
      end
      acc = type
    instructions:
      - sig: lda.type type_id
        acc: out:ref
        format: [op_id_16]
        opcode_idx: [0x1a]

  - title: Load null reference into accumulator
    description: Load null reference into accumulator.
    exceptions:
      - x_none
    verification:
      - none
    pseudo: |
      acc = null
    instructions:
      - sig: lda.null
        acc: out:ref
        format: [op_none]
        opcode_idx: [0x1b]

  - title: Store accumulator
    description: Moves accumulator content into a register.
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      vd = acc
    instructions:
      - sig: sta v:out:b32
        acc: in:b32
        format: [op_v_8]
        opcode_idx: [0x1c]
      - sig: sta.64 v:out:b64
        acc: in:b64
        format: [op_v_8]
        opcode_idx: [0x1d]
      - sig: sta.obj v:out:ref
        acc: in:ref
        format: [op_v_8]
        opcode_idx: [0x1e]

  - title: Integer comparison
    description: Perform specified signed or unsigned integer comparison between register and accumulator.
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
        if acc < vs then
          acc = -1
        else if acc == vs then
          acc = 0
        else
          acc = 1
        end
    instructions:
      - sig: cmp.64 v:in:i64
        acc: inout:i64->i32
        format: [op_v_8]
        opcode_idx: [0x1f]
      - sig: ucmp v:in:u32
        acc: inout:u32->i32
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x0]
      - sig: ucmp.64 v:in:u64
        acc: inout:u64->i32
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x1]

  - title: Floating-point comparison
    description: Perform specified floating-point comparison between register and accumulator.
    properties:
      - float
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
      if isnan(acc) or isnan(vs) then
        switch (op)
        case fcmpg:
        case fcmpg.64:
          acc = 1
        case fcmpl:
        case fcmpl.64:
          acc = -1
      else
        if acc < vs then
          acc = -1
        else if acc == vs then
          acc = 0
        else
          acc = 1
        end
      end
    instructions:
      - sig: fcmpl v:in:f32
        acc: inout:f32->i32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x2]
      - sig: fcmpl.64 v:in:f64
        acc: inout:f64->i32
        format: [op_v_8]
        opcode_idx: [0x20]
      - sig: fcmpg v:in:f32
        acc: inout:f32->i32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x3]
      - sig: fcmpg.64 v:in:f64
        acc: inout:f64->i32
        format: [op_v_8]
        opcode_idx: [0x21]

  - title: Unconditional jump
    description: >
      Unconditionally transfer execution to an instruction at offset bytes from the beginning of the current
      instruction. Offset is sign-extended to the size of instruction address.
    properties:
      - jump
    exceptions:
      - x_none
    verification:
      - branch_target
    pseudo: |
      pc += imm
    instructions:
      - sig: jmp imm:i32
        acc: none
        format: [op_imm_8, op_imm_16, op_imm_32]
        opcode_idx: [0x22, 0x23, 0x24]

  - title: Conditional object comparison jump
    description: >
      Transfer execution to an instruction at offset bytes from the beginning of the current instruction if
      object references in accumulator and source register compare as specified. Offset is sign-extended to the size of
      instruction address.
    properties:
      - jump
      - conditional
    exceptions:
      - x_none
    verification:
      - branch_target
      - acc_obj_or_null
      - v1_obj_or_null
    pseudo: |
      switch (cc)
      case eq:
        if acc == vs then
          pc += imm
        end
      case ne:
        if acc != vs then
          pc += imm
      end
    instructions:
      - sig: jeq.obj v:in:ref, imm:i32
        acc: in:ref
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x25, 0x26]
      - sig: jne.obj v:in:ref, imm:i32
        acc: in:ref
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x27, 0x28]

  - title: Conditional compared to null jump
    description: >
      Transfer execution to an instruction at offset bytes from the beginning of the current instruction if
      object reference in accumulator compares with null as specified. Offset is sign-extended to the size of
      instruction address.
    properties:
      - jump
      - conditional
    exceptions:
      - x_none
    verification:
      - branch_target
      - acc_obj_or_null
    pseudo: |
      switch (cc)
      case eq:
        if acc == null then
          pc += imm
        end
      case ne:
        if acc != null then
          pc += imm
      end
    instructions:
      - sig: jeqz.obj imm:i32
        acc: in:ref
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x29, 0x2a]
      - sig: jnez.obj imm:i32
        acc: in:ref
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x2b, 0x2c]

  - title: Conditional compared to zero jump
    description: >
      Transfer execution to an instruction at offset bytes from the beginning of the current instruction if
      signed 32-bit integer in accumulator compares with 0 as specified. Offset is sign-extended to the size
      of instruction address.
    properties:
      - jump
      - conditional
    exceptions:
      - x_none
    verification:
      - branch_target
      - acc_type
    pseudo: |
      switch (cc)
      case eq:
        if acc == 0 then
          pc += imm
        end
      case ne:
        if acc != 0 then
          pc += imm
        end
      case lt:
        if acc < 0 then
          pc += imm
        end
      case gt:
        if acc > 0 then
          pc += imm
        end
      case le:
        if acc <= 0 then
          pc += imm
        end
      case ge:
        if acc >= 0 then
          pc += imm
        end
    instructions:
      - sig: jeqz imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x2d, 0x2e]
      - sig: jnez imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x2f, 0x30]
      - sig: jltz imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x31, 0x32]
      - sig: jgtz imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x33, 0x34]
      - sig: jlez imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x35, 0x36]
      - sig: jgez imm:i32
        acc: in:i32
        format: [op_imm_8, op_imm_16]
        opcode_idx: [0x37, 0x38]

  - title: Conditional compared to register jump
    description: >
      Transfer execution to an instruction at offset bytes from the beginning of the current instruction if signed
      32-bit integers in accumulator and register compare as specified. Offset is sign-extended to the size of
      instruction address.
    properties:
      - jump
      - conditional
    exceptions:
      - x_none
    verification:
      - branch_target
      - acc_type
      - v1_type
    pseudo: |
      diff = signed_cmp(acc, vs)
      switch (cc)
      case eq:
        if diff == 0 then
          pc += imm
        end
      case ne:
        if diff != 0 then
          pc += imm
        end
      case lt:
        if diff < 0 then
          pc += imm
        end
      case gt:
        if diff > 0 then
          pc += imm
        end
      case le:
        if diff <= 0 then
          pc += imm
        end
      case ge:
        if diff >= 0 then
          pc += imm
        end
    instructions:
      - sig: jeq v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x39, 0x3a]
      - sig: jne v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x3b, 0x3c]
      - sig: jlt v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x3d, 0x3e]
      - sig: jgt v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x3f, 0x40]
      - sig: jle v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x41, 0x42]
      - sig: jge v:in:i32, imm:i32
        acc: in:i32
        format: [op_v_8_imm_8, op_v_8_imm_16]
        opcode_idx: [0x43, 0x44]

  - title: Floating-point unary
    description: Perform specified floating-point operation on accumulator.
    properties:
      - float
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      switch (op)
      case fneg:
      case fneg.64:
        acc = -acc
    instructions:
      - sig: fneg
        acc: inout:f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0x4]
      - sig: fneg.64
        acc: inout:f64
        format: [op_none]
        opcode_idx: [0x45]

  - title: Unary
    description: Perform specified operation on accumulator.
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      switch (op)
      case neg:
      case neg.64:
        acc = -acc
      case not:
      case not.64:
        acc = ~acc
    instructions:
      - sig: neg
        acc: inout:i32
        format: [op_none]
        opcode_idx: [0x46]
      - sig: neg.64
        acc: inout:i64
        format: [op_none]
        opcode_idx: [0x47]
      - sig: not
        acc: inout:i32
        prefix: bit
        format: [pref_op_none]
        opcode_idx: [0x0]
      - sig: not.64
        acc: inout:i64
        prefix: bit
        format: [pref_op_none]
        opcode_idx: [0x1]

  - title: Two address binary operation on accumulator
    description: Perform specified binary operation on accumulator and register, and store the result into accumulator.
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
      switch (op)
      case add2:
        acc = (acc + vs) % 2^32
      case add2.64:
        acc = (acc + vs) % 2^64
      case sub2:
        acc = (acc - vs) % 2^32
      case sub2.64:
        acc = (acc - vs) % 2^64
      case mul2:
        acc = (acc * vs) % 2^32
      case mul2.64:
        acc = (acc * vs) % 2^64
      case and2:
        acc = acc & vs
      case and2.64:
        acc = acc & vs
      case or2:
        acc = acc | vs
      case or2.64:
        acc = acc | vs
      case xor2:
        acc = acc ^ vs
      case xor2.64:
        acc = acc ^ vs
      case shl2:
        acc = (acc << (vs & 0x1f)) % 2^32
      case shl2.64:
        acc = (acc << (vs & 0x3f)) % 2^64
      case shr2:
        acc = acc >> (vs & 0x1f)
      case shr2.64:
        acc = acc >> (vs & 0x3f)
      case ashr2:
        acc = (acc < 0) ? ~(~acc >> vs & 0x1f) : acc >> vs & 0x1f
      case ashr2.64:
        acc = (acc < 0) ? ~(~acc >> vs & 0x3f) : acc >> vs & 0x3f
    instructions:
      - sig: add2 v:in:i32
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x48]
      - sig: add2.64 v:in:i64
        acc: inout:i64
        format: [op_v_8]
        opcode_idx: [0x49]
      - sig: sub2 v:in:i32
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x4a]
      - sig: sub2.64 v:in:i64
        acc: inout:i64
        format: [op_v_8]
        opcode_idx: [0x4b]
      - sig: mul2 v:in:i32
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x4c]
      - sig: mul2.64 v:in:i64
        acc: inout:i64
        format: [op_v_8]
        opcode_idx: [0x4d]
      - sig: and2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x2]
      - sig: and2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x3]
      - sig: or2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x4]
      - sig: or2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x5]
      - sig: xor2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x6]
      - sig: xor2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x7]
      - sig: shl2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x8]
      - sig: shl2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0x9]
      - sig: shr2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0xa]
      - sig: shr2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0xb]
      - sig: ashr2 v:in:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0xc]
      - sig: ashr2.64 v:in:i64
        acc: inout:i64
        prefix: bit
        format: [pref_op_v_8]
        opcode_idx: [0xd]

  - title: Two address binary operations on accumulator with results in the register
    description: Perform specified binary operation on accumulator and register, and store the result into the register.
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
      switch (op)
      case add2:
        vd = (acc + vs) % 2^32
      case add2.64:
        vd = (acc + vs) % 2^64
      case sub2:
        vd = (acc - vs) % 2^32
      case sub2.64:
        vd = (acc - vs) % 2^64
      case mul2:
        vd = (acc * vs) % 2^32
      case mul2.64:
        acc = (acc * vs) % 2^64
      case and2:
        vd = acc & vs
      case and2.64:
        vd = acc & vs
      case or2:
        vd = acc | vs
      case or2.64:
        vd = acc | vs
      case xor2:
        vd = acc ^ vs
      case xor2.64:
        vd = acc ^ vs
      case shl2:
        vd = (acc << (vs & 0x1f)) % 2^32
      case shl2.64:
        vd = (acc << (vs & 0x3f)) % 2^64
      case shr2:
        vd = acc >> (vs & 0x1f)
      case shr2.64:
        vd = acc >> (vs & 0x3f)
      case ashr2:
        vd = (acc < 0) ? ~(~acc >> vs & 0x1f) : acc >> vs & 0x1f
      case ashr2.64:
        vd = (acc < 0) ? ~(~acc >> vs & 0x3f) : acc >> vs & 0x3f
    instructions:
      - sig: add2v v1:out:i32, v2:in:i32
        acc: in:i32
        format: [op_v1_8_v2_8]
      - sig: add2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        format: [op_v1_8_v2_8]
      - sig: sub2v v1:out:i32, v2:in:i32
        acc: in:i32
        format: [op_v1_8_v2_8]
      - sig: sub2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        format: [op_v1_8_v2_8]
      - sig: mul2v v1:out:i32, v2:in:i32
        acc: in:i32
        format: [op_v1_8_v2_8]
      - sig: mul2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        format: [op_v1_8_v2_8]
      - sig: and2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: and2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: or2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: or2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: xor2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: xor2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: shl2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: shl2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: shr2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: shr2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: ashr2v v1:out:i32, v2:in:i32
        acc: in:i32
        prefix: bit
        format: [pref_op_v1_8_v2_8]
      - sig: ashr2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        prefix: bit
        format: [pref_op_v1_8_v2_8]

  - title: Two address floating-point binary operation on accumulator
    description: |
      Perform specified floating-point binary operation on accumulator and register, and store the result into accumulator.
      The results of instructions correspond to the IEEE-754 arithmetic rules.

      - Any operation with NaN results in the NaN value.
      - The sum of opposite infinities or the difference of the same-sign infinities is NaN.
      - Division is NaN if Infinity is divided by Infinity.
      - Division is NaN if zero is divided by zero.
      - Multiplication is NaN if zero is multiplied by infinity.
      - The sign of division or multiplication result is positive if both values have the same sign, or negative if the values have different signs.
      - Division is infinity if any nonzero value is divided by zero.
      - Multiplication is infinity if any nonzero value is multiplied by infinity.
      - The sum of two infinities of the same sign or the difference of two infinities of opposite signs is infinity. The sign of the result matches
        the sign of the accumulator value.
      - The sum or the difference of infinity and any finite value is infinity. The sign of the result matches the sign of infinity.
      - The sum or the difference of zeros is zero. Exceptions are the sum of two negative zeros and the difference of negative and positive zeros - the result is negative zero.

    properties:
      - float
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
      switch (op)
      case fadd2:
      case fadd2.64:
        acc = acc + vs
      case fsub2:
      case fsub2.64:
        acc = acc - vs
      case fmul2:
      case fmul2.64:
        acc = acc * vs
      case fdiv2:
      case fdiv2.64:
        acc = acc / vs
      case fmod2:
      case fmod2.64:
        acc = acc % vs
    instructions:
      - sig: fadd2 v:in:f32
        acc: inout:f32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x5]
      - sig: fadd2.64 v:in:f64
        acc: inout:f64
        format: [op_v_8]
        opcode_idx: [0x4e]
      - sig: fsub2 v:in:f32
        acc: inout:f32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x6]
      - sig: fsub2.64 v:in:f64
        acc: inout:f64
        format: [op_v_8]
        opcode_idx: [0x4f]
      - sig: fmul2 v:in:f32
        acc: inout:f32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x7]
      - sig: fmul2.64 v:in:f64
        acc: inout:f64
        format: [op_v_8]
        opcode_idx: [0x50]
      - sig: fdiv2 v:in:f32
        acc: inout:f32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x8]
      - sig: fdiv2.64 v:in:f64
        acc: inout:f64
        format: [op_v_8]
        opcode_idx: [0x51]
      - sig: fmod2 v:in:f32
        acc: inout:f32
        prefix: f32
        format: [pref_op_v_8]
        opcode_idx: [0x9]
      - sig: fmod2.64 v:in:f64
        acc: inout:f64
        format: [op_v_8]
        opcode_idx: [0x52]

  - title: Two address floating-point binary operations on accumulator with the results in the register.
    description: |
      Perform specified floating-point binary operation on accumulator and register, and store the result into the register.
      The results of instructions correspond to the IEEE-754 arithmetic rules.

      - Any operation with NaN results in NaN value.
      - The sum of opposite infinities or the difference of the same-sign infinities is NaN.
      - Division is NaN if Infinity is divided by Infinity.
      - Division is NaN if zero is divided by zero.
      - Multiplication is NaN if zero is multiplied by infinity.
      - The sign of division or multiplication result is positive if both values have the same sign, negative if the values have different sign.
      - Division is infinity if any nonzero value is divided by zero.
      - Multiplication is infinity if any nonzero value is multiplied by infinity.
      - The sum of two infinities of the same sign or the difference of two infinities of opposite sign is infinity.
        The sign of result matches the sign of the accumulator value.
      - The sum or the difference of infinity and any finite value is infinity. The sign of result matches the sign of infinity.
      - The sum or the difference of zeros is zero. Exceptions are the sum of two negative zeros and the difference of negative and positive zeros - the result is negative zero.

    properties:
      - float
    exceptions:
      - x_none
    verification:
      - acc_type
      - v1_type
    pseudo: |
      switch (op)
      case fadd2:
      case fadd2.64:
        vd = acc + vs
      case fsub2:
      case fsub2.64:
        vd = acc - vs
      case fmul2:
      case fmul2.64:
        vd = acc * vs
      case fdiv2:
      case fdiv2.64:
        vd = acc / vs
      case fmod2:
      case fmod2.64:
        vd = acc % vs
    instructions:
      - sig: fadd2v v1:out:f32, v2:in:f32
        acc: in:f32
        prefix: f32
        format: [pref_op_v1_8_v2_8]
      - sig: fadd2v.64 v1:out:f64, v2:in:f64
        acc: in:f64
        format: [op_v1_8_v2_8]
      - sig: fsub2v v1:out:f32, v2:in:f32
        acc: in:f32
        prefix: f32
        format: [pref_op_v1_8_v2_8]
      - sig: fsub2v.64 v1:out:f64, v2:in:f64
        acc: in:f64
        format: [op_v1_8_v2_8]
      - sig: fmul2v v1:out:f32, v2:in:f32
        acc: in:f32
        prefix: f32
        format: [pref_op_v1_8_v2_8]
      - sig: fmul2v.64 v1:out:f64, v2:in:f64
        acc: in:f64
        format: [op_v1_8_v2_8]
      - sig: fdiv2v v1:out:f32, v2:in:f32
        acc: in:f32
        prefix: f32
        format: [pref_op_v1_8_v2_8]
      - sig: fdiv2v.64 v1:out:f64, v2:in:f64
        acc: in:f64
        format: [op_v1_8_v2_8]
      - sig: fmod2v v1:out:f32, v2:in:f32
        acc: in:f32
        prefix: f32
        format: [pref_op_v1_8_v2_8]
      - sig: fmod2v.64 v1:out:f64, v2:in:f64
        acc: in:f64
        format: [op_v1_8_v2_8]

  - title: Two address integer division and modulo on accumulator
    description: Perform integer division or modulo on accumulator and register, and store the result into accumulator.
    exceptions:
      - x_arith
    verification:
      - acc_type
      - v1_type
    pseudo: |
      if vs == 0 then
        throw ArithmeticException
      end
      switch (op)
      case div:
        if acc == INT32_MIN and vs == -1 then
          acc = INT32_MIN
        else
          acc = acc / vs
        end
      case div.64:
        if acc == INT64_MIN and vs == -1 then
          acc = INT64_MIN
        else
          acc = acc / vs
        end
      case divu:
      case divu.64:
        acc = acc / vs
      case mod:
        if acc == INT32_MIN and vs == -1 then
          acc = 0
        else
          acc = acc % vs
        end
      case mod.64:
        if acc == INT64_MIN and vs == -1 then
          acc = 0
        else
          acc = acc % vs
        end
      case modu:
      case modu.64:
        acc = acc % vs
    instructions:
      - sig: div2 v:in:i32
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x53]
      - sig: div2.64 v:in:i64
        acc: inout:i64
        format: [op_v_8]
        opcode_idx: [0x54]
      - sig: mod2 v:in:i32
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x55]
      - sig: mod2.64 v:in:i64
        acc: inout:i64
        format: [op_v_8]
        opcode_idx: [0x56]
      - sig: divu2 v:in:u32
        acc: inout:u32
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x2]
      - sig: divu2.64 v:in:u64
        acc: inout:u64
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x3]
      - sig: modu2 v:in:u32
        acc: inout:u32
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x4]
      - sig: modu2.64 v:in:u64
        acc: inout:u64
        prefix: unsigned
        format: [pref_op_v_8]
        opcode_idx: [0x5]

  - title: Two address integer division and modulo on accumulator with the result in the register
    description: Perform integer division or modulo on accumulator and register, and store the result into the register.
    exceptions:
      - x_arith
    verification:
      - acc_type
      - v1_type
    pseudo: |
      if vs == 0 then
        throw ArithmeticException
      end
      switch (op)
      case div:
        if acc == INT32_MIN and vs == -1 then
          vd = INT32_MIN
        else
          vd = acc / vs
        end
      case div.64:
        if acc == INT64_MIN and vs == -1 then
          vd = INT64_MIN
        else
          vd = acc / vs
        end
      case divu:
      case divu.64:
        vd = acc / vs
      case mod:
        if acc == INT32_MIN and vs == -1 then
          vd = 0
        else
          vd = acc % vs
        end
      case mod.64:
        if acc == INT64_MIN and vs == -1 then
          vd = 0
        else
          vd = acc % vs
        end
      case modu:
      case modu.64:
        vd = acc % vs
    instructions:
      - sig: div2v v1:out:i32, v2:in:i32
        acc: in:i32
        format: [op_v1_8_v2_8]
      - sig: div2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        format: [op_v1_8_v2_8]
      - sig: mod2v v1:out:i32, v2:in:i32
        acc: in:i32
        format: [op_v1_8_v2_8]
      - sig: mod2v.64 v1:out:i64, v2:in:i64
        acc: in:i64
        format: [op_v1_8_v2_8]
      - sig: divu2v v1:out:u32, v2:in:u32
        acc: in:u32
        prefix: unsigned
        format: [pref_op_v1_8_v2_8]
      - sig: divu2v.64 v1:out:u64, v2:in:u64
        acc: in:u64
        prefix: unsigned
        format: [pref_op_v1_8_v2_8]
      - sig: modu2v v1:out:u32, v2:in:u32
        acc: in:u32
        prefix: unsigned
        format: [pref_op_v1_8_v2_8]
      - sig: modu2v.64 v1:out:u64, v2:in:u64
        acc: in:u64
        prefix: unsigned
        format: [pref_op_v1_8_v2_8]

  - title: Two address binary operation with immediate on accumulator
    description: >
      Perform specified binary operation on accumulator and immediate, and store the result into accumulator.
      Immediate is sign-extended to operand size.
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      switch (op)
      case addi:
        acc = (acc + imm) % 2^32
      case subi:
        acc = (acc - imm) % 2^32
      case muli:
        acc = (acc * imm) % 2^32
      case andi:
        acc = acc & imm
      case ori:
        acc = acc | imm
      case xori:
        acc = acc ^ imm
      case shli:
        acc = (acc << (imm & 0x1f)) % 2^32
      case shri:
        acc = acc >> (imm & 0x1f)
      case ashri:
        acc = (acc < 0) ? ~(~acc >> imm & 0x1f) : acc >> imm & 0x1f
    instructions:
      - sig: addi imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x57]
      - sig: subi imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x58]
      - sig: muli imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x59]
      - sig: andi imm:i32
        acc: inout:i32
        format: [op_imm_32]
        opcode_idx: [0x5a]
      - sig: ori imm:i32
        acc: inout:i32
        format: [op_imm_32]
        opcode_idx: [0x5b]
      - sig: xori imm:i32
        acc: inout:i32
        prefix: bit
        format: [pref_op_imm_32]
        opcode_idx: [0xe]
      - sig: shli imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x5c]
      - sig: shri imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x5d]
      - sig: ashri imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x5e]

  - title: Two address binary operation with immediate
    description: >
      Perform specified binary operation and immediate, and store the result into the register.
      Immediate is sign-extended to operand size.
    exceptions:
      - x_none
    verification:
      - v1_type
      - v2_type
    pseudo: |
      switch (op)
      case addi:
        v1 = (v2 + imm) % 2^32
      case subi:
        v1 = (v2 - imm) % 2^32
      case muli:
        v1 = (v2 * imm) % 2^32
      case andi:
        v1 = v2 & imm
      case ori:
        v1 = v2 | imm
      case xori:
        v1 = v2 ^ imm
      case shli:
        v1 = (v2 << (imm & 0x1f)) % 2^32
      case shri:
        v1 = v2 >> (imm & 0x1f)
      case ashri:
        v1 = (v2 < 0) ? ~(~v2 >> imm & 0x1f) : v2 >> imm & 0x1f
    instructions:
      - sig: addiv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: subiv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: muliv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: andiv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_32]
      - sig: oriv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_32]
      - sig: xoriv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4_imm_32]
      - sig: shliv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: shriv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: ashriv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]

  - title: Two address integer division or modulo with immediate on accumulator
    description: >
      Perform two address integer division or modulo on accumulator and immediate, and store the result into accumulator.
      Immediate is sign-extended to operand size.
    exceptions:
      - x_arith
    verification:
      - acc_type
    pseudo: |
      if imm == 0 then
        throw ArithmeticException
      end
      switch(op)
      case divi:
        if acc == INT32_MIN and imm == -1 then
          acc = INT32_MIN
        else
          acc = acc / imm
        end
      case modi:
        if acc == INT32_MIN and imm == -1 then
          acc = 0
        else
          acc = acc % imm
        end
    instructions:
      - sig: divi imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x5f]
      - sig: modi imm:i32
        acc: inout:i32
        format: [op_imm_8]
        opcode_idx: [0x60]

  - title: Two address integer division or modulo with immediate
    description: >
      Perform two address integer division or modulo and immediate, and store the result into the register.
      Immediate is sign-extended to operand size.
    exceptions:
      - x_arith
    verification:
      - v1_type
      - v2_type
    pseudo: |
      if imm == 0 then
        throw ArithmeticException
      end
      switch(op)
      case divi:
        if v1 == INT32_MIN and imm == -1 then
          v1 = INT32_MIN
        else
          v1 = v2 / imm
        end
      case modi:
        if v1 == INT32_MIN and imm == -1 then
          v1 = 0
        else
          v1 = v2 % imm
        end
    instructions:
      - sig: diviv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]
      - sig: modiv v1:out:i32, v2:in:i32, imm:i32
        acc: none
        format: [op_v1_4_v2_4_imm_8]

  - title: Three address binary operation
    description: Perform specified binary operation on two registers, and store the result into accumulator.
    exceptions:
      - x_none
    verification:
      - v1_type
      - v2_type
    pseudo: |
      switch (op)
      case add:
        acc = (vs1 + vs2) % 2^32
      case sub:
        acc = (vs1 - vs2) % 2^32
      case mul:
        acc = (vs1 * vs2) % 2^32
      case and:
        acc = vs1 & vs2
      case or:
        acc = vs1 | vs2
      case xor:
        acc = vs1 ^ vs2
      case shl:
        acc = (vs1 << (vs2 & 0x1f)) % 2^32
      case shr:
        acc = vs1 >> (vs2 & 0x1f)
      case ashr:
        acc = (vs1 < 0) ? ~(~vs1 >> vs2 & 0x1f) : vs1 >> vs2 & 0x1f
    instructions:
      - sig: add v1:in:i32, v2:in:i32
        acc: out:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x61]
      - sig: sub v1:in:i32, v2:in:i32
        acc: out:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x62]
      - sig: mul v1:in:i32, v2:in:i32
        acc: out:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x63]
      - sig: and v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0xf]
      - sig: or v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0x10]
      - sig: xor v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0x11]
      - sig: shl v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0x12]
      - sig: shr v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0x13]
      - sig: ashr v1:in:i32, v2:in:i32
        acc: out:i32
        prefix: bit
        format: [pref_op_v1_4_v2_4]
        opcode_idx: [0x14]

  - title: Three address binary operation with the result in the register
    description: Perform specified binary operation on two registers, and store the result into the register.
    exceptions:
      - x_none
    verification:
      - v1_type
      - v2_type
    pseudo: |
      switch (op)
      case add:
        v1 = (v1 + v2) % 2^32
      case sub:
        v1 = (v1 - v2) % 2^32
      case mul:
        v1 = (v1 * v2) % 2^32
      case and:
        v1 = v1 & v2
      case or:
        v1 = v1 | v2
      case xor:
        v1 = v1 ^ v2
      case shl:
        v1 = (v1 << (v2 & 0x1f)) % 2^32
      case shr:
        v1 = v1 >> (v2 & 0x1f)
      case ashr:
        v1 = (v1 < 0) ? ~(~v1 >> v2 & 0x1f) : v1 >> v2 & 0x1f
    instructions:
      - sig: addv v1:inout:i32, v2:in:i32
        acc: none
        format: [op_v1_4_v2_4]
      - sig: subv v1:inout:i32, v2:in:i32
        acc: none
        format: [op_v1_4_v2_4]
      - sig: mulv v1:inout:i32, v2:in:i32
        acc: none
        format: [op_v1_4_v2_4]
      - sig: andv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]
      - sig: orv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]
      - sig: xorv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]
      - sig: shlv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]
      - sig: shrv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]
      - sig: ashrv v1:inout:i32, v2:in:i32
        acc: none
        prefix: bit
        format: [pref_op_v1_4_v2_4]

  - title: Three address integer division or modulo
    description: Perform integer division or modulo on two registers, and store the result into accumulator.
    exceptions:
      - x_arith
    verification:
      - v1_type
      - v2_type
    pseudo: |
      if vs2 == 0 then
        throw ArithmeticException
      end
      switch(op)
      case div:
        if vs1 == INT32_MIN and vs2 == -1 then
          acc = INT32_MIN
        else
          acc = vs1 / vs2
        end
      case mod:
        if vs1 == INT32_MIN and vs2 == -1 then
          acc = 0
        else
          acc = vs1 % vs2
        end
    instructions:
      - sig: div v1:in:i32, v2:in:i32
        acc: out:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x64]
      - sig: mod v1:in:i32, v2:in:i32
        acc: out:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x65]

  - title: Three address integer division or modulo with the result in the register
    description: Perform integer division or modulo on two registers, and store the result into accumulator.
    exceptions:
      - x_arith
    verification:
      - v1_type
      - v2_type
    pseudo: |
      if v2 == 0 then
        throw ArithmeticException
      end
      switch(op)
      case div:
        if v1 == INT32_MIN and v2 == -1 then
          v1 = INT32_MIN
        else
          v1 = v1 / v2
        end
      case mod:
        if v1 == INT32_MIN and v2 == -1 then
          v1 = 0
        else
          v1 = v1 % v2
        end
    instructions:
      - sig: divv v1:inout:i32, v2:in:i32
        acc: none
        format: [op_v1_4_v2_4]
      - sig: modv v1:inout:i32, v2:in:i32
        acc: none
        format: [op_v1_4_v2_4]

  - title: Increment register with immediate
    description: >
      Increment virtual register by specified immediate. Immediate is sign-extended to operand size.
    exceptions:
      - x_none
    verification:
      - v1_i32
    pseudo: |
      vx = (vx + imm) % 2^32
    instructions:
      - sig: inci v:inout:i32, imm:i32
        acc: none
        format: [op_v_4_imm_4]
        opcode_idx: [0x66]

  - title: Conversions between integer and floating-point types
    description: |
      Perform specified primitive type conversion of accumulator.
      Conversion from floating-point types to integer type is performed by the following rules:

      - It is rounding toward zero.
      - If converted value is less than minimal value for destination type, then the result is the minimum value for that type.
      - If source is negative infinity, then the result is the minimum value for the destination type.
      - If converted value is greater than the maximum value for the destination type, then the result is the maximum value for that type.
      - If source is positive infinity, then the result is the maximum value for the destination type.
      - If source is NaN, then the result is equal to 0.

    properties:
      - float
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      (dest_type) acc = (src_type) acc
    instructions:
      - sig: i32tof32
        acc: inout:i32->f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xa]
      - sig: i32tof64
        acc: inout:i32->f64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x0]
      - sig: u32tof32
        acc: inout:u32->f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xb]
      - sig: u32tof64
        acc: inout:u32->f64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x1]
      - sig: i64tof32
        acc: inout:i64->f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xc]
      - sig: i64tof64
        acc: inout:i64->f64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x2]
      - sig: u64tof32
        acc: inout:u64->f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xd]
      - sig: u64tof64
        acc: inout:u64->f64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x3]
      - sig: f32tof64
        acc: inout:f32->f64
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xe]
      - sig: f32toi32
        acc: inout:f32->i32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0xf]
      - sig: f32toi64
        acc: inout:f32->i64
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0x10]
      - sig: f32tou32
        acc: inout:f32->u32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0x11]
      - sig: f32tou64
        acc: inout:f32->u64
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0x12]
      - sig: f64toi32
        acc: inout:f64->i32
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x4]
      - sig: f64toi64
        acc: inout:f64->i64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x5]
      - sig: f64tou32
        acc: inout:f64->u32
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x6]
      - sig: f64tou64
        acc: inout:f64->u64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x7]
      - sig: f64tof32
        acc: inout:f64->f32
        prefix: f32
        format: [pref_op_none]
        opcode_idx: [0x13]

  - title: Conversions from integer types to u1
    description: |
      Conversion from integer types to u1 is performed by the following rules:

      - If converted integer is not equal to zero, then the result is 1.
      - Otherwise, the result is 0.

    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      (dest_type) acc = (src_type) acc
    instructions:
      - sig: i32tou1
        acc: inout:i32->u1
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x8]
      - sig: i64tou1
        acc: inout:i64->u1
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x9]
      - sig: u32tou1
        acc: inout:u32->u1
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xa]
      - sig: u64tou1
        acc: inout:u64->u1
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xb]

  - title: Integer truncations and extensions
    description: >
      Perform specified integer extension or truncations of accumulator.
      Truncations discard all but N lowest-order bits, where N is the bit size of the destination type.
      If extension bytecode treats its source as signed integer, then the value is sign-extended to destination type.
      If extension bytecode treats its source as unsigned integer, then the value is zero-extended to destination type.
    exceptions:
      - x_none
    verification:
      - acc_type
    pseudo: |
      (dest_type) acc = (src_type) acc
    instructions:
      - sig: i32toi64
        acc: inout:i32->i64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xc]
      - sig: i32toi16
        acc: inout:i32->i16
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xd]
      - sig: i32tou16
        acc: inout:i32->u16
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xe]
      - sig: i32toi8
        acc: inout:i32->i8
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0xf]
      - sig: i32tou8
        acc: inout:i32->u8
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x10]
      - sig: i64toi32
        acc: inout:i64->i32
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x11]
      - sig: u32toi64
        acc: inout:u32->i64
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x12]
      - sig: u32toi16
        acc: inout:u32->i16
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x13]
      - sig: u32tou16
        acc: inout:u32->u16
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x14]
      - sig: u32toi8
        acc: inout:u32->i8
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x15]
      - sig: u32tou8
        acc: inout:u32->u8
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x16]
      - sig: u64toi32
        acc: inout:u64->i32
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x17]
      - sig: u64tou32
        acc: inout:u64->u32
        prefix: cast
        format: [pref_op_none]
        opcode_idx: [0x18]

  - title: Load from array
    description: >
      Load an element from array using accumulator as an index and put it into accumulator.
      If the size of an element is smaller then 32 bits, then it is zero or
      sign-extended (depending on bytecode) to i32.
    verification:
      - v1_array_type
      - acc_i32
    exceptions:
      - x_null
      - x_bounds
    pseudo: |
      if vs == null then
        throw NullPointerException
      end
      if acc < 0 || acc >= len(vs) then
        throw ArrayIndexOutOfBoundsException
      end
      if op == ldarr.8 then
        acc = i8toi32(vs[acc])
      else if op == ldarru.8 then
        acc = u8toi32(vs[acc])
      else if op == ldarr.16 then
        acc = i16toi32(vs[acc])
      else if op == ldarru.16 then
        acc = u16toi32(vs[acc])
      else
        acc = vs[acc]
      end
    instructions:
      - sig: ldarr.8 v:in:i8[]
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x67]
      - sig: ldarru.8 v:in:u8[]
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x68]
      - sig: ldarr.16 v:in:i16[]
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x69]
      - sig: ldarru.16 v:in:u16[]
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x6a]
      - sig: ldarr v:in:i32[]
        acc: inout:i32
        format: [op_v_8]
        opcode_idx: [0x6b]
      - sig: ldarr.64 v:in:i64[]
        acc: inout:i32->i64
        format: [op_v_8]
        opcode_idx: [0x6c]
      - sig: fldarr.32 v:in:f32[]
        acc: inout:i32->f32
        format: [op_v_8]
        opcode_idx: [0x6d]
        properties: [float]
      - sig: fldarr.64 v:in:f64[]
        acc: inout:i32->f64
        format: [op_v_8]
        opcode_idx: [0x6e]
        properties: [float]
      - sig: ldarr.obj v:in:ref[]
        acc: inout:i32->ref
        format: [op_v_8]
        opcode_idx: [0x6f]

  - title: Store to array
    description: >
      Store the accumulator content into the array slot pointed by index.
      If the size of an element to store is less than 32, then the accumulator
      content is truncated to storage size before storing.
    verification:
      - v1_array_type
      - v2_i32
      - acc_type
    exceptions:
      - x_null
      - x_bounds
      - x_store
    pseudo: |
      if vs1 == null then
        throw NullPointerException
      end
      if vs2 < 0 || vs2 >= len(vs1) then
        throw ArrayIndexOutOfBoundsException
      end
      if op == starr.obj && !has_type(acc, component_type(vs1))
        throw ArrayStoreException
      end
      if op == starr.8 then
        vs1[vs2] = truncateto8(acc)
      else if op == starr.16 then
        vs1[vs2] = truncateto16(acc)
      else
        vs1[vs2] = acc
      end
    instructions:
      - sig: starr.8 v1:in:i8[], v2:in:i32
        acc: in:i8
        format: [op_v1_4_v2_4]
        opcode_idx: [0x70]
      - sig: starr.16 v1:in:i16[], v2:in:i32
        acc: in:i16
        format: [op_v1_4_v2_4]
        opcode_idx: [0x71]
      - sig: starr v1:in:i32[], v2:in:i32
        acc: in:i32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x72]
      - sig: starr.64 v1:in:i64[], v2:in:i32
        acc: in:i64
        format: [op_v1_4_v2_4]
        opcode_idx: [0x73]
      - sig: fstarr.32 v1:in:f32[], v2:in:i32
        acc: in:f32
        format: [op_v1_4_v2_4]
        opcode_idx: [0x74]
        properties: [float]
      - sig: fstarr.64 v1:in:f64[], v2:in:i32
        acc: in:f64
        format: [op_v1_4_v2_4]
        opcode_idx: [0x75]
        properties: [float]
      - sig: starr.obj v1:in:ref[], v2:in:i32
        acc: in:ref
        format: [op_v1_4_v2_4]
        opcode_idx: [0x76]

  - title: Array length
    description: Get length of an array and put it into accumulator.
    verification:
      - v1_array
    exceptions:
      - x_null
    pseudo: |
      if x == null then
        throw NullPointerException
      end
      acc = len(vs)
    instructions:
      - sig: lenarr v:in:top[]
        acc: out:i32
        format: [op_v_8]
        opcode_idx: [0x77]

  - title: Create new array
    description: >
      Create a new single-dimensional array of given type and size and put a reference to it into register.
      Elements of array are initialized to a default value, i.e., 0 for primitive types and null for objects.
    verification:
      - type_id_array
      - v2_i32
    exceptions:
      - x_negsize
      - x_oom
    properties:
      - type_id
      - language_type
      - initialize_type
    pseudo: |
      if v2 < 0 then
        throw NegativeArraySizeException
      end
      type = resolve(type_id)
      v1 = new_array(v2, type)
      if not initialized(type)
        initialize(type)
      end
      if v1 == null then
        throw OutOfMemoryError
      end
    instructions:
      - sig: newarr v1:out:ref, v2:in:i32, type_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x78]

  - title: Create new object
    description: |
      Resolve class type from type_id, allocate memory for an object,
      initialize its fields with their default values (i.e., 0 for primitives
      and null for objects), and put a reference to the newly created object
      into the register. The object must be initialized by calling the
      initialization method before further usage.
    verification:
      - type_id_object
    exceptions:
      - x_oom
    properties:
      - type_id
      - initialize_type
    pseudo: |
      type = resolve(type_id)
      if not initialized(type)
        initialize(type)
      end
      v = new_instance(type)
      if v == null then
        throw OutOfMemoryError
      end
    instructions:
      - sig: newobj v:out:ref, type_id
        acc: none
        format: [op_v_8_id_16]
        opcode_idx: [0x79]

  - title: Create new object and call initializer
    description: >
      Resolve class type from initializer method_id, allocate memory for an
      object, initialize its fields with their default values (i.e., 0 for
      primitives and null for objects), call specified initializer, and put
      a reference to the newly created object into accumulator.
      method_id must resolve to an initializer. Non-range instructions can be
      used to pass up to 4 arguments. Unused register slot values are to be
      discarded, and corresponding registers are not to be passed to initializer).
      Range kinds of instruction is to be used for methods with more arguments.
      Such instructions take the required number of arguments starting from
      'vs' register.
    verification:
      - method_id_non_static
      - method_id_accessible
      - method_init_obj
      - compatible_arguments
    exceptions:
      - x_abstract
      - x_oom
      - x_call
    properties:
      - method_id
      - call
      - initialize_type
      - init_obj
      - short_long_range
    pseudo: |
      init, type = resolve(method_id)
      if not initialized(type)
        initialize(type)
      end
      acc = new_instance(type)
      if acc == null then
        throw OutOfMemoryError
      end
      init(acc, args)
    instructions:
      - sig: initobj.short method_id, v1:in:none, v2:in:none
        acc: out:ref
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x7a]
      - sig: initobj method_id, v1:in:none, v2:in:none, v3:in:none, v4:in:none
        acc: out:ref
        format: [op_v1_4_v2_4_v3_4_v4_4_id_16]
        opcode_idx: [0x7b]
      - sig: initobj.range method_id, v:in:none
        acc: out:ref
        format: [op_v_8_id_16]
        opcode_idx: [0x7c]

  - title: Get field from object to accumulator
    description: >
      Get field value from an object by field id and put it into accumulator.
      For a non-object variant, the size of the field is determined by the
      field_id. The most significant bits are sign- or unsigned-extended
      based on the field type to fit accumulator size. If field type size is
      less than 32, then the loaded value is sign- or zero-extended to i32
      depending on field type.
    verification:
      - v1_object
      - field_id_non_static
      - field_id_size
    properties:
      - field_id
    exceptions:
      - x_null
    pseudo: |
      if vs == null then
        throw NullPointerException
      end
      field = resolve(field_id)
      if op == ldobj and size(field) < 32 then
        acc = extendto32(vs.get(field))
      else
        acc = vs.get(field)
      end
    instructions:
      - sig: ldobj v:in:ref, field_id
        acc: out:b32
        format: [op_v_8_id_16]
        opcode_idx: [0x7d]
      - sig: ldobj.64 v:in:ref, field_id
        acc: out:b64
        format: [op_v_8_id_16]
        opcode_idx: [0x7e]
      - sig: ldobj.obj v:in:ref, field_id
        acc: out:ref
        format: [op_v_8_id_16]
        opcode_idx: [0x7f]

  - title: Store accumulator content into object field
    description: >
      Store the accumulator content into object field by field_id. For
      a non-object variant, the size of the actually stored value is determined
      by field_id, while other accumulator bits are discarded.
      If field type size is less than 32, then the accumulator content is
      truncated to storage size before storing.
    verification:
      - v1_object
      - field_id_non_static
      - field_id_size
      - acc_type
    properties:
      - field_id
    exceptions:
      - x_null
    pseudo: |
      if vs == null then
        throw NullPointerException
      end
      field = resolve(field_id)
      if op == stobj and size(field) < 32 then
        vs.set(field, truncate(field, acc))
      else
        vs.set(field, acc)
      end
    instructions:
      - sig: stobj v:in:ref, field_id
        acc: in:b32
        format: [op_v_8_id_16]
        opcode_idx: [0x80]
      - sig: stobj.64 v:in:ref, field_id
        acc: in:b64
        format: [op_v_8_id_16]
        opcode_idx: [0x81]
      - sig: stobj.obj v:in:ref, field_id
        acc: in:ref
        format: [op_v_8_id_16]
        opcode_idx: [0x82]

  - title: Get field from object to register
    description: >
      Get field value from an object by field id and put it into register.
      For a non-object variant, the size of the field is determined by the
      field_id, and the most significant bits are sign- or unsigned-extended
      based on the field type to fit register size. If field type size is less
      than 32, then the loaded value is sign- or zero-extended to i32
      depending on field type.
    verification:
      - v2_object
      - field_id_non_static
      - field_id_size
    properties:
      - field_id
    exceptions:
      - x_null
    pseudo: |
      if v2 == null then
        throw NullPointerException
      end
      field = resolve(field_id)
      if op == ldobj and size(field) < 32 then
        v1 = extendto32(v2.get(field))
      else
        v1 = v2.get(field)
      end
    instructions:
      - sig: ldobj.v v1:out:b32, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x83]
      - sig: ldobj.v.64 v1:out:b64, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x84]
      - sig: ldobj.v.obj v1:out:ref, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x85]

  - title: Store register content into object field
    description: >
      Store register content into object field by field_id. For a non-object
      variant the size of the actually stored value is determined by field_id,
      while other register bits are discarded.
      If field type size is less than 32, then the register content is truncated
      to storage size before storing.
    verification:
      - v1_type
      - v2_object
      - field_id_non_static
      - field_id_size
    properties:
      - field_id
    exceptions:
      - x_null
    pseudo: |
      if v2 == null then
        throw NullPointerException
      end
      field = resolve(field_id)
      if op == stobj and size(field) < 32 then
        v2.set(field, truncate(field, v1))
      else
        v2.set(field, v1)
      end
    instructions:
      - sig: stobj.v v1:in:b32, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x86]
      - sig: stobj.v.64 v1:in:b64, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x87]
      - sig: stobj.v.obj v1:in:ref, v2:in:ref, field_id
        acc: none
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x88]

  - title: Get static field
    description: >
      Get static field value by field_id and put it into accumulator. For a
      non-object variant, the size of the field is determined by field_id, the
      most significant bits are sign- or unsigned-extended based on field type
      to fit accumulator size.
      If field size is less then 32, then the result is sign- or
      unsigned-extended to i32 depending on field type.
    verification:
      - field_id_static
      - field_id_size
    properties:
      - static_field_id
      - initialize_type
    exceptions:
      - x_init
    pseudo: |
      field, type = resolve(field_id)
      if not initialized(type)
        initialize(type)
      end
      if op == ldstatic and size(field) < 32 then
        acc = extendto32(get_static(field))
      else
        acc = get_static(field)
      end
    instructions:
      - sig: ldstatic field_id
        acc: out:b32
        format: [op_id_16]
        opcode_idx: [0x89]
      - sig: ldstatic.64 field_id
        acc: out:b64
        format: [op_id_16]
        opcode_idx: [0x8a]
      - sig: ldstatic.obj field_id
        acc: out:ref
        format: [op_id_16]
        opcode_idx: [0x8b]

  - title: Store to static field
    description: >
      Store accumulator content into static field by field_id. For a non-object
      variant the size of the actually stored value is determined by field_id, other
      accumulator bits are discarded. If field type size is less than 32, then
      accumulator content is truncated to field size before storing.
    verification:
      - field_id_static
      - field_id_size
      - acc_type
    properties:
      - static_field_id
      - initialize_type
    exceptions:
      - x_init
    pseudo: |
      field, type = resolve(field_id)
      if not initialized(type)
        initialize(type)
      end
      if op == ststatic and size(field) < 32 then
        set_static(field, truncate(field, acc))
      else
        set_static(field, acc)
      end
    instructions:
      - sig: ststatic field_id
        acc: in:b32
        format: [op_id_16]
        opcode_idx: [0x8c]
      - sig: ststatic.64 field_id
        acc: in:b64
        format: [op_id_16]
        opcode_idx: [0x8d]
      - sig: ststatic.obj field_id
        acc: in:ref
        format: [op_id_16]
        opcode_idx: [0x8e]

  - title: Return value from method
    description: >
      Return from the current method, i.e., restore the frame of method invoker
      and return control to the invoker. Return value must be in accumulator.
    verification:
      - acc_return_type
    exceptions:
      - x_none
    properties:
      - return
    pseudo: |
      return acc
    instructions:
      - sig: return
        acc: in:b32
        format: [op_none]
        opcode_idx: [0x8f]
      - sig: return.64
        acc: in:b64
        format: [op_none]
        opcode_idx: [0x90]
      - sig: return.obj
        acc: in:ref
        format: [op_none]
        opcode_idx: [0x91]

  - title: Return from a void method
    description: >
      Return from the current method, i.e., restore the frame of method invoker
      and return control to the invoker. Caller must treat accumulator value as
      undefined, and cannot use it until accumulator in the caller frame is
      defined.
    verification:
      - none
    exceptions:
      - x_none
    properties:
      - return
    pseudo: |
      return
    instructions:
      - sig: return.void
        acc: none
        format: [op_none]
        opcode_idx: [0x92]

  - title: Throw exception
    description: >
      Throw an exception located in register. The current method is searched
      for the first exception handler that matches the class of exception. If
      exception handler is found, then control is passed to the exception
      handler. If no exception handler is found, then the frame of invoker is
      restored. If such frame exists, then the exception is re-thrown.
      If no such frame exists, then the current VM thread exits.
    verification:
      - v1_throw_type
    exceptions:
      - x_null
      - x_throw
    pseudo: |
      if vs == null then
        throw NullPointerException
      end
      throw vs
    instructions:
      - sig: throw v:in:ref
        acc: none
        format: [op_v_8]
        opcode_idx: [0x93]

  - title: Check cast
    description: >
      Resolve object type by specified id; if an object in accumulator can be
      cast to the resolved type, then the accumulator content remains unchanged.
      Otherwise, ClassCastException is thrown.
      Object of type O can be cast to type T if O is the same as T or is a
      subtype of T. For arrays, O can be cast to T if T is a root type in type
      hierarchy, or array elements of T and O are the same, or O is a subtype
      of a T array element.
      'null' object reference can be cast to every type.
    verification:
      - type_id_any_object
      - acc_obj_or_null
    exceptions:
      - x_cast
    properties:
      - type_id
    pseudo: |
      type = resolve(type_id)
      if acc != null and !has_type(acc, type) then
        throw ClassCastException
      end
    instructions:
      - sig: checkcast type_id
        acc: in:ref
        format: [op_id_16]
        opcode_idx: [0x94]

  - title: Is instance
    description: >
      Resolve object type by specified id, and if an object in accumulator is
      an instance of the resolved type, then put 1 into accumulator. Otherwise,
      put 0.
      Object of type O is instance of type T if O is the same as T, or is a
      subtype of T. For arrays, T must be a root type in type hierarchy, or
      array elements of T and O are the same, or O is a subtype of a T
      array element.
      'null' object is not an instance of any class.
    verification:
      - type_id_any_object
      - acc_obj_or_null
    exceptions:
      - x_classdef
    properties:
      - type_id
    pseudo: |
      type = resolve(type_id)
      if acc == null or !has_type(acc, type) then
        acc = 0
      else
        acc = 1
      end
    instructions:
      - sig: isinstance type_id
        acc: inout:ref->i32
        format: [op_id_16]
        opcode_idx: [0x95]

  - title: Static call
    description: >
      Call the indicated static method, i.e., create new frame, pass values of
      arguments, and continue the execution from the first instruction of a
      method.
      Callee must treat the accumulator value as undefined, and cannot use it
      until accumulator in the new frame is defined.
      Result (if any) is returned in accumulator (see 'Calling sequence'
      for more details).
      Method, its class, and the number of arguments is resolved by a given
      method_id in runtime constant-pool.
      Arguments are passed in source registers in the same order as in the
      method signature.
      Non-range instructions can be used to pass up to 4 arguments (unused
      register slot values are discarded, and corresponding registers are not
      passed to the callee).
      Range kind of instructions are to be used for methods with more arguments
      Such instructions take the required number of arguments starting from
      'vs' register.
    verification:
      - method_id_static
      - method_id_non_abstract
      - compatible_arguments
    properties:
      - static_method_id
      - call
      - initialize_type
      - short_long_range
    exceptions:
      - x_call
    pseudo: |
      if not initialized(type)
        initialize(type)
      end
      acc = call(method, args)
    instructions:
      - sig: call.short method_id, v1:in:top, v2:in:top
        acc: out:top
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x96]
      - sig: call method_id, v1:in:top, v2:in:top, v3:in:top, v4:in:top
        acc: out:top
        format: [op_v1_4_v2_4_v3_4_v4_4_id_16]
        opcode_idx: [0x97]
      - sig: call.range method_id, v:in:top
        acc: out:top
        format: [op_v_8_id_16]
        opcode_idx: [0x98]

  - title: Static call with accumulator as input
    description: >
      Call the indicated static method, i.e., create a new frame, pass values
      of arguments, and continue the execution from the first instruction of a
      method.
      Callee must treat the accumulator value as undefined, and cannot use it
      until accumulator in the new frame is defined.
      Result (if any) is returned in accumulator (see 'Calling sequence' for
      more details).
      Method, its class, and the number of arguments is resolved by a given
      method_id in runtime constant-pool.
      Arguments are passed in source registers in the same order as in the
      method signature.
      Non-range instructions can be used to pass up to 4 arguments (unused
      register slot values are discarded, and corresponding registers are not
      passed to the callee).
      Immediate operand encodes a position starting from 0 on which accumulator
      is passed.
    verification:
      - method_id_static
      - method_id_non_abstract
      - compatible_arguments
    properties:
      - static_method_id
      - call
      - short_long_range
    exceptions:
      - x_call
    pseudo: |
      args = []
      for (i = 0; i < 4; ++i)
        if (i < imm) then
          args[i] = regs[i]
        else if (i == imm) then
          args[i] = acc
        else
          args[i] = regs[i - 1]
        end
      end
      method = resolve(method_id)
      acc = call(method, args)
    instructions:
      - sig: call.acc.short method_id, v:in:top, imm:u1
        acc: inout:top
        format: [op_v_4_imm_4_id_16]
        opcode_idx: [0x99]
      - sig: call.acc method_id, v1:in:top, v2:in:top, v3:in:top, imm:u2
        acc: inout:top
        format: [op_v1_4_v2_4_v3_4_imm_4_id_16]
        opcode_idx: [0x9a]

  - title: Virtual calls
    description: >
      Call the indicated virtual method, i.e., create a new frame, pass values
      of arguments, and continue the execution from the first instruction of a
      method.
      Callee must treat the accumulator value as undefined, and cannot use it
      until accumulator in the new frame is defined.
      Result (if any) is returned in accumulator (see 'Calling sequence' for
      more details).
      Method, its class, and the number of arguments is resolved by a given
      method_id in runtime constant-pool based on object reference using
      language-specific semantics (currently only Java virtual methods are
      supported, further extensions are TBD).
      Object reference is passed in the first source register, arguments are
      passed starting from the second source register in the same order as in
      the method signature.
      Non-range instructions can be used to pass up to 4 arguments (including
      object reference).
      Unused register slot values are discarded, and corresponding registers
      are not passed to the callee).
      For methods with more arguments, range kinds of instruction are to be used.
      The instructions take the required number of arguments starting from
      'vs' register (including object reference).
    verification:
      - compatible_arguments
      - method_id_accessible
    exceptions:
      - x_null
      - x_abstract
      - x_call
    properties:
      - method_id
      - call
      - call_virt
      - short_long_range
    pseudo: |
      if args[0] == null then
        throw NullPointerException
      end
      method = resolve(method_id)
      if is_abstract(method) then
        throw AbstractMethodError
      end
      acc = call(method, args)
    instructions:
      - sig: call.virt.short method_id, v1:in:top, v2:in:top
        acc: out:top
        format: [op_v1_4_v2_4_id_16]
        opcode_idx: [0x9b]
      - sig: call.virt method_id, v1:in:top, v2:in:top, v3:in:top, v4:in:top
        acc: out:top
        format: [op_v1_4_v2_4_v3_4_v4_4_id_16]
        opcode_idx: [0x9c]
      - sig: call.virt.range method_id, v:in:top
        acc: out:top
        format: [op_v_8_id_16]
        opcode_idx: [0x9d]

  - title: Virtual calls with accumulator as input
    description: >
      Call the indicated virtual method, i.e., create a new frame, pass values
      of arguments, and continue the execution from the first instruction of a
      method.
      Callee must treat the accumulator value as undefined, and cannot use it
      until accumulator in the new frame is defined.
      Result (if any) is returned in accumulator (see 'Calling sequence' for
      more details).
      Method, its class, and the number of arguments is resolved by a given
      method_id in runtime constant-pool based on object reference using
      language-specific semantics (currently only Java virtual methods are
      supported, further extensions are TBD).
      Object reference is passed in the first source register, arguments are
      passed starting from the second source register in the same order as
      in the method signature.
      Non-range instructions can be used to pass up to 4 arguments (including
      object reference). Unused register slot values are discarded, and
      corresponding registers are not passed to the callee).
      Immediate operand encodes a position starting from 0 on which accumulator
      is passed.
    verification:
      - compatible_arguments
      - method_id_accessible
    exceptions:
      - x_null
      - x_abstract
      - x_call
    properties:
      - method_id
      - call
      - call_virt
      - short_long_range
    pseudo: |
      args = []
      for (i = 0; i < 4; ++i)
        if (i < imm) then
          args[i] = regs[i]
        else if (i == imm) then
          args[i] = acc
        else
          args[i] = regs[i - 1]
        end
      end
      if args[0] == null then
        throw NullPointerException
      end
      method = resolve(method_id)
      if is_abstract(method) then
        throw AbstractMethodError
      end
      acc = call(method, args)
    instructions:
      - sig: call.virt.acc.short method_id, v:in:top, imm:u1
        acc: inout:top
        format: [op_v_4_imm_4_id_16]
        opcode_idx: [0x9e]
      - sig: call.virt.acc method_id, v1:in:top, v2:in:top, v3:in:top, imm:u2
        acc: inout:top
        format: [op_v1_4_v2_4_v3_4_imm_4_id_16]
        opcode_idx: [0x9f]

  - title: Dynamic move register-to-register
    description: >
      Move 'any' values between registers
    verification:
      - valid_in_dynamic_context
    exceptions:
      - x_none
    properties:
      - dynamic
    pseudo: |
      vd = vs
    instructions:
      - sig: mov.dyn v1:out:any, v2:in:any
        acc: none
        format: [op_v1_8_v2_8, op_v1_16_v2_16]
        opcode_idx: [0xa0, 0xa1]

  - title: Dynamic load accumulator from register
    description: >
      Move 'any' value from register to accumulator
    verification:
      - valid_in_dynamic_context
    exceptions:
      - x_none
    properties:
      - dynamic
    pseudo: |
      acc = v
    instructions:
      - sig: lda.dyn v:in:any
        acc: out:any
        format: [op_v_8]
        opcode_idx: [0xa2]

  - title: Dynamic store accumulator
    description: >
      Move 'any' value from accumulator to register
    verification:
      - valid_in_dynamic_context
    exceptions:
      - x_none
    properties:
      - dynamic
    pseudo: |
      v = acc
    instructions:
      - sig: sta.dyn v:out:any
        acc: in:any
        format: [op_v_8]
        opcode_idx: [0xa3]

  - title: Dynamic load accumulator from immediate
    description: >
      Move immediate as 'any' value to accumulator
    verification:
      - valid_in_dynamic_context
    exceptions:
      - x_none
    properties:
      - dynamic
    pseudo: |
      acc = imm
    instructions:
      - sig: ldai.dyn imm:i32
        acc: out:any
        format: [op_imm_32]
        opcode_idx: [0xa4]
      - sig: fldai.dyn imm:f64
        acc: out:any
        format: [op_imm_64]
        opcode_idx: [0xa5]
        properties: [float, dynamic]
