# plugin ets_string
# Copyright (c) 2024-2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative 'string_helpers.irt'
include_relative '../../plugins/ets/irtoc_scripts/common.irt'

module Constants
  MEM_BLOCK_8_BYTES = "8"
  MEM_BLOCK_16_BYTES = "16"
  MEM_BLOCK_32_BYTES = "32"
  MEM_BLOCK_32_ALIGN_MASK = "~31ULL"
  LOG2_BITS_PER_U8 = "3"
  LOG2_BITS_PER_U16 = "4"
  LOG2_BYTES_PER_U16 = "1"
  LOG2_BYTES_PER_OBJ_PTR = "2" # object pointer has a size of 4 bytes on each supported platform
  XOR_SUB_U8_MASK = "0x0101010101010101ULL"
  XOR_AND_U8_MASK = "0x8080808080808080ULL"
  MAX_U8_VALUE = "255"
  U8_SIZE = "1"
  U16_SIZE = "2"
  OBJ_PTR_SIZE = "ark::OBJECT_POINTER_SIZE"
  WRONG_CHAR_FLAG_MASK = "0x10000UL"
end

# It is assumed that _begin_index and _end_index are safe and does not check/normalize them.
# The range is [_begin_index, _end_index).
# Note, a caller of this macro must provide a corresponding 'SlowPathEntrypoint'
# for the case when 'allocate_string_tlab' fails (see StringTrim as an example)
# Now TLAB implementation initializes memory with zero, so the hashcode field
# is not initialized with zero explicitly.
macro(:fast_substring) do |_str, _str_len, _begin_index, _end_index, _not_compressed|
  _char_count := Sub(_end_index, _begin_index).u32
  If(_char_count, Cast(_str_len).u32).EQ.Unlikely.b {
    # Return the string itself
    _same_str := Cast(_str).SrcType(Constants::COMPILER_REFERENCE).ptr
    Goto(:_Fast_Substring_Result_No_Barrier)
  }
  _klass := load_class(_str)
  If(_char_count, 0).EQ.Unlikely.b {
    # Allocate and return an empty string
    _empty_str := allocate_string_tlab(_klass, 0)
    Goto(:_Fast_Substring_Result)
  }
  # Allocate a new normal string
  _offset := Shl(_begin_index, _not_compressed).u32
  _src_str_data := Add(Cast(_str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  _src_str_data := Add(_src_str_data, Cast(_offset).u64).ptr
  If(_not_compressed, 1).EQ.Unlikely.b {
    _compressable := is_array_of_compressable_chars(_src_str_data, Cast(_char_count).u64)
    If(_compressable, 1).EQ.Likely.b {
      _data_size1 := Cast(_char_count).word
      Goto(:_L1)
    }
    _data_size2 := Cast(ShlI(_char_count).Imm(1).u32).word
Label(:_L1)
    _data_size := Phi(_data_size1, _data_size2).word
    _new_str1 := allocate_string_tlab(_klass, _data_size)
    _new_str_data := Add(_new_str1, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
    If(_compressable, 1).EQ.Likely.b {
      compress_u16_to_u8_chars(_src_str_data, _new_str_data, Cast(_char_count).u64)
      StoreI(_new_str1, ShlI(_char_count).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      Goto(:_Fast_Substring_Result)
    }
    copy_u16_chars(_src_str_data, _new_str_data, Cast(_char_count).u64)
    StoreI(_new_str1, OrI(ShlI(_char_count).Imm(1).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
    Goto(:_Fast_Substring_Result)
  }
  # Source string is already compressed
  _new_str2 := allocate_string_tlab(_klass, Cast(_char_count).word)
  _new_str_data2 := Add(_new_str2, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  copy_u8_chars(_src_str_data, _new_str_data2, Cast(_char_count).u64)
  StoreI(_new_str2, ShlI(_char_count).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
Label(:_Fast_Substring_Result)
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  _substring := Phi(_empty_str, _new_str1, _new_str1, _new_str2).ptr
Label(:_Fast_Substring_Result_No_Barrier)
  _result := Phi(_same_str, _substring).ptr
end


#
# Test if u16 char is a white space
#
scoped_macro(:is_white_space_u16) do |ch|
  IfImm(Compare(ch, 0x0020).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x000E..0x009F -- common non-whitespace chars
  IfImm(Compare(ch, 0x000E).AE.b).Imm(0).NE.b {
    IfImm(Compare(ch, 0x00A0).B.b).Imm(0).NE.b {
      Goto(:LabelNotWhiteSpaceChar)
    }
  }
  # 0x0009 -- horizontal tab
  # 0x000A -- line feed or new line
  # 0x000B -- vertical tab
  # 0x000C -- formfeed
  # 0x000D -- carriage return
  IfImm(Compare(ch, 0x0009).B.b).Imm(0).NE.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  IfImm(Compare(ch, 0x000D).BE.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x00A0 -- non-breaking space
  IfImm(Compare(ch, 0x00A0).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x1680 -- Ogham space mark
  If(ch, 0x1680).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2000 -- en quad
  # 0x2001 -- em quad
  # 0x2002 -- en space
  # 0x2003 -- em space
  # 0x2004 -- three-per-em space
  # 0x2005 -- four-per-em space
  # 0x2006 -- six-per-em space
  # 0x2007 -- figure space
  # 0x2008 -- punctuation space
  # 0x2009 -- thin space
  # 0x200A -- hair space
  If(ch, 0x2000).B.Unlikely.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  If(ch, 0x200A).BE.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2028 -- line separator
  If(ch, 0x2028).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2029 -- paragraph separator
  If(ch, 0x2029).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x202F -- narrow no-break space
  If(ch, 0x202F).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x205F -- medium mathematical space
  If(ch, 0x205F).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0xFEFF -- byte order mark
  If(ch, 0xFEFF).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x3000 -- ideographic space
  If(ch, 0x3000).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
Label(:LabelNotWhiteSpaceChar)
  whiteSpace0 := 0
  Goto(:LabelReturn)
Label(:LabelWhiteSpaceChar)
  whiteSpace1 := 1
Label(:LabelReturn)
  result := Phi(whiteSpace0, whiteSpace1).b
end

#
# Test if u8 char is a white space
#
scoped_macro(:is_white_space_u8) do |ch|
  IfImm(Compare(ch, 0x20).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x0E..0x9F -- common non-whitespace chars
  IfImm(Compare(ch, 0x0E).AE.b).Imm(0).NE.b {
    IfImm(Compare(ch, 0xA0).B.b).Imm(0).NE.b {
      Goto(:LabelNotWhiteSpaceChar)
    }
  }
  # 0x09 -- horizontal tab
  # 0x0A -- line feed or new line
  # 0x0B -- vertical tab
  # 0x0C -- formfeed
  # 0x0D -- carriage return
  IfImm(Compare(ch, 0x09).B.b).Imm(0).NE.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  IfImm(Compare(ch, 0x0D).BE.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0xA0 -- non-breaking space
  IfImm(Compare(ch, 0xA0).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
Label(:LabelNotWhiteSpaceChar)
  whiteSpace0 := 0
  Goto(:LabelReturn)
Label(:LabelWhiteSpaceChar)
  whiteSpace1 := 1
Label(:LabelReturn)
  result := Phi(whiteSpace0, whiteSpace1).b
end


function(:CharIsWhiteSpace,
          params: {ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  Return(is_white_space_u16(ch)).b
}


function(:StringEmpty,
          params: {str: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  klass := load_class(str)
  empty_str := allocate_string_tlab(klass, 0)
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(empty_str).ptr
Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("CREATE_EMPTY_STRING_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY).AddImm(entrypoint).MethodAsImm("CreateEmptyString1ArgBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}


if Options.arch == :arm64
  trim_left_regs = $temps_mask + :callee0 + :callee1
  trim_right_regs = $temps_mask + :callee0 + :callee1
else
  trim_left_regs = $temps_mask + :callee0 + :caller0 + :caller1
  trim_right_regs = $temps_mask + :callee0 + :caller0 + :caller1
end


function(:StringTrimLeftBase,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  length := ShrI(length_packed).Imm(1).i32
  start_index := Cast(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)
    i := Phi(start_index, i1).i32
    ws1 := is_white_space_u8(Load(str_data, i).u8)
    If(ws1, 0).NE.Likely.b {
      i1 := AddI(i).Imm(1).i32
      If(i1, length).LT.Likely.b {
        Goto(:Loop1)
      }
    }
    index1 := Phi(i, i1).i32
    Goto(:TrimLeft)
  }
  # String contains 16-bit chars
Label(:Loop2)
  j := Phi(start_index, j1).i32
  ws2 := is_white_space_u16(Load(str_data, ShlI(j).Imm(1).i32).u16)
  If(ws2, 0).NE.Likely.b {
    j1 := AddI(j).Imm(1).i32
    If(j1, length).LT.Likely.b {
      Goto(:Loop2)
    }
  }
  index2 := Phi(j, j1).i32
Label(:TrimLeft)
  index := Phi(index1, index2).i32
  trimmed := fast_substring(str, length, index, length, not_compressed)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("SUB_STRING_FROM_STRING_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, str, index, length).AddImm(entrypoint).MethodAsImm("SubStringFromStringOddSavedBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}


function(:StringTrimLeft,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $trim_left_regs,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    ws1 := is_white_space_u8(Load(str_data, 0).u8)
    Goto(:L1)
  }
  ws2 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L1)
  ws := Phi(ws1, ws2).b
  If(ws, 0).EQ.Likely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  If(ShrI(length_packed).Imm(1).i32, 1).EQ.Unlikely.b {
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset("STRING_EMPTY")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm("StringEmpty").Terminator.ptr
  }
  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(unused1).DstReg(regmap[:arg1]).i32
  LiveOut(unused2).DstReg(regmap[:arg2]).i32
  entrypoint2 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm("StringTrimLeftBase").Terminator.ptr
}


function(:StringTrimRightBase,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  length := ShrI(length_packed).Imm(1).i32
  start_index := SubI(length).Imm(2).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)
    i := Phi(start_index, i1).i32
    ws1 := is_white_space_u8(Load(str_data, i).u8)
    If(ws1, 0).NE.Likely.b {
      i1 := SubI(i).Imm(1).i32
      If(i1, 0).GE.Likely.b {
        Goto(:Loop1)
      }
    }
    index1 := Phi(i, i1).i32
    Goto(:TrimRight)
  }
  # String contains 16-bit chars
Label(:Loop2)
  j := Phi(start_index, j1).i32
  ws2 := is_white_space_u16(Load(str_data, ShlI(j).Imm(1).i32).u16)
  If(ws2, 0).NE.Likely.b {
    j1 := SubI(j).Imm(1).i32
    If(j1, 0).GE.Likely.b {
      Goto(:Loop2)
    }
  }
  index2 := Phi(j, j1).i32
Label(:TrimRight)
  index := Phi(index1, index2).i32
  index := AddI(index).Imm(1).i32
  trimmed := fast_substring(str, length, 0, index, not_compressed)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("SUB_STRING_FROM_STRING_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, str, Cast(0).i32, index).AddImm(entrypoint).MethodAsImm("SubStringFromStringOddSavedBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}


function(:StringTrimRight,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $trim_right_regs,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  length := ShrI(length_packed).Imm(1).i32
  last_char_index :=  SubI(length).Imm(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    ws1 := is_white_space_u8(Load(str_data, last_char_index).u8)
    Goto(:L1)
  }
  ws2 := is_white_space_u16(Load(str_data, ShlI(last_char_index).Imm(1).i32).u16)
Label(:L1)
  ws := Phi(ws1, ws2).b
  If(ws, 0).EQ.Likely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  If(length, 1).EQ.Unlikely.b {
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset("STRING_EMPTY")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm("StringEmpty").Terminator.ptr
  }
  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(unused1).DstReg(regmap[:arg1]).i32
  LiveOut(unused2).DstReg(regmap[:arg2]).i32
  entrypoint2 = get_entrypoint_offset("STRING_TRIM_RIGHT_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm("StringTrimRightBase").Terminator.ptr
}


function(:StringTrimBase,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  length := ShrI(length_packed).Imm(1).i32
  left := 0
  right := SubI(length).Imm(2).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)  # while (utf::IsWhiteSpaceChar(str->At(right)))
    right1 := Phi(right, right2).i32
    If(is_white_space_u8(Load(str_data, right1).u8), 0).NE.Likely.b {
      If(right1, 0).EQ.Unlikely.b {
        Goto(:Trim)
      }
      right2 := SubI(right1).Imm(1).i32
      Goto(:Loop1)
    }
Label(:Loop2)  # while (left < right && utf::IsWhiteSpaceChar(str->At(left)))
    left1 := Phi(left, left2).i32
    If(left1, right1).LT.Unlikely.b {
      If(is_white_space_u8(Load(str_data, left1).u8), 0).NE.Likely.b {
        left2 := AddI(left1).Imm(1).i32
        Goto(:Loop2)
      }
    }
    right3 := AddI(right1).Imm(1).i32
    Goto(:Trim)
  }
  # String contains 16-bit chars
Label(:Loop3)  # while (utf::IsWhiteSpaceChar(str->At(right)))
  right11 := Phi(right, right22).i32
  If(is_white_space_u16(Load(str_data, ShlI(right11).Imm(1).i32).u16), 0).NE.Likely.b {
    If(right11, 0).EQ.Unlikely.b {
      Goto(:Trim)
    }
    right22 := SubI(right11).Imm(1).i32
    Goto(:Loop3)
  }
Label(:Loop4)  # while (left < right && utf::IsWhiteSpaceChar(str->At(left)))
  left11 := Phi(left, left22).i32
  If(left11, right11).LT.Unlikely.b {
    If(is_white_space_u16(Load(str_data, ShlI(left11).Imm(1).i32).u16), 0).NE.Likely.b {
      left22 := AddI(left11).Imm(1).i32
      Goto(:Loop4)
    }
  }
  right33 := AddI(right11).Imm(1).i32
Label(:Trim)
  l := Phi(left, left1, left, left11).i32
  r := Phi(right1, right3, right11, right33).i32
  trimmed := fast_substring(str, length, l, r, not_compressed)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("SUB_STRING_FROM_STRING_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, str, l, r).AddImm(entrypoint).MethodAsImm("SubStringFromStringOddSavedBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}


function(:StringTrim,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # length == 0
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  not_compressed := AndI(length_packed).Imm(1).i32
  length := ShrI(length_packed).Imm(1).i32
  # length == 1
  If(length, 1).EQ.b {
    If(not_compressed, 0).EQ.Likely.b {
      ws1 := is_white_space_u8(Load(str_data, 0).u8)
      Goto(:L1)
    }
    ws2 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L1)
    ws3 := Phi(ws1, ws2).b
    If(ws3, 0).EQ.Likely.b {
      Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
    }
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset("STRING_EMPTY")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm("StringEmpty").Terminator.ptr
  }
  # length > 1
  last_char_index := SubI(length).Imm(1).i32
  If(not_compressed, 0).EQ.Likely.b {
    ws4 := is_white_space_u8(Load(str_data, last_char_index).u8)
    Goto(:L2)
  }
  ws5 := is_white_space_u16(Load(str_data, ShlI(last_char_index).Imm(1).i32).u16)
Label(:L2)
  ws6 := Phi(ws4, ws5).b
  If(ws6, 0).EQ.Likely.b {
    # last char is not whitespace, so check the first char
    If(not_compressed, 0).EQ.Likely.b {
      ws7 := is_white_space_u8(Load(str_data, 0).u8)
      Goto(:L3)
    }
    ws8 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L3)
    ws9 := Phi(ws7, ws8).b
    If(ws9, 0).EQ.Likely.b {
      # first char is not white space, so return 'str'
      Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
    }
    Goto(:FirstCharWhitespace)
  }
  # last char is whitespace, so call StringTrimBase
  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(unused1).DstReg(regmap[:arg1]).i32
  LiveOut(unused2).DstReg(regmap[:arg2]).i32
  entrypoint2 = get_entrypoint_offset("STRING_TRIM_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm("StringTrimBase").Terminator.ptr
Label(:FirstCharWhitespace)
  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(unused1).DstReg(regmap[:arg1]).i32
  LiveOut(unused2).DstReg(regmap[:arg2]).i32
  entrypoint3 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint3).MethodAsImm("StringTrimLeftBase").Terminator.ptr
}


scoped_macro(:at) do |str_data, index, not_compressed|
  If(not_compressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
    c8 := Cast(Load(str_data, index).u8).u16
    Goto(:Done)
  }
  # String contains 16-bit chars
  c16 := Load(str_data, ShlI(index).Imm(1).i32).u16
Label(:Done)
  c := Phi(c8, c16).u16
end


function(:StringStartsWithBase,
          params: {str: 'ref', pfx: 'ref', from_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_not_compressed := AndI(str_len_packed).Imm(1).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  pfx_len_packed := LoadI(pfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  pfx_len := ShrI(pfx_len_packed).Imm(1).i32
  pfx_not_compressed := AndI(pfx_len_packed).Imm(1).i32
  pfx_data := Add(Cast(pfx).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

  pfx_i1 := 0
Label(:Loop)
  str_i := Phi(from_index, str_i1).i32
  pfx_i := Phi(pfx_i1, pfx_i2).i32
  If(pfx_i, pfx_len).GE.Unlikely.b {
    Goto(:Done)
  }
  s := at(str_data, str_i, str_not_compressed)
  p := at(pfx_data, pfx_i, pfx_not_compressed)
  If(s, p).NE.Likely.b {
    Return(0).b
  }
  pfx_i2 := AddI(pfx_i).Imm(1).i32
  str_i1 := AddI(str_i).Imm(1).i32
  Goto(:Loop)
Label(:Done)
  Return(1).b
}


function(:StringStartsWith,
          params: {str: 'ref', pfx: 'ref', from_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  pfx_len_packed := LoadI(pfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'true' if prefix is empty
  # The least significant bit indicates COMPRESSED/UNCOMPRESSED,
  # thus if (packed length <= 1) then the actual length is equal to 0.
  If(pfx_len_packed, 1).LE.Unlikely.b {
    Return(1).b
  }

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'false' if 'str' is empty as 'prefix' is not empty.
  If(str_len_packed, 1).LE.Unlikely.b {
    Return(0).b
  }

  # If 'from_index' is less than zero then make it zero.
  IfImm(Compare(from_index, 0).LT.b).Imm(0).NE.Unlikely.b {
    from_index1 := Cast(0).i32
  }
  from_index2 := Phi(from_index, from_index1).i32

  str_len := ShrI(str_len_packed).Imm(1).i32
  pfx_len := ShrI(pfx_len_packed).Imm(1).i32

  If(from_index2, Sub(str_len, pfx_len).i32).GT.Unlikely.b {
    # Return 'false' in this case, as we know that 'pfx' is not empty
    # and it is longer than the part of 'str' to be checked.
    Return(0).b
  }

  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(pfx).DstReg(regmap[:arg1]).ref
  LiveOut(from_index2).DstReg(regmap[:arg2]).i32
  entrypoint = get_entrypoint_offset("STRING_STARTS_WITH_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringStartsWithBase").Terminator.b
}


function(:StringEndsWithBase,
          params: {str: 'ref', sfx: 'ref', end_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_not_compressed := AndI(str_len_packed).Imm(1).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  sfx_len_packed := LoadI(sfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  sfx_not_compressed := AndI(sfx_len_packed).Imm(1).i32
  sfx_data := Add(Cast(sfx).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  sfx_len := ShrI(sfx_len_packed).Imm(1).i32
  from_index := Sub(end_index, sfx_len).i32;

  sfx_i1 := 0
Label(:Loop)
  str_i := Phi(from_index, str_i1).i32
  sfx_i := Phi(sfx_i1, sfx_i2).i32
  If(sfx_i, sfx_len).GE.Unlikely.b {
    Goto(:Done)
  }
  s := at(str_data, str_i, str_not_compressed)
  p := at(sfx_data, sfx_i, sfx_not_compressed)
  If(s, p).NE.Likely.b {
    Return(0).b
  }
  sfx_i2 := AddI(sfx_i).Imm(1).i32
  str_i1 := AddI(str_i).Imm(1).i32
  Goto(:Loop)

Label(:Done)
  Return(1).b
}


function(:StringEndsWith,
          params: {str: 'ref', sfx: 'ref', end_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  sfx_len_packed := LoadI(sfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'true' if suffix is empty
  # The least significant bit indicates COMPRESSED/UNCOMPRESSED,
  # thus if (packed length <= 1) then the actual length is equal to 0.
  If(sfx_len_packed, 1).LE.Unlikely.b {
    Return(1).b
  }

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'false' if 'str' is empty as 'suffix' is not empty.
  If(str_len_packed, 1).LE.Unlikely.b {
    Return(0).b
  }
  # If 'end_index' is less or equal to zero then return false.
  IfImm(Compare(end_index, 0).LE.b).Imm(0).NE.Unlikely.b {
    Return(0).b
  }

  str_len := ShrI(str_len_packed).Imm(1).i32
  # If 'end_index' is greater than length of 'str' make it equal to length of 'str'.
  If(end_index, str_len).GT.Unlikely.b {
    end_index1 := str_len
  }
  end_index2 := Phi(end_index, end_index1).i32

  sfx_len := ShrI(sfx_len_packed).Imm(1).i32
  from_index := Sub(end_index2, sfx_len).i32;
  IfImm(Compare(from_index, 0).LT.b).Imm(0).NE.Unlikely.b {
    # Return 'false' in this case, as 'sfx' length is greater than 'end_index'.
    Return(0).b
  }

  LiveOut(str).DstReg(regmap[:arg0]).ref
  LiveOut(sfx).DstReg(regmap[:arg1]).ref
  LiveOut(end_index2).DstReg(regmap[:arg2]).i32
  entrypoint = get_entrypoint_offset("STRING_ENDS_WITH_BASE")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringEndsWithBase").Terminator.b
}

function(:StringGetBytesTlab,
        params: {str: 'ref', begin_index: 'i32', end_index: 'i32', array_klass: 'ref'},
        regmap: $full_regmap,
        regalloc_set: $panda_mask,
        mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  If(begin_index, end_index).GT.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }

  If(begin_index, Cast(0).i32).LT.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }

  # Note, 'str' is checked against nullptr in the InstBuilder (see AddArgNullcheckIfNeeded)
  length := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32;
  uncompressed := AndI(length).Imm(1).u32;
  length := ShrI(length).Imm(1).u32;

  If(Cast(end_index).u32, length).A.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }
  offset := Shl(begin_index, uncompressed).u32

  src_str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  src_str_data := Add(src_str_data, Cast(offset).u64).ptr

# Allocate a new array of u8 (bytes)
  count := Sub(Cast(end_index).u32, Cast(begin_index).u32).u64
  new_arr := allocate_array_of_bytes_tlab(array_klass, Cast(count).word)
  new_arr_data := Add(new_arr, Cast(Constants::ARRAY_DATA_OFFSET).u64).ptr
  If(uncompressed, Cast(0).u32).EQ.Likely.b {
    copy_u8_chars(src_str_data, new_arr_data, count)
    Goto(:End)
  }
  compress_u16_to_u8_chars(src_str_data, new_arr_data, count)

  Label(:End)
  Return(new_arr).ptr

  Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("STRING_GET_BYTES_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, str, begin_index, end_index).AddImm(entrypoint).MethodAsImm("StringGetBytes4ArgBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

###
# Char codes in an instance of 'escompat.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double'. Runtime stores such objects as instances of the 'ark::ets::EtsBoxPrimitive' class
# and every instance has a field of type 'double', the value.
#
# The macro reads the boxed value by an object pointer and applies unboxing.
#
scoped_macro(:load_char_code) do |char_codes, offset|
  _boxed_ptr := get_object_pointer(char_codes, offset)
  _char_core := LoadI(_boxed_ptr).Imm(EtsConstants::BOX_PRIMITIVE_VALUE_OFFSET).f64
end  # load_char_code

###
# Tries to convert flag_char_pair, the result of calling the JS_CAST_DOUBLE_TO_CHAR intrinsic, into a Utf16 char (u16).
# The macro checks whether the conversion was successful: whether an overflow or underflow takes place during the
# conversion of a denormalized number and if so goes to the slow path.
#
scoped_macro(:validate_flag_char_pair) do |flag_char_pair|
  _convertible1 := Cast(1).b
  If(AndI(flag_char_pair).Imm(Constants::WRONG_CHAR_FLAG_MASK).u32, 0).NE.Unlikely {
    _convertible2 := Cast(0).b
  }
  _convertible := Phi(_convertible1, _convertible2).b
end  # validate_flag_char_pair

###
# Tries to convert a char_code into a Utf16 char (u16).
# The macro checks whether the conversion was successful: whether an overflow or underflow takes place during the
# conversion of a denormalized number and if so goes to the slow path.
#
scoped_macro(:validate_char_code) do |char_code|
  _flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code).u32
  _convertible := validate_flag_char_pair(_flag_char_pair)
end  # validate_char_code

###
# Checks if starting from codes_data the specified number of codes (codes_count) are convertible: whenever
# an overflow or underflow takes place during the conversion of a denormalized number we have to go to the
# slow path.
#
scoped_macro(:is_array_of_convertible_char_codes) do |codes_data, codes_count|
  if Options.jscvt_feature_enabled?
    _convertible := Cast(1).b
  else
    _offset1 := Cast(0).u64
    _codes_len := ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_OBJ_PTR).u64
    _convertible1 := Cast(1).b
Label(:Loop)
    _offset := Phi(_offset1, _offset2).u64
    If(_offset, _codes_len).AE.Unlikely {
      Goto(:LoopDone)
    }
    _convertible2 := validate_char_code(load_char_code(codes_data, _offset).f64)
    If(_convertible2, 0).EQ.Unlikely.b {
      Goto(:LoopDone)
    }
    _offset2 := AddI(_offset).Imm(Constants::OBJ_PTR_SIZE).u64
    Goto(:Loop)
Label(:LoopDone)
    _convertible := Phi(_convertible1, _convertible2).b
  end
end # is_array_of_convertible_char_codes

###
# Converts a flag_char_pair, the result of calling the JS_CAST_DOUBLE_TO_CHAR intrinsic, into a Utf16 char (u16).
# Note, a caller of this macro must be sure the conversion will always be successful: neither overflow nor
# underflow will take place during the conversion of a denormalized number.
#
scoped_macro(:get_char_from_flag_char_pair) do |flag_char_pair|
  if !Options.jscvt_feature_enabled? and defines.DEBUG
    If(AndI(flag_char_pair).Imm(Constants::WRONG_CHAR_FLAG_MASK).u32, 0).NE.Unlikely {
      Intrinsic(:UNREACHABLE).Terminator.void
    }
  end
  _char := Cast(flag_char_pair).u16
end  # get_char_from_flag_char_pair

###
# Converts a char_code (f64) into a Utf16 char (u16).
# Note, a caller of this macro must be sure the conversion will always be successful: neither overflow nor
# underflow will take place during the conversion of a denormalized number.
#
scoped_macro(:get_char_from_code) do |char_code|
  _flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code).u32
  _char := get_char_from_flag_char_pair(_flag_char_pair)
end  # get_char_from_code

###
# Checks if starting from codes_data the specified number of codes (codes_count) represent
# an array of compressible chars
#
# Utf16 char is ASCII if (utf16_char - 1U < utf::UTF8_1B_MAX)
# See runtime/include/coretypes/string.h - IsASCIICharacter
#
scoped_macro(:is_array_of_compressible_char_codes) do |codes_data, codes_count|
  _offset1 := Cast(0).u64
  _codes_len := ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_OBJ_PTR).u64
  _compressible1 := Cast(1).b
Label(:Loop)
  _offset := Phi(_offset1, _offset2).u64
  If(_offset, _codes_len).AE.Unlikely {
    Goto(:LoopDone)
  }
  _char := get_char_from_code(load_char_code(codes_data, _offset).f64)
  If(SubI(_char).Imm(Constants::STRING_MUTF8_1B_MIN).u16, Cast(Constants::STRING_MUTF8_1B_MAX).u16).AE.Unlikely {
    _compressible2 := Cast(0).b
    Goto(:LoopDone)
  }
  _offset2 := AddI(_offset).Imm(Constants::OBJ_PTR_SIZE).u64
  Goto(:Loop)

Label(:LoopDone)
  _compressible := Phi(_compressible1, _compressible2).b
end  # is_array_of_compressible_char_codes

###
# Converts char codes (numbers) to chars with type equals either to "u8" or "u16". For type equals to "u8", it is
# assumed that all char codes represent compressible chars.
#
["u8", "u16"].each do |type|
  scoped_macro("convert_char_codes_to_#{type}_chars".to_sym) do |src, dst, count|
    compressed_string = type == "u8"
    _i1 := Cast(0).u64
Label(:Loop)
    _i := Phi(_i1, _i2).u64
    If(_i, count).AE.Unlikely {
      Goto(:LoopDone)
    }
    _code_offset := ShlI(_i).Imm(Constants::LOG2_BYTES_PER_OBJ_PTR).u64
    _char := get_char_from_code(load_char_code(src, _code_offset).f64)
    if compressed_string
      _char_offset := Cast(_i).u64
      Store(dst, _char_offset, _char).u8
    else
      _char_offset := ShlI(_i).Imm(Constants::LOG2_BYTES_PER_U16).u64
      Store(dst, _char_offset, _char).u16
    end
    _i2 := AddI(_i).Imm(1).u64
    Goto(:Loop)

Label(:LoopDone)
  end  # convert_char_codes_to_#{type}_chars
end

def GenerateCreateStringFromCharCodeTlab(string_compression_enabled)
  suffix = (string_compression_enabled ? "Compressed" : "")
  available_regs = $panda_mask
  function("CreateStringFromCharCodeTlab#{suffix}".to_sym,
            params: {char_codes: 'ref', string_klass: 'ref'},
            regmap: $full_regmap,
            regalloc_set: available_regs,
            mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      ReturnVoid().void
      next
    end

    # There is no check of the arguments against NullPointer as
    # it's done in the InstBuilder (see AddArgNullcheckIfNeeded) for non-empty arrays
    # and we suppose that the `NewArray (size=0)` instruction never returns `null`.
    if defines.DEBUG
      If(char_codes, 0).EQ {
        Intrinsic(:UNREACHABLE).Terminator.void
      }
    end

    char_codes_array := get_object_pointer_imm(char_codes, EtsConstants::ESCOMPAT_ARRAY_DATA_OFFSET)
    codes_data := AddI(char_codes_array).Imm(Constants::ARRAY_DATA_OFFSET).ptr
    codes_count := LoadI(char_codes_array).Imm(Constants::ARRAY_LENGTH_OFFSET).u32

    # Validate if all the char codes are convertible: whenever an overflow or underflow takes place during the
    # conversion of a denormalized number we have to go to the slow path. The validation must take place before
    # any attempts to allocate the memory in TLAB.
    convertible := is_array_of_convertible_char_codes(codes_data, Cast(codes_count).u64)
    If(convertible, 0).EQ.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    # Allocate a new string
    if string_compression_enabled
      compressible := is_array_of_compressible_char_codes(codes_data, Cast(codes_count).u64)
      If(compressible, 1).EQ.Likely {
        data_size1 := Cast(codes_count).word
      } Else {
        data_size2 := Cast(ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_U16).u32).word
      }
      data_size := Phi(data_size1, data_size2).word
    else
      data_size := Cast(ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_U16).u32).word
    end
    new_str := allocate_string_tlab(string_klass, data_size)
    str_data := Add(new_str, Cast(Constants::STRING_DATA_OFFSET).u64).ptr

    # Copy data from char_codes to the new string with the required preprocessing
    # String length field is set according to SetLength() from runtime/include/coretypes/string.h
    if string_compression_enabled
      If(compressible, 1).EQ.Likely {
        convert_char_codes_to_u8_chars(codes_data, str_data, Cast(codes_count).u64)
        StoreI(new_str, ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_U16).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      } Else {
        convert_char_codes_to_u16_chars(codes_data, str_data, Cast(codes_count).u64)
        StoreI(new_str, OrI(ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_U16).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      }
    else
      convert_char_codes_to_u16_chars(codes_data, str_data, Cast(codes_count).u64)
      StoreI(new_str, codes_count).Imm(Constants::STRING_LENGTH_OFFSET).u32
    end
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

  Label(:SlowPathEntrypoint)
    entrypoint = get_entrypoint_offset("CREATE_STRING_FROM_CHAR_CODE_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, char_codes).AddImm(entrypoint).MethodAsImm("CreateStringFromCharCode2ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  }
end # def GenerateCreateStringFromCharCodeTlab

GenerateCreateStringFromCharCodeTlab(string_compression_enabled=true)
GenerateCreateStringFromCharCodeTlab(string_compression_enabled=false)

def GenerateCreateStringFromCharCodeSingleTlab(string_compression_enabled)
  suffix = (string_compression_enabled ? "Compressed" : "")
  available_regs = $panda_mask
  function("CreateStringFromCharCodeSingleTlab#{suffix}".to_sym,
            params: {char_code: 'u64', string_klass: 'ref'},
            regmap: $full_regmap,
            regalloc_set: available_regs,
            mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      ReturnVoid().void
      next
    end

    char_code_num := Bitcast(char_code).f64
    flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code_num).u32
    if !Options.jscvt_feature_enabled?
      # Validate if the char code is convertible: whenever an overflow or underflow takes place during the
      # conversion of a denormalized number we have to go to the slow path. The validation must take place before
      # any attempts to allocate the memory in TLAB.
      convertible := validate_flag_char_pair(flag_char_pair)
      If(convertible, 0).EQ.Unlikely {
         Goto(:SlowPathEntrypoint)
      }
    end

    # Allocate a new string
    char := get_char_from_flag_char_pair(flag_char_pair)
    if string_compression_enabled
      If(SubI(char).Imm(Constants::STRING_MUTF8_1B_MIN).u16, Cast(Constants::STRING_MUTF8_1B_MAX).u16).AE.Unlikely {
        compressible1 := Cast(0).b
        data_size1 := Cast(2).word
      } Else {
        compressible2 := Cast(1).b
        data_size2 := Cast(1).word
      }
      compressible := Phi(compressible1, compressible2).b
      data_size := Phi(data_size1, data_size2).word
    else
      data_size := Cast(2).word
    end

    new_str := allocate_string_tlab(string_klass, data_size)
    str_data := Add(new_str, Cast(Constants::STRING_DATA_OFFSET).u64).ptr

    # Copy the char to the new string with the required preprocessing
    # String length field is set according to SetLength() from runtime/include/coretypes/string.h
    if string_compression_enabled
      If(compressible, 1).EQ.Likely {
        Store(str_data, Cast(0).u64, char).u8
        StoreI(new_str, Cast(2).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      } Else {
        Store(str_data, Cast(0).u64, char).u16
        StoreI(new_str, OrI(Cast(2).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      }
    else
      Store(str_data, Cast(0).u64, char).u16  
      StoreI(new_str, Cast(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
    end
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

  Label(:SlowPathEntrypoint)
    entrypoint = get_entrypoint_offset("CREATE_STRING_FROM_CHAR_CODE_SINGLE_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, char_code).AddImm(entrypoint).MethodAsImm("CreateStringFromCharCodeSingle2ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  }
end # def GenerateCreateStringFromCharCodeSingleTlab

GenerateCreateStringFromCharCodeSingleTlab(string_compression_enabled=true)
GenerateCreateStringFromCharCodeSingleTlab(string_compression_enabled=false)

# String contains 8-bit chars
# 0 < str_data_size < 8
function(:StringIndexOfCompressedSmall,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  i1 := 0
Label(:Loop)
  i := Phi(i1, i2).u32
  If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
    Return(Cast(i).i32).i32
  }
  i2 := AddI(i).Imm(Constants::U8_SIZE).u32
  If(i2, str_data_size).LT.Likely.b {
    Goto(:Loop)
  }
  Return(-1).i32
}


# String contains 8-bit chars
# 8 <= str_data_size < 16
function(:StringIndexOfCompressedMedium,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  pattern := Cast(ch).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_BYTE").u64, pattern).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_UINT16").u64, pattern).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_UINT32").u64, pattern).u64
  value := LoadI(str_data).Imm(0).u64
  x := Xor(value, pattern).u64
  found := AndI(And(SubI(x).Imm(Constants::XOR_SUB_U8_MASK).u64, Not(x).u64).u64).Imm(Constants::XOR_AND_U8_MASK).u64
  If(found, 0).NE.Likely.b {
    rev := Intrinsic(:REVERSE_BYTES_U64, found).u64
    pos := Cast(ShrI(Intrinsic(:COUNT_LEADING_ZERO_BITS_U64, rev).u64).Imm(Constants::LOG2_BITS_PER_U8).u64).i32
    Return(pos).i32
  }
  i1 := Constants::MEM_BLOCK_8_BYTES
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
      Return(Cast(i).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U8_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 16 <= str_data_size < 32
function(:StringIndexOfCompressedLarge,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 8-bit chars
  p := Intrinsic(:MEM_CHAR_U8_X16_USING_SIMD, ch, str_data).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(Sub(p, str_data).word).i32).i32
  }
  i1 := Constants::MEM_BLOCK_16_BYTES
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
      Return(Cast(i).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U8_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 32 <= data size
function(:StringIndexOfCompressed,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 8-bit chars
  end_ptr := Add(str_data, Cast(str_data_size).word).ptr

  IfImm(Compare(str_data_size, Constants::MEM_BLOCK_32_BYTES).GE.b).Imm(0).NE.Likely.b {
    end_ptr_aligned := Bitcast(AndI(Bitcast(end_ptr).word).Imm(Constants::MEM_BLOCK_32_ALIGN_MASK).word).ptr
Label(:LoopSimd)
    curr_ptr := Phi(str_data, curr_ptr1).ptr;
    p := Intrinsic(:MEM_CHAR_U8_X32_USING_SIMD, ch, curr_ptr).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(Sub(p, str_data).word).i32).i32
    }
    curr_ptr1 := Add(curr_ptr, Constants::MEM_BLOCK_32_BYTES).ptr
    If(curr_ptr1, end_ptr_aligned).LT.Likely.b {
      Goto(:LoopSimd)
    }
    If(end_ptr_aligned, end_ptr).EQ.Unlikely.b {
      Return(-1).i32
    }
  }
  curr_ptr2 := Phi(str_data, curr_ptr1).ptr

  IfImm(Compare(Sub(end_ptr, curr_ptr2).word, Constants::MEM_BLOCK_16_BYTES).GE.b).Imm(0).NE.Likely.b {
    p := Intrinsic(:MEM_CHAR_U8_X16_USING_SIMD, ch, curr_ptr2).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(Sub(p, str_data).word).i32).i32
    }
    curr_ptr3 := AddI(curr_ptr2).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
  }
  curr_ptr4 := Phi(curr_ptr2, curr_ptr3).ptr

Label(:Loop)
  curr_ptr5 := Phi(curr_ptr4, curr_ptr6).ptr
  If(curr_ptr5, end_ptr).LT.Likely.b {
    c := LoadI(curr_ptr5).Imm(0).u8
    If(c, ch).EQ.Unlikely.b {
      Return(Cast(Sub(curr_ptr5, str_data).word).i32).i32
    }
    curr_ptr6 := AddI(curr_ptr5).Imm(Constants::U8_SIZE).ptr
    Goto(:Loop)
  }
  Return(-1).i32
}

# 0 < str_data_size < 16
function(:StringIndexOfUncompressedSmall,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  i1 := 0
Label(:Loop)
  i := Phi(i1, i2).u32
  If(Load(str_data, i).u16, ch).EQ.Unlikely.b {
    Return(Cast(ShrI(i).Imm(1).u32).i32).i32
  }
  i2 := AddI(i).Imm(Constants::U16_SIZE).u32
  If(i2, str_data_size).LT.Likely.b {
    Goto(:Loop)
  }
  Return(-1).i32
}


# 16 <= str_data_size < 32
function(:StringIndexOfUncompressedMedium,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  p := Intrinsic(:MEM_CHAR_U16_X8_USING_SIMD, ch, str_data).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
  }
  i1 := Constants::MEM_BLOCK_16_BYTES  # u16x8
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u16, ch).EQ.Unlikely.b {
      Return(Cast(ShrI(i).Imm(1).u32).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U16_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 32 <= data size
function(:StringIndexOfUncompressed,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  end_ptr := Add(str_data, Cast(str_data_size).word).ptr

  IfImm(Compare(str_data_size, Constants::MEM_BLOCK_32_BYTES).GE.b).Imm(0).NE.Likely.b {
    end_ptr_aligned := Bitcast(AndI(Bitcast(end_ptr).word).Imm(Constants::MEM_BLOCK_32_ALIGN_MASK).word).ptr
Label(:LoopSimd)
    curr_ptr := Phi(str_data, curr_ptr1).ptr;
    p := Intrinsic(:MEM_CHAR_U16_X16_USING_SIMD, ch, curr_ptr).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr1 := Add(curr_ptr, Constants::MEM_BLOCK_32_BYTES).ptr
    If(curr_ptr1, end_ptr_aligned).LT.Likely.b {
      Goto(:LoopSimd)
    }
    If(end_ptr_aligned, end_ptr).EQ.Unlikely.b {
       Return(-1).i32
    }
  }
  curr_ptr2 := Phi(str_data, curr_ptr1).ptr
  IfImm(Compare(Sub(end_ptr, curr_ptr2).word, Constants::MEM_BLOCK_16_BYTES).GE.b).Imm(0).NE.Likely.b {
    p := Intrinsic(:MEM_CHAR_U16_X8_USING_SIMD, ch, curr_ptr2).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr3 := AddI(curr_ptr2).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
  }
  curr_ptr4 := Phi(curr_ptr2, curr_ptr3).ptr

Label(:Loop)
  curr_ptr5 := Phi(curr_ptr4, curr_ptr6).ptr
  If(curr_ptr5, end_ptr).LT.Likely.b {
    If(LoadI(curr_ptr5).Imm(0).u16, ch).EQ.Unlikely.b {
      Return(Cast(ShrI(Sub(curr_ptr5, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr6 := AddI(curr_ptr5).Imm(Constants::U16_SIZE).ptr
    Goto(:Loop)
  }
  Return(-1).i32
}


function(:StringIndexOf,
          params: {str: 'ref', ch: 'u16', fake: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_regs,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32

  # Return '-1' if 'str' is empty.
  IfImm(Compare(str_len_packed, 1).LE.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

  IfImm(Compare(AndI(str_len_packed).Imm(1).i32, 1).EQ.b).Imm(0).NE.Unlikely.b {
    str_data_size_u16 := AndI(str_len_packed).Imm(0xFFFFFFFE).u32
    # 0 < data size < 16
    If(str_data_size_u16, 16).LT.Unlikely.b {
        LiveOut(str_data).DstReg(regmap[:arg0]).ptr
        LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
        LiveOut(ch).DstReg(regmap[:arg2]).u16
        entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_SMALL")
        Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressedSmall").Terminator.i32
    }
    # 16 <= data size < 32
    If(str_data_size_u16, 32).LT.Unlikely.b {
        LiveOut(str_data).DstReg(regmap[:arg0]).ptr
        LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
        LiveOut(ch).DstReg(regmap[:arg2]).u16
        entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_MEDIUM")
        Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressedMedium").Terminator.i32
    }
    # 32 <= data size
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u16
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressed").Terminator.i32
  }

  IfImm(Compare(ch, Constants::MAX_U8_VALUE).A.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  str_data_size_u8 := ShrI(str_len_packed).Imm(1).u32
  # 0 < data size < 8
  If(str_data_size_u8, 8).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_SMALL")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedSmall").Terminator.i32
  }
  # 8 <= data size < 16
  If(str_data_size_u8, 16).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_MEDIUM")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedMedium").Terminator.i32
  }
  # 16 <= data size < 32
  If(str_data_size_u8, 32).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_LARGE")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedLarge").Terminator.i32
  }
  # 32 <= data size
  LiveOut(str_data).DstReg(regmap[:arg0]).ptr
  LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
  LiveOut(ch).DstReg(regmap[:arg2]).u8
  entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressed").Terminator.i32
}


# 'IndexOfAfter' calls the corresponding functions from the 'IndexOf' family
# for the purpose of code efficiency and to avoid code duplication.
# The problem is that we have to add 'start_index' to the result, but execution flow
# never returns to 'StringIndexOfAfter' because of TAIL_CALL. So the codegen and libllvm
# take care of it and emit instructions adding 'start_index' to the result returned
# by 'StringIndexOfAfter'.
function(:StringIndexOfAfter,
          params: {str: 'ref', ch: 'u16', start_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return '-1' if 'str' is empty.
  IfImm(Compare(str_len_packed, 1).LE.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  str_len := ShrI(str_len_packed).Imm(1).i32

  # Return '-1' if 'start_index' is out of range
  If(start_index, str_len).GE.Unlikely.b {
    Return(-1).i32
  }

  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

  IfImm(Compare(AndI(str_len_packed).Imm(1).i32, 1).EQ.b).Imm(0).NE.Unlikely.b {
    offs := Cast(ShlI(start_index).Imm(1).i32).u32
    data_size_u16 := AndI(str_len_packed).Imm(0xFFFFFFFE).u32
    data_size_u16 := Sub(data_size_u16, offs).u32
    data_ptr_u16 := Add(str_data, Cast(offs).word).ptr
    # 0 < data size < 16
    If(data_size_u16, 16).LT.Unlikely.b {
      LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
      LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
      LiveOut(ch).DstReg(regmap[:arg2]).u16
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_SMALL")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressedSmall").Terminator.i32
    }
    # 16 <= data size < 32
    If(data_size_u16, 32).LT.Unlikely.b {
      LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
      LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
      LiveOut(ch).DstReg(regmap[:arg2]).u16
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_MEDIUM")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressedMedium").Terminator.i32
    }
    # 32 <= data size
    LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u16
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfUncompressed").Terminator.i32
  }

  IfImm(Compare(ch, Constants::MAX_U8_VALUE).A.b).Imm(0).NE.Unlikely.b {
    # Return '-1' as 'str' is compressed and 'ch' does not fit in 8 bits.
    Return(-1).i32
  }

  data_size_u8 := Sub(str_len, Cast(start_index).u32).u32
  data_ptr_u8 := Add(str_data, Cast(start_index).word).ptr
  # 0 < data size < 8
  If(data_size_u8, 8).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_SMALL")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedSmall").Terminator.i32
  }
  # 8 <= data size < 16
  If(data_size_u8, 16).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_MEDIUM")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedMedium").Terminator.i32
  }
  # 16 <= data size < 32
  If(data_size_u8, 32).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_LARGE")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressedLarge").Terminator.i32
  }
  # 32 <= data size
  LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
  LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
  LiveOut(ch).DstReg(regmap[:arg2]).u8
  entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringIndexOfCompressed").Terminator.i32
}

function(:StringRepeatTlab,
        params: {str: 'ref', cnt: 'i32'},
        regmap: $full_regmap,
        regalloc_set: $panda_mask,
        mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    next
  end

  count := Cast(cnt).u32
  IfImm(Compare(count, 0).LT.b).Imm(0).NE {
    Goto(:SlowPathEntrypoint)
  }

  IfImm(Compare(count, 0).EQ.b).Imm(0).NE {
    klass := load_class(str)
    new_str := allocate_string_tlab(klass, Cast(0).u64);
    Return(new_str).ptr
  }

  IfImm(Compare(count, 1).EQ.b).Imm(0).NE {
    Return(Cast(str).ptr).ptr
  }

  length := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32;
  klass := load_class(str)
  old_buf := AddI(str).Imm(Constants::STRING_DATA_OFFSET).ptr
  uncompressed := AndI(length).Imm(1).u32
  length := Shl(ShrI(length).Imm(1).u32, uncompressed).u32
  size := Mul(length, count).u32
  new_str := allocate_string_tlab(klass, Cast(size).u64);
  new_buf := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

  If(new_str, 0).EQ {
    Goto(:SlowPathEntrypoint)
  }

  i0 := Cast(0).u32
Label(:outer)
  i := Phi(i0, i1).u32
  If(i, count).GE {
    Goto(:End)
  }
  offset := Mul(i, length).u32

  j0 := Cast(0).u32
  Label(:inner)
    j := Phi(j0, j1).u32
    If(j, length).GE {
      Goto(:endInner)
    }
    Store(new_buf, Add(offset, j).u32, Load(old_buf, j).u8).u8
    j1 := AddI(j).Imm(1).u32
    Goto(:inner)
  Label(:endInner)
  i1 := AddI(i).Imm(1).u32
  Goto(:outer)

Label(:End)
  # shift left if it was a compressed string
  # mark the (unset) lowest bit with uncompressed
  compress := Neg(SubI(uncompressed).Imm(1).u32).u32
  length := Or(Shl(size, compress).u32, uncompressed).u32
  StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
  Return(new_str).ptr

Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("STRING_REPEAT_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, str, count).AddImm(entrypoint).MethodAsImm("StringRepeatUsualBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

function(:WriteStringToMem,
          params: {mem: 'i64', str: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    next
  end

  buf := Bitcast(mem).ptr
  len := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  utf16 := AndI(len).Imm(1).u32
  len_0 := ShrI(len).Imm(1).u32
  len := len_0

  If(len, 0).EQ.Unlikely.b {
      Goto(:End)
  }

  If(utf16, 1).EQ.Unlikely.b {
    mark := 0xfeff
    StoreI(buf, mark).Imm(0).u16
    len_1 := ShlI(len).Imm(1).u32
    buf_1 := AddI(buf).Imm(2).ptr
  }
  buf := Phi(buf, buf_1).ptr
  len := Phi(len, len_1).u32

  str_data := AddI(str).Imm(Constants::STRING_DATA_OFFSET).ptr
  copy_u8_chars(str_data, buf, len);

  If(utf16, 1).EQ.Unlikely.b {
    len_1 := AddI(len).Imm(2).u32
  }

Label(:End)
  len := Phi(len_0, len, len_1).u32
  Return(len).u32
}

function(:CreateStringFromMem,
          params: {buf: 'i64', len: 'i32', klass: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    next
  end

  addr := Bitcast(buf).ptr
  mark := LoadI(addr).Imm(0).u16

  If(mark, Cast(0xFEFF).u16).EQ.Unlikely.b {  # UTF-16 string
    size_1 := SubI(len).Imm(2).i32
    addr_1 := AddI(addr).Imm(2).ptr                
  }

  size := Phi(len, size_1).i32
  addr := Phi(addr, addr_1).ptr

  str := allocate_string_tlab_no_debug(klass, size)
  str_data := AddI(str).Imm(Constants::STRING_DATA_OFFSET).ptr
  copy_u8_chars(addr, str_data, size);
  size_0 := ShlI(size).Imm(1).u32

  If(mark, Cast(0xFEFF).u16).EQ.Unlikely.b {  # UTF-16 string
    size_1 := OrI(ShrI(size_0).Imm(1).u32).Imm(1).u32
  }

  size := Phi(size_0, size_1).u32
  str_len := AddI(str).Imm(Constants::STRING_LENGTH_OFFSET).ptr
  StoreI(str_len, size).Imm(0).u32

  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(str).ptr

  Label(:SlowPathEntrypoint)
  eid = get_entrypoint_offset("CREATE_STRING_FROM_MEM_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, buf, len).AddImm(eid).MethodAsImm("CreateStringFromMem3ArgBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

