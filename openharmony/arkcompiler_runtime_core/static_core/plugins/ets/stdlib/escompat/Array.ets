/*
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package escompat;

// NOTE: autogenerated file

function asIntOrDefault(n: Number | undefined, def: int): int {
    if (n === undefined) {
        return def
    }
    return (n! as Object as Number) as number as int;
}

function normalizeIndex(idx: int, len: int): int {
    if (idx < -len) {
        return 0
    }
    if (idx < 0) {
        return len + idx
    }
    if (idx > len) {
        return len
    }
    return idx
}

class ArrayKeysIterator<T> implements IterableIterator<number> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<number> {
        if (this.isDone || this.idx >= this.parent.actualLength) {
            this.isDone = true
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(this.idx++ as number)
    }

    override $_iterator(): IterableIterator<number> {
        return this
    }
}

class FromBuffer {}
const FROM_BUFFER = new FromBuffer()

/**
 * Represents JS API-compatible Array
 */
export class Array<T> implements ReadonlyArray<T>, Iterable<T> {
    private buffer: FixedArray<NullishType>
    internal actualLength: int

    override get length(): number {
        return this.actualLength as number
    }

    set length(newLen: number) {
        const len = newLen as int
        if (len < 0 || len > this.actualLength) {
            throw new RangeError("can't change length to bigger or negative")
        }
        this.actualLength = len
    }

    public override $_get(index: number): T {
        return this.$_get(index as int)
    }

    public $_set(i: number, val: T): void {
        this.$_set(i as int, val)
    }

    public native $_get(idx: int): T;

    internal $_get_unsafe(idx: int): T {
        return this.buffer[idx] as T
    }

    public native $_set(idx: int, val: T): void;

    private $_set_unsafe(idx: int, val: T): void {
        this.buffer[idx] = val
    }

    /**
     * Creates a new instance of Array
     */
    public constructor(arrayLen: int) {
        this.buffer = new NullishType[arrayLen]
        this.actualLength = arrayLen
    }

    public constructor(arrayLen: number) {
        this(arrayLen as int)
    }

    internal constructor(_tag: FromBuffer, buf: NullishType[]) {
        this.buffer = buf
        this.actualLength = buf.length
    }

    internal constructor() {
        this.buffer = new NullishType[4]
        this.actualLength = 0
    }

    /**
     * Creates a new instance of Array based on Object[]
     *
     * @param d Array initializer
     */
    public constructor(first: T, ...d: T[]) {
        this.buffer = new NullishType[d.length + 1]
        this.actualLength = d.length + 1

        this.buffer[0] = first

        for (let k: int = 0; k < d.length; k++) {
            this.$_set_unsafe(k + 1, d[k])
        }
    }

    /**
     * Creates a new instance of Array.
     *
     * @param arrayLength amount of elements.
     *
     * @param initialValue initial value of elements.
     *
     */
    public static create<T>(arrayLength: number, initialValue: T): Array<T> {
        let other = new Array<T>(arrayLength as int)
        other.fill(initialValue)
        return other
    }

    /**
     * Extends Array with new elements to specified length.
     *
     * @param arrayLength new length of the array.
     *
     * @param initialValue initial value of added elements.
     *
     */
    public extendTo(arrayLength: number, initialValue: T): void {
        if (arrayLength > Int.MAX_VALUE) {
            throw new RangeError("arrayLength must be <= int32 max")
        }
        const len = arrayLength as int
        const delta: int = len - this.actualLength
        if (delta <= 0) {
            return
        }
        this.ensureUnusedCapacity(delta)
        for (let i: int = 0; i < delta; i++) {
            this.buffer[this.actualLength + i] = initialValue
        }
        this.actualLength = len
    }

    /**
     * Shrinks Array to specified length.
     *
     * @param arrayLength length at which to shrink.
     *
     */
    public shrinkTo(arrayLength: number): void {
        if (arrayLength >= this.actualLength) {
            return
        }
        let newLen: int = arrayLength as int
        if (newLen < 0) {
            // Convert from signed to unsigned
            newLen = newLen & Int.MAX_VALUE
        }
        const other = this.slice(0, newLen)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
    }

    /**
     * Creates a new instance of an Array with the specified length
     *
     * @param arrayLength The length of the array to be created (optional).
     *
     * @returns A new Array instance with the specified length
     */
    static $_invoke<T>(arrayLength?: number): Array<T> {
        if (arrayLength != undefined) {
            return new Array<T>(arrayLength);
        } else {
            return new Array<T>();
        }
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param arr an iterable object to convert to an array.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array.
     */
    public static from<T>(iterable: ArrayLike<T> | Iterable<T>): Array<T> {
        return Array.from<T, T>(iterable, (x: T, k: number): T => x)
    }

    /**
     * Creates a new `Array` instance from `Object[]` primitive array.
     *
     * @param iterable an iterable object to convert to an array.
     *
     * @param mapfn a mapping function to call on every element of the array.
     * Every value to be added to the array is first passed through this function, and `mapfn`'s return value
     * is added to the array instead.
     *
     * @returns `Array` intance constructed from `Object[]` primitive array and given function.
     */
    public static from<T, U>(iterable: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: number) => U): Array<U> {
        const ret = new Array<U>()
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(iterable.$_iterator(), (x: T): void => {
            ret.push(mapfn(x, idx[0] as number))
            idx[0] += 1
        })
        return ret
    }

    public static from<T, U>(values: T[], mapfn: (v: T, k: number) => U): Array<U> {
        const ret = new Array<U>(values.length)
        for (let i = 0; i < values.length; ++i) {
            ret[i] = mapfn(values[i], i)
        }
        return ret
    }

    /**
    * Creates a new `Array` instance from `Object[]` primitive array.
    *
    * @param arr primitive array.
    *
    * @returns `Array` intance constructed from `Object[]` primitive array.
    */
    public static from<T>(arr: T[]): Array<T> {
        const len = arr.length
        const ret = new NullishType[len as int]
        for (let i: int = 0; i < len; i++) {
            ret[i] = arr[i] as NullishType
        }
        return new Array<T>(FROM_BUFFER, ret)
    }

    private lastIndexOfUndefined(fi: int): int {
        for (let i = fi; i >= 0; i--) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return i
            }
        }
        return -1
    }

    private lastIndexOfNull(fi: int): int {
        for (let i = fi; i >= 0; i--) {
            if (this.$_get_unsafe(i) instanceof null) {
                return i
            }
        }
        return -1
    }

    private lastIndexOfString(val: String, fi: int): int {
        for (let i = fi; i >= 0; i--) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return i
                }
            }
        }
        return -1
    }

    private lastIndexOfNumber(val: Number, fi: int): int {
        const unboxedVal: number = val.valueOf()
        if (isNaN(val)) {
            return -1
        }
        for (let i = fi; i >= 0; i--) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Number) {
                if (unboxedVal == tmp.unboxed()) {
                    return i
                }
            }
        }
        return -1
    }

    private lastIndexOfFloat(val: Float, fi: int): int {
        const unboxedVal: float = val.unboxed()
        if (isNaN(val)) {
            return -1
        }
        for (let i = fi; i >= 0; i--) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Float) {
                if (unboxedVal == tmp.unboxed()) {
                        return i
                }
            }
        }
        return -1
    }

    private lastIndexOfLong(val: Long, fi: int): int {
        const unboxedVal: long = val.unboxed()
        for (let i = fi; i >= 0; i--) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == unboxedVal) {
                    return i
                }
            }
        }
        return -1
    }

    private lastIndexOfInt(val: Int, fi: int): int {
        const unboxedVal: int = val.unboxed()
        for (let i = fi; i >= 0; i--) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == unboxedVal) {
                    return i
                }
            }
        }
        return -1
    }

    private lastIndexOfCommon(val: T, fi: int): int {
        for (let i = fi; i >= 0; i--) {
            if (val == this.$_get_unsafe(i)) {
                return i
            }
        }
        return -1
    }

    private searchUndefined(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return true
            }
        }
        return false
    }

    private searchNull(fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof null) {
                return true
            }
        }
        return false
    }

    private searchString(val: String, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return true
                }
            }
        }
        return false
    }

    private searchNumber(val: Number, fi: int, len: int): boolean {
        const unboxedVal: number = val.valueOf()
        if (isNaN(unboxedVal)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Number) {
                    if (isNaN(tmp.valueOf())) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Number) {
                    if (unboxedVal == tmp.unboxed()) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchFloat(val: Float, fi: int, len: int): boolean {
        const unboxedVal: float = val.unboxed()
        if (isNaN(unboxedVal)) {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (isNaN(tmp.unboxed())) {
                        return true
                    }
                }
            }
        } else {
            for (let i = fi; i < len; i++) {
                const tmp = this.$_get_unsafe(i)
                if (tmp instanceof Float) {
                    if (unboxedVal == tmp.unboxed()) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private searchLong(val: Long, fi: int, len: int): boolean {
        const unboxedVal: long = val.unboxed()
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == unboxedVal) {
                    return true
                }
            }
        }
        return false
    }

    private searchInt(val: Int, fi: int, len: int): boolean {
        const unboxedVal: int = val.unboxed()
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == unboxedVal) {
                    return true
                }
            }
        }
        return false
    }

    private searchCommon(val: T, fi: int, len: int): boolean {
        for (let i = fi; i < len; i++) {
            if (val == this.$_get_unsafe(i)) {
                return true;
            }
        }
        return false
    }

    private indexOfUndefined(fi: int, len: int): int {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof undefined) {
                return i
            }
        }
        return -1
    }

    private indexOfNull(fi: int, len: int): int {
        for (let i = fi; i < len; i++) {
            if (this.$_get_unsafe(i) instanceof null) {
                return i
            }
        }
        return -1
    }

    private indexOfString(val: String, fi: int, len: int): int {
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof String) {
                if (tmp == val) {
                    return i
                }
            }
        }
        return -1
    }

    private indexOfNumber(val: Number, fi: int, len: int): int {
        const unboxedVal: number = val.valueOf()
        if (isNaN(val)) {
            return -1
        }
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Number) {
                if (unboxedVal == tmp.unboxed()) {
                    return i
                }
            }
        }
        return -1
    }

    private indexOfFloat(val: Float, fi: int, len: int): int {
        const unboxedVal: float = val.unboxed()
        if (isNaN(val)) {
            return -1
        }
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Float) {
                if (unboxedVal == tmp.unboxed()) {
                    return i
                }
            }
        }
        return -1
    }

    private indexOfLong(val: Long, fi: int, len: int): int {
        const unboxedVal: long = val.unboxed()
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Long) {
                if (tmp == unboxedVal) {
                    return i
                }
            }
        }
        return -1
    }

    private indexOfInt(val: Int, fi: int, len: int): int {
        const unboxedVal: int = val.unboxed()
        for (let i = fi; i < len; i++) {
            const tmp = this.$_get_unsafe(i)
            if (tmp instanceof Int) {
                if (tmp == unboxedVal) {
                    return i
                }
            }
        }
        return -1
    }

    private indexOfCommon(val: T, fi: int, len: int): int {
        for (let i = fi; i < len; i++) {
            if (val == this.$_get_unsafe(i)) {
                return i
            }
        }
        return -1
    }
    /**
     * Default comparison function for sort algorithm.
     * Objects are compared as string. Both objects are convereted to string
     * using `toString()` method and compared using `compareTo() method of `string` class.
     *
     * @param a: Object - Object to be compared
     *
     * @param b: Object - Object to be compared
     *
     * @returns Returns one of values -1, 0, 1 (_less_, _equal_, _greater_ respectively).
     */
    private static defaultComparator(a: NullishType, b: NullishType): number {
        if (a instanceof Number && b instanceof Number) {
            const x = (a as Number).valueOf()
            const y = (b as Number).valueOf()
            if (Number.isInteger(x) && Number.isInteger(y) &&
                x <= Int.MAX_VALUE / 128 && x >= Int.MIN_VALUE / 128 &&
                y <= Int.MAX_VALUE / 128 && y >= Int.MIN_VALUE / 128) {
                let z = x as int
                let w = y as int
                return Array.defaultComparatorInts(z, w)
            }
        } else if (a instanceof String && b instanceof String) {
            return a.compareTo(b)
        }
        let sa = new String(a)
        let sb = new String(b)
        return sa.compareTo(sb)
    }

    private static defaultComparatorInts(a: int, b: int): number {
        if (a < 0) {
            if (b >= 0) {
                return -1
            }
            a *= -1
            b *= -1
        } else if (b < 0) {
            return 1
        }
        let aDigs = 1
        while (10 * aDigs <= a) {
            aDigs *= 10
        }
        let bDigs = 1
        while (10 * bDigs <= b) {
            bDigs *= 10
        }

        while (aDigs > 0 && bDigs > 0) {
            let r = (a / aDigs) - (b / bDigs)
            if (r != 0) {
                return r
            }
            aDigs /= 10
            bDigs /= 10
        }
        return (aDigs - bDigs)
    }

    private static defaultComparatorStr(a: String, b: String) {
        return a.compareTo(b)
    }

    /**
     * Helper function preparing copy of `this` instance of `Array` class' data array.
     *
     * @returns Copy of an `Array`'s primitive array data.
     */
    private copyArray(): NullishType[] {
        let len: int = this.actualLength
        let res = new NullishType[len]
        for (let i = 0; i < len; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        return res
    }

    private wrap_default_sort(): void {
        let idxNonUndef = 0
        type arrType = String | undefined
        try {
            let strArr = new arrType[this.actualLength]
            for (let i = 0; i < this.actualLength; i++) {
                const vl = this.$_get_unsafe(i)
                if (vl !== undefined) {
                    if (vl == null) {
                        this.$_set_unsafe(idxNonUndef, vl as T)
                        strArr[idxNonUndef] = "null"
                    } else {
                        this.$_set_unsafe(idxNonUndef, vl)
                        strArr[idxNonUndef] = vl.toString()
                    }
                    idxNonUndef++
                }
            }
            let sortTo = idxNonUndef
            for (let i = idxNonUndef; i < this.actualLength; i++) {
                this.$_set_unsafe(i, undefined as T)
            }

            sort_default<NullishType>(this.buffer, strArr, 0, sortTo)
        }
        catch (e) {
            if (e instanceof OutOfMemoryError) {
                this.slow_default_sort()
            } else {
                throw e as Error
            }
        }
    }

    private slow_default_sort(): void {
        let idxNonUndef = 0
        const cmp: (l: NullishType, r: NullishType) => number = (l: NullishType, r: NullishType): number => {
            return Array.defaultComparator(l, r)
        }
        for (let i = 0; i < this.actualLength; i++) {
            const vl = this.$_get_unsafe(i)
            if (vl !== undefined) {
                this.$_set_unsafe(idxNonUndef, vl)
                idxNonUndef++
            }
        }
        let sortTo = idxNonUndef
        for (let i = idxNonUndef; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        sort_stable<NullishType>(this.buffer, 0, sortTo, cmp)
    }

    private move_undefined_end(): int {
        let writeIndex: int = 0
        for (let i = 0; i < this.actualLength; i++) {
            let val = this.$_get_unsafe(i)
            if (val !== undefined) {
                if(writeIndex != i) {
                    this.$_set_unsafe(writeIndex, val)
                }
                writeIndex++
            }
        }
        for (let i = writeIndex; i < this.actualLength; i++) {
            this.$_set_unsafe(i, undefined as T)
        }
        return writeIndex
    }

    /**
     * Reorders elements of `this` using comparator function.
     *
     * @see ECMA-262, 23.1.3.30
     *
     * @param comparator function that defines the sort order.
     *
     * @returns `this` instance of `Array` class.
     *
     * @note Mutating method
     *
     * NOTE clarify UTF-16 or UTF-8
     */
    public sort(comparator?: (a: T, b: T) => number): this {
        if (this.actualLength <= 1)
            return this

        if (comparator == undefined) {
            this.wrap_default_sort()
            return this
        }

        const compareTo = this.move_undefined_end()
        let cmp: (l: NullishType, r: NullishType) => number = (l: NullishType, r: NullishType): number => {
            return comparator!(l as T, r as T)
        }
        sort_stable<NullishType>(this.buffer, 0, compareTo, cmp)
        return this
    }

    /**
     * Removes the first element from an array and returns that removed element.
     * This method changes the length of the array.
     *
     * @returns shifted element, i.e. that was at index zero
     */
    public shift(): T | undefined {
        if(this.actualLength == 0) {
            return undefined
        }
        let obj = this.$_get_unsafe(0)
        const other = this.slice(1, this.actualLength)
        this.buffer = other.buffer
        this.actualLength = other.actualLength
        return obj
    }

    /**
     * Removes the last element from an array and returns that element.
     * This method changes the length of the array.
     *
     * @returns removed element
     */
    public pop(): T | undefined {
        if(this.actualLength == 0) {
            return undefined
        }
        let obj = this.$_get_unsafe(this.actualLength - 1)
        this.buffer[this.actualLength - 1] = null
        this.actualLength--
        return obj
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @returns new length
     */
    public push(...val: T[]): number {
        this.ensureUnusedCapacity(val.length)
        for (let i = 0; i < val.length; i++) {
            this.buffer[this.actualLength + i] = val[i]
        }
        this.actualLength += val.length
        return this.actualLength
    }

    /**
     * Adds the specified elements to the end of an array and returns the new length of the array.
     *
     * @returns new length
     */
    public pushECMA(...val: T[]): number {
        this.ensureUnusedCapacity(val.length)
        for (let i = 0; i < val.length; i++) {
            this.buffer[this.actualLength + i] = val[i]
        }
        this.actualLength += val.length
        return this.actualLength
    }

    private ensureUnusedCapacity(cap: int): void {
        if (this.actualLength + cap > this.buffer.length) {
            const copy = new NullishType[this.buffer.length * 2 + cap]
            for (let i = 0; i < this.actualLength; i++) {
                copy[i] = this.buffer[i]
            }
            this.buffer = copy
        }
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns an Array with deleted elements
     */
    public splice(start: number, delete: Number | undefined, ...items: T[]): Array<T> {
        return this.splice(start as int, asIntOrDefault(delete, 0), ...items)
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns an Array with deleted elements
     */
    public splice(start: int, delete: int, ...items: T[]): Array<T> {
        start = normalizeIndex(start, this.actualLength)
        if (delete < 0) {
            delete = 0
        }
        if (start > this.actualLength - delete) {
            delete = this.actualLength - start
        }
        // this: [left middle right], we must replace middle with `items`

        this.ensureUnusedCapacity(items.length - delete)
        const oldLen = this.actualLength
        this.actualLength = this.actualLength - delete + items.length

        let ret = new Array<T>(delete)
        let lastSet = start
        // left part remains unchanged
        // copy excluded part
        for (let i = 0; i < delete; i++) {
            ret.buffer[i] = this.buffer[start + i]
        }
        // move right part to the right of the buffer
        const rightLen = oldLen - start - delete
        if (items.length > delete) {
            for (let i = 0; i < rightLen; i++) {
                this.buffer[this.actualLength - 1 - i] = this.buffer[oldLen - 1 - i]
            }
        } else {
            for (let i = 0; i < rightLen; i++) {
                this.buffer[start + items.length + i] = this.buffer[start + delete + i]
            }
        }
        // insert middle part
        for (let i = 0; i < items.length; i++) {
            this.buffer[start + i] = items[i]
        }
        return ret
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @returns an Array with deleted elements from start to the last element of the current instance
     */
    public splice(start: number): Array<T> {
        return this.splice(start as int)
    }

    /**
     * Changes the contents of an array by removing or replacing existing elements
     * and/or adding new elements in place.
     *
     * @param start index
     *
     * @returns an Array with deleted elements from start to the last element of the current instance
     */
    public splice(start: int): Array<T> {
        return this.splice(start, this.actualLength)
    }

    /**
     * Checks whether the passed value is an Array.
     *
     * @param arr
     *
     * @returns true is arr is a non-nullish array, false otherwise
     */
    public static isArray(o: NullishType): boolean {
        if (o instanceof Array) {
            return true
        }
        return (Type.of(o) instanceof ArrayType)
    }

    /**
     * Creates a new Array instance from a variable number of arguments,
     * regardless of number or type of the arguments.
     *
     * @param values an initilizer
     *
     * @returns a newly created Array
     */
    public static of<T>(...values: T[]): Array<T> {
        const ret = new Array<T>()
        ret.ensureUnusedCapacity(values.length)
        for (let i = 0; i < values.length; i++) {
            ret.push(values[i])
        }
        return ret
    }

    /**
     * Adds the specified elements to the beginning of an Array
     * and returns the new length of the Array.
     *
     * @param values data to be added
     *
     * @returns new length of the Array
     */
    public unshift(...values: T[]): number {
        let buffer = this.buffer
        if (this.buffer.length <= values.length + this.actualLength) {
            buffer = new NullishType[this.buffer.length * 2 + values.length]
        }
        for (let i = 0; i < this.actualLength; i++) {
            buffer[this.actualLength + values.length - i - 1] = this.buffer[this.actualLength - 1 - i]
        }
        for (let i = 0; i < values.length; i++) {
            buffer[i] = values[i]
        }
        this.buffer = buffer
        this.actualLength += values.length
        return this.actualLength
    }

    /**
     * Returns an iterator over all indices
     */
    public override keys(): IterableIterator<Number> {
        return new ArrayKeysIterator<T>(this)
    }

    /**
     * Returns an iterator over all values
     */
    public override $_iterator(): IterableIterator<T> {
        return this.values()
    }

    // === methods with uncompatible implementation ===
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     *
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     *
     * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
     */
    public override filter(predicate: (value: T, index: number, array: Array<T>) => boolean): Array<T> {
        const res = new Array<T>()
        for (let i: int = 0; i < this.actualLength; i++) {
            const val = this.$_get_unsafe(i)
            if (predicate(val, i as number, this)) {
                res.push(val)
            }
        }
        return res
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     * into it recursively up to the specified depth.
     *
     * @param depth
     *
     * @returns a flattened Array with respect to depth
     */
    public flat<U>(depth: number): Array<U> {
        return this.flat<U>(depth as int)
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     * into it recursively up to the specified depth.
     *
     * @param depth
     *
     * @returns a flattened Array with respect to depth
     */
    public flat<U>(depth: int): Array<U> {
        let ret = new Array<U>()
        this.flatImpl<U>(depth, ret)
        return ret
    }

    private flatImpl<U>(depth: int, to: Array<U>) {
        throw new Error("not implemented")
    }

    /**
     * Creates a new Array with all sub-array elements concatenated
     *
     * @returns a flattened Array
     */
    public flat<U>(): Array<U> {
        return this.flat<U>(1)
    }

    /**
     * Applies flat and than map
     *
     * fn a function to apply
     *
     * @return new Array after map and than flat
     */
    // NOTE(ivan-tyulyandin): TBD, flatMap may be not subset, see ReadonlyArray
    public flatMap<U>(fn: (v: T, k: number, arr: Array<T>) => U): Array<U> {
        let mapped: Array<U> = this.map<U>(fn)
        return mapped.flat<U>()
    }

    // === methods common among all arrays ===

    /**
     * Takes an integer value and returns the item at that index,
     * allowing for positive and negative integers. Negative integers count back
     * from the last item in the array.
     *
     * @param index Zero-based index of the array element to be returned.
     * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
     *
     * @returns The element in the array matching the given index.
     * Returns undefined if `index` < `-length()` or `index` >= `length()`.
     */
    public override at(index: number): T | undefined {
        return this.at(index as int)
    }

    /**
     * Creates a new `Array` from this `Array` instance and given `Array` instance.
     *
     * @param other to concatenate into a new array.
     *
     * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
     */
    // public override concat(...items: (T | ConcatArray<T>)[]): Array<T> {
    //     throw new Error("not implemented")
    // }

    public concat(...items: ConcatArray<T>[]): Array<T> {
        let totalAdd = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            totalAdd += items[i].length as int
        }

        const buf = new NullishType[totalAdd];

        for (let i = 0; i < this.actualLength; i++) {
            buf[i] = this.$_get_unsafe(i);
        }

        let insertTo = this.actualLength;
        for (let i = 0; i < items.length; i++) {
            const arr = items[i]
            const len = arr.length as int
            for (let j = 0; j < len; j++) {
                buf[insertTo++] = arr.$_get(j)
            }
        }

        return new Array<T>(FROM_BUFFER, buf);
    }

    /**
     * Takes an integer value and returns the item at that index,
     * allowing for positive and negative integers. Negative integers count back
     * from the last item in the array.
     *
     * @param index Zero-based index of the array element to be returned.
     * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
     *
     * @returns The element in the array matching the given index.
     * Returns undefined if `index` < `-length()` or `index` >= `length()`.
     */
    public at(index: int): T | undefined {
        let len = this.actualLength;
        let k: int;
        if (index >= 0) {
            k = index;
        } else {
            k = len + index;
        }

        if (k < 0 || k >= len) {
            return undefined;
        }

        return this.$_get_unsafe(k);
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @param start index at which to start copying elements from
     *
     * @param end index at which to end copying elements from
     *
     * @returns this array after transformation
     */
    public copyWithin(target: number, start: number, end?: Number): this {
        this.copyWithin(target as int, start as int, asIntOrDefault(end, this.actualLength));
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @param start index at which to start copying elements from
     *
     * @param end index at which to end copying elements from
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int, start: int, end: int): this {
        target = normalizeIndex(target, this.actualLength)
        start = normalizeIndex(start, this.actualLength)
        end = normalizeIndex(end, this.actualLength)

        if (end <= start) {
            return this;
        }

        if (target <= start) {
            while (start < end) {
                const read = this.$_get_unsafe(start++);
                this.$_set_unsafe(target++, read);
            }
        } else {
            let len = end - start;
            if (target + len > this.actualLength) {
                len = this.actualLength - target
            }
            for (let i = 0; i < len; i++) {
                const read = this.$_get_unsafe(start + len - 1 - i);
                this.$_set_unsafe(target + len - 1 - i, read);
            }
        }

        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @param start index at which to start copying elements from
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int, start: int): this {
        this.copyWithin(target, start, this.actualLength);
        return this;
    }

    /**
     * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
     *
     * @param target index at which to copy the sequence
     *
     * @returns this array after transformation
     */
    public copyWithin(target: int): this {
        this.copyWithin(target, 0, this.actualLength);
        return this;
    }

    /**
     * Changes all elements in the Array to a static value, from a start index to an end index
     *
     * @param value to fill the array with
     *
     * @param start index at which to start filling
     *
     * @param end index at which to end filling, but not including
     *
     * @returns this array after transformation
     */
    public fill(value: T, start?: Number, end?: Number): this {
        this.fill(value, asIntOrDefault(start, 0), asIntOrDefault(end, this.actualLength));
        return this;
    }

    /**
     * Changes all elements in the Array to a static value, from a start index to an end index
     *
     * @param value to fill the array with
     *
     * @param start index at which to start filling
     *
     * @param end index at which to end filling, but not including
     *
     * @returns this array after transformation
     */
    public fill(value: T, start: int, end: int): this {
        start = normalizeIndex(start, this.actualLength);
        end = normalizeIndex(end, this.actualLength)

        for (let i = start; i < end; i++) {
            this.$_set_unsafe(i, value);
        }

        return this;
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise.
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined.
     *
     * @returns the value of the first element in the array or undefined
     */
    public override find(predicate: (value: T, index: number, array: Array<T>) => boolean): T | undefined {
        const res = this.findIndex(predicate)
        if (res == -1) {
            return undefined
        }
        return this.$_get_unsafe(res as int);
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise.
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
     *
     * @returns found element index or -1 otherwise
     */
    public override findIndex(predicate: (value: T, index: number, array: Array<T>) => boolean): number {
        for (let i = 0; i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i as number, this)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Iterates the array in reverse order and returns the value of the first element
     * that satisfies the provided testing function
     *
     * @param predicate testing function
     *
     * @returns found element or undefined otherwise
     */
    public override findLast(predicate: (elem: T, index: number, array: Array<T>) => boolean): T | undefined {
        for (let i = this.actualLength - 1; i >= 0; i--) {
            const val = this.$_get_unsafe(i);
            if (predicate(val, i as number, this)) {
                return val;
            }
        }
        return undefined;
    }

    /**
     * Determines whether all the members of an array satisfy the specified test.
     *
     * @param predicate A function that accepts up to three arguments. The every method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value false, or until the end of the array.
     *
     * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
     */
    public override every(predicate: (value: T, index: number, array: Array<T>) => boolean): boolean {
        let curArrLength = this.actualLength
        for (let i = 0; i < curArrLength && i < this.actualLength; i++) {
            if (!predicate(this.$_get_unsafe(i), i as number, this)) {
                return false
            }
        }
        return true;
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts up to three arguments. The some method calls
     * the predicate function for each element in the array until the predicate returns a value
     * which is coercible to the Boolean value true, or until the end of the array.
     *
     * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
     */
    public override some(predicate: (value: T, index: number, array: Array<T>) => boolean): boolean {
        for (let i = 0; i < this.actualLength; i++) {
            if (predicate(this.$_get_unsafe(i), i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Iterates the array in reverse order and returns the index of
     * the first element that satisfies the provided testing function.
     * If no elements satisfy the testing function, -1 is returned.
     *
     * @param predicate testing function
     *
     * @returns index of first element satisfying to predicate, -1 if no such element
     */
    public override findLastIndex(predicate: (element: T, index: number, array: Array<T>) => boolean): number {
        for (let i = this.actualLength - 1; i >= 0; i--) {
            if (predicate(this.$_get_unsafe(i), i as number, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduce(callbackfn: (previousValue: T, currentValue: T, index: number, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(0);
        for (let i = 1; i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i as number, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduce<U = T>(callbackfn: (previousValue: U, currentValue: T, index: number, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        for (let i = 0; i < this.actualLength; i++) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i as number, this)
        }
        return acc
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, index: number, array: Array<T>) => U, initialValue: U): U {
        let acc = initialValue
        for (let i = this.actualLength - 1; i >= 0; i--) {
            acc = callbackfn(acc, this.$_get_unsafe(i), i as number, this)
        }
        return acc
    }

    /**
     * Performs the specified action for each element in an array.
     *
     * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     */
    public override forEach(callbackfn: (value: T, index: number, array: Array<T>) => void): void {
        const len0 = this.actualLength;
        for (let i = 0; i < len0; i++) {
            callbackfn(this.$_get_unsafe(i), i as number, this)
        }
    }

    /**
     * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
     * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
     *
     * @param start zero-based index at which to start extraction
     *
     * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
     *
     * @returns `Array` instance, constructed from extracted elements of `this` instance.
     */
    public override slice(start?: Number, end?: Number): Array<T> {
        const len: int = this.actualLength;
        return this.slice(asIntOrDefault(start, 0), asIntOrDefault(end, len))
    }

    /**
     * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
     * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
     *
     * @param start zero-based index at which to start extraction
     *
     * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
     *
     * @returns `Array` instance, constructed from extracted elements of `this` instance.
     */
    public slice(start: int, end: int): Array<T> {
        const len: int = this.actualLength;
        const relStart = normalizeIndex(start, len)
        const relEnd = normalizeIndex(end, len)

        let count = relEnd - relStart;
        if (count < 0) {
            count = 0;
        }
        let res = new NullishType[count]
        for (let i = 0; i < count; i++) {
            res[i] = this.$_get_unsafe(relStart + i);
        }

        return new Array<T>(FROM_BUFFER, res)
    }

    /**
     * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
     * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
     *
     * @param start zero-based index at which to start extraction
     *
     * @returns `Array` instance, constructed from extracted elements of `this` instance.
     */
    public slice(start: int): Array<T> {
        return this.slice(start, Int.MAX_VALUE as int);
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
     public lastIndexOf(searchElement: T, fromIndex: int): int {
        if (this.actualLength == 0) {
            return -1;
        }
        let n = fromIndex;
        let k: int;
        if (n >= 0) {
            k = min(this.actualLength - 1, n);
        } else {
            k = this.actualLength + n;
        }

        if (searchElement instanceof String) {
            return this.lastIndexOfString(searchElement, k)
        } else if (searchElement instanceof Number) {
            return this.lastIndexOfNumber(searchElement, k)
        } else if (searchElement instanceof Float) {
            return this.lastIndexOfFloat(searchElement, k)
        } else if (searchElement instanceof Long) {
            return this.lastIndexOfLong(searchElement, k)
        } else if (searchElement instanceof Int) {
            return this.lastIndexOfInt(searchElement, k)
        } else if (searchElement === undefined) {
            return this.lastIndexOfUndefined(k)
        } else if (searchElement == null) {
                return this.lastIndexOfNull(k)
        } else {
            return this.lastIndexOfCommon(searchElement, k)
        }
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    public lastIndexOf(searchElement: T, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0));
    }

    /**
     * Returns the last index at which a given element can be found in the array,
     * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
     *
     * @param searchElement element to locate in the array.
     *
     * @param fromIndex zero-based index at which to start searching backwards.
     * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
     * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
     * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
     * If `fromIndex` is undefined then `fromIndex = 0`.
     * If `fromIndex` is ommited then `fromIndex = length()-1`.
     *
     * @returns The last index of the element in the array; -1 if not found.
     */
    public lastIndexOf(searchElement: T): number {
        return this.lastIndexOf(searchElement, this.actualLength - 1);
    }

    /**
     * Creates and returns a new string by concatenating all of the elements in an `Array`,
     * separated by a specified separator string.
     * If the array has only one item, then that item will be returned without using the separator.
     *
     * @param sep specifies a separator
     *
     * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
     */
    public override join(sep?: String): string {
        if (this.actualLength == 0) {
            return ""
        }
        const sepReal = sep === undefined ? "," : sep!
        // NOTE(aleksander-sotov) We can't call String constructor here due to internal issue 18583
        const first_el = this.$_get_unsafe(0)
        let first_str = ""
        if (first_el !== undefined && first_el !== null) {
            first_str = new String(first_el)
        }
        let sb = new StringBuilder(first_str)
        for (let i: int = 1; i < this.actualLength; i++) {
            const tmp = this.$_get_unsafe(i)
            sb.append(sepReal);
            // NOTE(aleksander-sotov) We can't call String constructor here due to internal issue 18583
            if (tmp !== undefined && tmp !== null) {
                sb.append(new String(tmp))
            } else {
                sb.append("")
            }
        }

        return sb.toString();
    }

    /**
     * Returns a string representing the specified array and its elements.
     *
     * @returns string representation
     */
    public override toString(): string {
        return this.join(",");
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Array.toLocaleString: not implemented")
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Returns a locale string representing the specified array and its elements.
     *
     * @returns string representation
     */
    public override toLocaleString(): string {
        const sb = new StringBuilder()
        const len = this.actualLength;
        for (let i = 0; i < len; i++) {
            if (i != 0) {
                sb.append(",")
            }
            let x = this.$_get_unsafe(i) as NullishType;
            if ((null !== x) && (undefined !== x)) {
                sb.append(x!.toLocaleString())
            }
        }
        return sb.toString()
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start?: Number, delete?: Number): Array<T> {
        const len = this.actualLength;
        return this.toSpliced(asIntOrDefault(start, len), asIntOrDefault(delete, len))
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start: number, delete: number, ...items: T[]): Array<T> {
        const len = this.actualLength;
        return this.toSpliced(start as int, delete as int, ...items)
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @param delete number of items after start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start: int, delete: int, ...items: T[]): Array<T> {
        const len = this.actualLength;
        start = normalizeIndex(start, len);
        if (delete < 0) {
            delete = 0;
        } else if (delete > len) {
            delete = len;
        }
        if (start > len - delete) {
            delete = len - start
        }
        const res = new NullishType[len - delete + items.length];
        for (let i = 0; i < start; i++) {
            res[i] = this.$_get_unsafe(i)
        }
        for (let i = 0; i < items.length; i++) {
            res[start + i] = items[i]
        }
        for (let i = start + delete; i < len; i++) {
            res[i - delete + items.length] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, res);
    }

    /**
     * Copying version of the splice() method.
     *
     * @param start index
     *
     * @returns a new Array with some elements removed and/or replaced at a given index.
     */
    public toSpliced(start: int): Array<T> {
        return this.toSpliced(start, this.actualLength)
    }

    /**
     * Checks whether an Array includes a certain value among its entries,
     * returning true or false as appropriate.
     *
     * @param val value to search
     *
     * @param fromIndex start index
     *
     * @returns true if val is in Array
     */
    public override includes(val: T, fromIndex?: Number): boolean {
        const len = this.actualLength;
        const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
        if (val instanceof String) {
            return this.searchString(val, fi, len)
        } else if (val instanceof Number) {
            return this.searchNumber(val, fi, len)
        } else if (val instanceof Float) {
            return this.searchFloat(val, fi, len)
        } else if (val instanceof Long) {
            return this.searchLong(val, fi, len)
        } else if (val instanceof Int) {
            return this.searchInt(val, fi, len)
        } else if (val === undefined) {
            return this.searchUndefined(fi, len)
        } else if (val == null) {
            return this.searchNull(fi, len)
        } else {
            return this.searchCommon(val, fi, len)
        }
    }

    /**
     * Returns the first index at which a given element
     * can be found in the array, or -1 if it is not present.
     *
     * @param val value to search
     *
     * @param fromIndex index to search from
     *
     * @returns index of val, -1 otherwise
     */
    public indexOf(val: T, fromIndex: int): int {
        fromIndex = normalizeIndex(fromIndex, this.actualLength)
        const len = this.actualLength;
        if (val instanceof String) {
            return this.indexOfString(val, fromIndex, len)
        } else if (val instanceof Number) {
            return this.indexOfNumber(val, fromIndex, len)
        } else if (val instanceof Float) {
            return this.indexOfFloat(val, fromIndex, len)
        } else if (val instanceof Long) {
            return this.indexOfLong(val, fromIndex, len)
        } else if (val instanceof Int) {
            return this.indexOfInt(val, fromIndex, len)
        } else if (val === undefined) {
            return this.indexOfUndefined(fromIndex, len)
        } else if (val === null) {
            return this.indexOfNull(fromIndex, len)
        } else {
            return this.indexOfCommon(val, fromIndex, len)
        }
    }

    /**
     * Returns the first index at which a given element
     * can be found in the array, or -1 if it is not present.
     *
     * @param val value to search
     *
     * @param fromIndex index to search from
     *
     * @returns index of val, -1 otherwise
     */
    public override indexOf(val: T, fromIndex?: Number): number {
        return this.indexOf(val, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Copying version of the sort() method.
     * It returns a new array with the elements sorted in ascending order.
     *
     * @returns sorted copy of hte current instance using default comparator
     */
    public toSorted(): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort()
        return arr
    }

    /**
     * Copying version of the sort() method.
     * It returns a new array with the elements sorted in ascending order.
     *
     * @param comparator function to compare to elements of the Array
     *
     * @returns sorted copy of the current instance comparator
     */
    public toSorted(comparator: (a: T, b: T) => number): Array<T> {
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.sort(comparator)
        return arr
    }

    /**
     * Modifies `this` instance of `Array` class and populates
     * it with same elements ordered towards the direction opposite to that previously stated.
     *
     * @note Mutating method
     */
    public reverse(): this {
        for (let i = 0; i < this.actualLength / 2; i++) {
            const tmp = this.$_get_unsafe(i);
            const idx_r = this.actualLength - 1 - i;
            const val_r = this.$_get_unsafe(idx_r);
            this.$_set_unsafe(i, val_r);
            this.$_set_unsafe(idx_r, tmp);
        }
        return this;
    }

    /**
     * Copying version of the reverse() method.
     * It returns a new array with the elements in reversed order.
     *
     * @returns reversed copy of the current Array
     */
    public toReversed(): Array<T> {
        let arr = new NullishType[this.actualLength]
        for (let i = 0; i < this.actualLength; i++) {
            arr[this.actualLength - 1 - i] = this.$_get_unsafe(i)
        }
        return new Array<T>(FROM_BUFFER, arr)
    }

    /**
     * Copying version of using the bracket notation to change the value of a given index.
     * It returns a new Array with the element at the given index replaced with the given value.
     *
     * @param index to replace
     *
     * @param value new value
     *
     * @returns a new Array with the element at the given index replaced with the given value
     */
    public with(index: number, value: T): Array<T> {
        return this.with(index as int, value)
    }

    /**
     * Copying version of using the bracket notation to change the value of a given index.
     * It returns a new Array with the element at the given index replaced with the given value.
     *
     * @param index to replace
     *
     * @param value new value
     *
     * @returns a new Array with the element at the given index replaced with the given value
     */
    public with(index: int, value: T): Array<T> {
        if (index < 0) {
            index += this.actualLength;
        }
        if (index >= this.actualLength) {
            throw new RangeError("Invalid index")
        }
        let arr = new Array<T>(FROM_BUFFER, this.copyArray());
        arr.$_set_unsafe(index, value);
        return arr
    }

    /**
     * Returns an iterator over all values
     */
    public override values(): IterableIterator<T> {
        return new ArrayValuesIterator_T<T>(this);
    }

    /**
     * Returns an iterable of key, value pairs for every entry in the array
     */
    public override entries(): IterableIterator<[number, T]> {
        return new ArrayEntriesIterator_T<T>(this);
    }

    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     *
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     *
     * @returns `Array` instance, constructed from `this` and given function.
     */
    public override map<U>(callbackfn: (value: T, index: number, array: Array<T>) => U): Array<U> {
        const len = this.actualLength;
        let res = new NullishType[len];
        for (let i = 0; i < this.actualLength; i++) {
            res[i] = callbackfn(this.$_get_unsafe(i), i as number, this);
        }
        return new Array<U>(FROM_BUFFER, res);
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @returns a result after applying callbackfn over all elements of the Array
     */
    public override reduceRight(callbackfn: (previousValue: T, currentValue: T, index: number, array: Array<T>) => T): T {
        if (this.actualLength == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }
        let acc: T = this.$_get_unsafe(this.actualLength - 1);
        for (let i = this.actualLength - 2; i >= 0; i--) {
            if (this.actualLength > i) {
                acc = callbackfn(acc, this.$_get_unsafe(i), i as number, this)
            }
        }
        return acc
    }

}

class ArrayValuesIterator_T<T> implements IterableIterator<T> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<T> {
        if (this.isDone || this.idx >= this.parent.actualLength) {
            this.isDone = true
            return new IteratorResult<T>()
        }
        return new IteratorResult<T>(this.parent.$_get_unsafe(this.idx++))
    }

    override $_iterator(): IterableIterator<T> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_T<T> implements IterableIterator<[number, T]> {
    private parent: Array<T>
    private idx: int = 0
    private isDone: boolean = false

    constructor(parent: Array<T>) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, T]> {
        if (this.isDone || this.idx >= this.parent.actualLength) {
            this.isDone = true
            return new IteratorResult<[number, T]>()
        }
        const i = this.idx++;
        const vl: [number, T] = [i as number, this.parent.$_get_unsafe(i)]
        return new IteratorResult<[number, T]>(vl);
    }

    override $_iterator(): IterableIterator<[number, T]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}
