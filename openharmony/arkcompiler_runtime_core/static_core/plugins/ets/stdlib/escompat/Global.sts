/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package escompat;

/**
 * Represents the NaN value according to IEEE-754 specification
 */
export const NaN = Double.NaN;

/**
 * Represents the +Infinity value according to IEEE-754 specification
 */
export const Infinity = Double.POSITIVE_INFINITY;

/**
 * Parses integer number from `String` with specified radix
 *
 * This function is an equivalent to @link{<Double.parseInt(s, radix)>}
 *
 * @returns result of parsing
 */
export function parseInt(s: String, radix: int): number {
    return Double.parseInt(s, radix);
}

/**
 * Parses integer number from `String` with specified radix
 *
 * This function is an equivalent to @link{<Double.parseInt(s, radix)>}
 *
 * @returns result of parsing
 */
export function parseInt(s: String, radix: number): number {
    return Double.parseInt(s, radix);
}

/**
 * Parses integer number from `String` with specified radix
 *
 * This function is an equivalent to @link{<Double.parseInt(s, radix)>}
 *
 * @returns result of parsing
 */
export function parseInt(s: String): number {
    return Double.parseInt(s);
}

/**
 * Parses floating point number from `String`
 *
 * This function is an equivalent to @link{<Double.parseFloat(s)>}
 *
 * @returns result of parsing
 */
export function parseFloat(s: String): number {
    return Double.parseFloat(s);
}

/**
 * Checks if Double is `NaN` (not a number)
 *
 * @param d the Double to test
 *
 * @returns `true` if the argument is `NaN`, `false` otherwise.
 */
export function isNaN(d: Number): boolean {
    return d.isNaN();
}

/**
 * Checks if double is `NaN` (not a number)
 *
 * @param d the `double` to test
 *
 * @returns `true` if the argument is `NaN`, `false` otherwise.
 */
export function isNaN(d: number): boolean {
    return Double.isNaN(d);
}

/**
 * Checks if `Float` value is `NaN` (not a number)
 *
 * @param f the `Float` value to test
 *
 * @returns `true` if the argument is `NaN`, `false` otherwise.
 */
export function isNaN(f: Float): boolean {
    return f.isNaN();
}

/**
 * Checks if `float` value is `NaN` (not a number)
 *
 * @param f the `float` value to test
 *
 * @returns `true` if the argument is `NaN`, `false` otherwise.
 */
export function isNaN(f: float): boolean {
    return Float.isNaN(f);
}

/**
 * Checks if `byte` value is `NaN` (not a number)
 *
 * @param b the `byte` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(b: byte): boolean { return false; }

/**
 * Checks if `int` value is `NaN` (not a number)
 *
 * @param i the `int` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(i: int): boolean { return false; }

/**
 * Checks if `short` value is `NaN` (not a number)
 *
 * @param s the `short` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(s: short): boolean { return false; }

/**
 * Checks if `long` value is `NaN` (not a number)
 *
 * @param l the `long` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(l: long): boolean { return false; }

/**
 * Checks if `Byte` value is `NaN` (not a number)
 *
 * @param b the `Byte` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(b: Byte): boolean { return false; }

/**
 * Checks if `Int` value is `NaN` (not a number)
 *
 * @param i the `Int` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(i: Int): boolean { return false; }

/**
 * Checks if `Short` value is `NaN` (not a number)
 *
 * @param s the `Short` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(s: Short): boolean { return false; }

/**
 * Checks if `Long` value is `NaN` (not a number)
 *
 * @param l the `Long` value to test
 *
 * @returns unconditionally returns `false`. Integral types can not be `NaN`.
 */
export function isNaN(l: Long): boolean { return false; }

/**
 * Checks if `Double` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param d the `Double` value to test
 *
 * @returns `true` if the argument is a floating point value, `false` otherwise.
 */
export function isFinite(d: Number): boolean {
    return d.isFinite();
}

/**
 * Checks if `double` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param d the `double` value to test
 *
 * @returns `true` if the argument is a floating point value, `false` otherwise.
 */
export function isFinite(d: number): boolean {
    return Double.isFinite(d);
}

/**
 * Checks if `Float` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param f the `Float` value to test
 *
 * @returns `true` if the argument is a floating point value, `false` otherwise.
 */
export function isFinite(f: Float): boolean {
    return f.isFinite();
}

/**
 * Checks if `float` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param f the `float` value to test
 *
 * @returns `true` if the argument is a floating point value, `false` otherwise.
 */
export function isFinite(f: float): boolean {
    return Float.isFinite(f);
}

/**
 * Checks if `byte` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param b the `byte` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(b: byte): boolean { return true; }

/**
 * Checks if `int` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param i the `int` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(i: int): boolean { return true; }

/**
 * Checks if `short` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param s the `short` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(s: short): boolean { return true; }

/**
 * Checks if `long` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param l the `long` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(l: long): boolean { return true; }

/**
 * Checks if `Byte` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param b the `Byte` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(b: Byte): boolean { return true; }

/**
 * Checks if `Int` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param i the `Int` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(i: Int): boolean { return true; }

/**
 * Checks if `Short` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param s the `Short` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(s: Short): boolean { return true; }

/**
 * Checks if `Long` value is a floating point value (not a `NaN` or `Infinity`)
 *
 * @param l the `Long` value to test
 *
 * @returns unconditionally returns `true`. Integral types can not be `NaN` or `Infinity`.
 */
export function isFinite(l: Long): boolean { return true; }

/**
 * Checks if float is similar to an integer value
 *
 * @param v the float to test
 *
 * @returns boolean - true if the argument is similar to an integer value
 */
export function isInteger(v: float): boolean {
    return Float.isInteger(v);
}

/**
 * Checks if Float is similar to an integer value
 *
 * @param v the Float to test
 *
 * @returns boolean - true if the argument is similar to an integer value
 */
export function isInteger(v: Float): boolean {
    return v.isInteger();
}

/**
 * Checks if double is similar to an integer value
 *
 * @param v the double to test
 *
 * @returns boolean - true if the argument is similar to an integer value
 */
export function isInteger(v: number): boolean {
    return Double.isInteger(v);
}

/**
 * Checks if Double is similar to an integer value
 *
 * @param v the Double to test
 *
 * @returns boolean - true if the argument is similar to an integer value
 */
export function isInteger(v: Number): boolean {
    return v.isInteger();
}

/**
 * Checks if `byte` is similar to an integer value
 *
 * @param b the `byte` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(b: byte): boolean { return true; }

/**
 * Checks if `int` is similar to an integer value
 *
 * @param i the `int` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(i: int): boolean { return true; }

/**
 * Checks if `short` is similar to an integer value
 *
 * @param s the `short` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(s: short): boolean { return true; }

/**
 * Checks if `long` value is similar to an integer value
 *
 * @param l the `long` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(l: long): boolean { return true; }

/**
 * Checks if `Byte` is similar to an integer value
 *
 * @param b the `Byte` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(b: Byte): boolean { return true; }

/**
 * Checks if `Int` is similar to an integer value
 *
 * @param i the `Int` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(i: Int): boolean { return true; }

/**
 * Checks if `Short` is similar to an integer value
 *
 * @param s the `Short` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(s: Short): boolean { return true; }

/**
 * Checks if `Long` value is similar to an integer value
 *
 * @param l the `Long` value to test
 *
 * @returns boolean - unconditionally returns `true` as integral types are integer.
 */
export function isInteger(l: Long): boolean { return true; }

/**
 * Checks if float is a safe integer value
 *
 * @param v: float - the float to test
 *
 * @returns boolean - true if the argument is integer and less than Float.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: float): boolean {
    return Float.isSafeInteger(v);
}

/**
 * Checks if Float is a safe integer value
 *
 * @param v: Float - the Float to test
 *
 * @returns boolean - true if the underlying float is a safe integer
 */
export function isSafeInteger(v: Float): boolean {
    return v.isSafeInteger();
}

/**
 * Checks if double is a safe integer value
 *
 * @param v the double to test
 *
 * @returns boolean - true if the argument is integer and less than Double.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: number): boolean {
    return Double.isSafeInteger(v);
}

/*
 * Checks if Double is a safe integer value
 *
 * @param v the Double to test
 *
 * @returns boolean - true if the underlying double is a safe integer
 */
export function isSafeInteger(v: Number): boolean {
    return v.isSafeInteger();
}

/**
 * Checks if int can be represented in float without lossing precision
 *
 * @param v: int - the int to test
 *
 * @returns boolean - true if the argument is less than Float.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: int): boolean {
    return v <= Float.MAX_SAFE_INTEGER as int;
}

/**
 * Checks if Int can be represented in float without lossing precision
 *
 * @param v: Int - the Int to test
 *
 * @returns boolean - true if the argument is less than Float.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: Int): boolean {
    return v.unboxed() <= Float.MAX_SAFE_INTEGER as int;
}

/**
 * Checks if long can be represented in double without lossing precision
 *
 * @param v: long - the long to test
 *
 * @returns boolean - true if the argument is less than Double.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: long): boolean {
    return v <= Double.MAX_SAFE_INTEGER as long;
}

/**
 * Checks if Long can be represented in double without lossing precision
 *
 * @param v: Long - the Long to test
 *
 * @returns boolean - true if the argument is less than Double.MAX_SAFE_INTEGER
 */
export function isSafeInteger(v: Long): boolean {
    return v.unboxed() <= Double.MAX_SAFE_INTEGER as long;
}

/**
 * Execute function on the next cycle.
 *
 * @param func: () => void - the function to be executed on the next cycle.
 * @returns int - timer id
 */
export function setTimeout(func: () => void): int {
    return setTimeout(func, 0);
}

/**
 * Execute function after the timer expires.
 *
 * @param func: () => void - the function to be executed after the timer expires.
 * @param delayMs: int - timeout in milliseconds.
 * @returns int - timer id
 */
export function setTimeout(func: () => void, delayMs: int): int {
    startTimer(func as Object, delayMs, true);
}

/**
 * Cancel the specified timer.
 *
 * @param timerId: int - the id of the timer returned from setTimeout.
 */
export function clearTimeout(timerId: int): void {
    stopTimer(timerId);
}

/**
 * Repeatedly do asynchronous call of the function.
 *
 * @param func: () => void - the function to be executed.
 * @returns int - timer id
 */
export function setInterval(func: () => void): int {
    return setInterval(func, 0);
}

/**
 * Repeatedly call the function with delayMs interval between calls. The first call will be after delayMs.
 *
 * @param func: () => void - the function to be executed.
 * @param delayMs: int - timeout in milliseconds.
 * @returns int - timer id
 */
export function setInterval(func: () => void, delayMs: int): int {
    return startTimer(func as Object, delayMs, false);
}

/**
 * Cancel the specified timer.
 *
 * @param timerId: int - the id of the timer returned from setInterval.
 */
export function clearInterval(timerId: int): void {
    stopTimer(timerId);
}

native function startTimer(func: Object, delayMs: int, oneShotTimer: boolean): int;
native function stopTimer(timerId: int): void;
