/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package escompat;

export interface ReadonlyMap<K, V> extends Iterable<[K, V]> {
    /**
     * Returns number of Entries with unique keys in the Map
     *
     * @returns number of Entries with unique keys in the Map
     */
    get size(): number;

    /**
     * Returns a value assosiated with key if present
     *
     * @param k the key to find in the Map/class
     *
     * @returns value if assosiated with key presents.
     */
    get(key: K): V | undefined;

    /**
     * Checks if a key is in the Map
     *
     * @param k the key to find in the Map
     *
     * @returns true if the value is in the Map
     */
    has(key: K): boolean;

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    forEach(callbackfn: () => void): void;

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    forEach(callbackfn: (value: V) => void): void;

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param fn to apply
     */
    forEach(callbackfn: (value: V, key: K) => void): void;

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    forEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void): void;

    /**
     * Returns elements from the Map as an keys Iterator
     *
     * @returns ValueIterator with map keys
     */
    keys(): IterableIterator<K>;

    /**
     * Returns elements from the Map as an values Iterator
     *
     * @returns ValueIterator with map values
     */
    values(): IterableIterator<V>;

    /**
     * Returns elements from the Map as an array of Entries
     *
     * @returns an array of Entries
     */
    entries(): IterableIterator<[K, V]>;
}

final class MapEntry<K, V> {
    prev: MapEntry<K, V> = this
    next: MapEntry<K, V> = this

    key: K
    val: V

    constructor(key: K, val: V) {
        this.key = key
        this.val = val
    }

    toString(): string {
        return `{${this.key},${this.val}}`
    }
}

final class MapIterator<K, V, R> implements IterableIterator<R> {
    private node: MapEntry<K, V>
    private tail: MapEntry<K, V>

    private mapper: (e: MapEntry<K, V>) => R

    constructor(node: MapEntry<K, V>, tail: MapEntry<K, V>, mapper: (e: MapEntry<K, V>) => R) {
        this.node = node
        this.tail = tail
        this.mapper = mapper
    }

    override next(): IteratorResult<R> {
        const nextNode = this.node.next
        if (__runtimeIsSameReference(nextNode, this.tail)) {
            return new IteratorResult<R>()
        }
        this.node = nextNode
        return new IteratorResult<R>(this.mapper(this.node))
    }

    override $_iterator(): IterableIterator<R> {
        return this
    }
}

final class EmptyMapIterator<R> implements IterableIterator<R> {
    override next(): IteratorResult<R> {
        return new IteratorResult<R>()
    }

    override $_iterator(): IterableIterator<R> {
        return this
    }
}

export class Map<K, V> implements ReadonlyMap<K, V> {
    private headEntry: MapEntry<K, V> | undefined = undefined

    private buckets: Array<Array<MapEntry<K, V>>> = new Array<Array<MapEntry<K, V>>>()
    private sizeVal: int = 0

    private static readonly ENTRY_KEY = 0
    private static readonly ENTRY_VAL = 1

    internal static hashOf(a: NullishType): int {
        if (__runtimeIsSameReference(a, null)) {
            return 0;
        }
        if (__runtimeIsSameReference(a, undefined)) {
            return 1;
        }
        return a!.$_hashCode();
    }

    /**
     * Constructs a Map from collection
     * @param entries initial collection
     */
    constructor(entries?: ArrayLike<[K, V]> | Iterable<[K, V]> | null) {
        if (entries != null) {
            const entriesIter = entries.$_iterator()
            const entriesBuf = new Array<[K, V]>()
            for (let iterRes = entriesIter.next();!iterRes.done;iterRes = entriesIter.next()) {
                this.buckets.push(new Array<MapEntry<K, V>>())

                const entry = iterRes.value
                if (entry != null) {
                    entriesBuf.push(entry)
                }
            }

            entriesBuf.forEach((e: [K, V]) => {
                this.set(e[Map.ENTRY_KEY], e[Map.ENTRY_VAL])
            })
        } else {
            this.buckets.push(new Array<MapEntry<K, V>>())
        }
    }

    override toString(): String {
        const strBuf = new StringBuilder()

        const entriesIter = this.entries()
        let entriesIterRes = entriesIter.next()
        while (!entriesIterRes.done) {
            const entry = entriesIterRes.value
            if (!__runtimeIsSameReference(entry, undefined) && !__runtimeIsSameReference(entry, null)) {
                strBuf.append(entry!)
            }

            entriesIterRes = entriesIter.next()
            if (!entriesIterRes.done) {
                strBuf.append(",")
            }
        }

        return strBuf.toString()
    }

    private getBucket(v: NullishType): Array<MapEntry<K, V>> {
        let idx = Map.hashOf(v) % this.buckets.actualLength;
        idx += this.buckets.actualLength;
        idx %= this.buckets.actualLength;
        return this.buckets[idx]
    }

    private rehash(): void {
        const entriesIter = this.mappedIterator<MapEntry<K, V>>((e: MapEntry<K, V>): MapEntry<K, V> => e)
        const oldSize = this.buckets.length
        for (let i = 0; i < oldSize; i++) {
            const a = this.buckets[i]
            a.length = 0
            this.buckets.push(new Array<MapEntry<K, V>>())
        }
        iteratorForEach<MapEntry<K, V>>(entriesIter, (e: MapEntry<K, V>): void => {
            this.getBucket(e.key).push(e)
        })
    }


    /**
     * Puts a pair of key and value into the Map
     *
     * @param key the key to put into the Map
     *
     * @param val the value to put into the Map
     */
    set(key: K, val: V): this {
        // insert into buckets
        const buck = this.getBucket(key)
        const buckSize = buck.length
        for (let i = 0; i < buckSize; i++) {
            const entry = buck.$_get(i)
            if (__runtimeSameValueZero(entry.key, key)) {
                entry.val = val
                return this
            }
        }

        // not found, add to insertion-ordered list
        const newEntry = new MapEntry<K, V>(key, val)

        if (this.headEntry === undefined) {
            this.headEntry = new MapEntry<K, V>(key, val)
        }

        const headEntry = this.headEntry!
        newEntry.next = headEntry
        newEntry.prev = headEntry.prev
        headEntry.prev.next = newEntry
        headEntry.prev = newEntry

        buck.push(newEntry)

        this.sizeVal += 1

        // constant load factor (entries / buckets < 0.75)
        if (this.sizeVal * 4 > this.buckets.length * 3) {
            this.rehash();
        }

        return this;
    }

    /**
     * Checks if a key is in the Map
     *
     * @param key the key to find in the Map
     *
     * @returns true if the value is in the Map
     */
    override has(key: K): boolean {
        const buck = this.getBucket(key)
        const buckSize = buck.length
        for (let i = 0; i < buckSize; i++) {
            const entry = buck.$_get(i)
            if (__runtimeSameValueZero(entry.key, key)) {
                return true
            }
        }
        return false;
    }

    /**
     * Returns number of Entries with unique keys in the Map
     *
     * @returns number of Entries with unique keys in the Map
     */
    override get size(): number {
        return this.sizeVal
    }

    /**
     * Removes an Entry with specified key from the Map
     *
     * @param key the key to remove
     */
    delete(key: K): boolean {
        return this.deleteImpl(key)
    }

    internal deleteImpl(key: K): boolean {
        const buck = this.getBucket(key)
        const buckSize = buck.length
        for (let i = 0; i < buckSize; i++) {
            const entry = buck.$_get(i)
            if (__runtimeSameValueZero(entry.key, key)) {
                entry.prev.next = entry.next
                entry.next.prev = entry.prev
                buck.fill(buck.pop()!, i, i + 1)
                this.sizeVal -= 1

                if (this.sizeVal == 0) {
                    this.headEntry = undefined
                }

                return true
            }
        }
        return false
    }

    /**
     * Deletes all elements from the Map
     */
    clear(): void {
        this.sizeVal = 0

        if (this.headEntry !== undefined) {
            this.headEntry = undefined
            this.buckets = new Array<Array<MapEntry<K, V>>>()
            this.buckets.push(new Array<MapEntry<K, V>>())
        }
    }

    /**
     * Returns a value assosiated with key if present
     *
     * @param key the key to find in the Map
     *
     * @returns value if assosiated with key presents.
     */
    override get(key: K): V | undefined {
        const buck = this.getBucket(key)
        const buckSize = buck.length
        for (let i = 0; i < buckSize; i++) {
            const entry = buck.$_get(i)
            if (__runtimeSameValueZero(entry.key, key)) {
                return entry.val
            }
        }
        return undefined;
    }

    /**
     * Returns a value assosiated with key if present, or a default value otherwise
     *
     * @param key the key to find in the Map
     *
     * @param def a value to return if key is not in the Map
     *
     * @returns value if key presents, def otherwise
     */
    get(key: K, def: V): V {
        const val = this.get(key)
        if (val !== undefined) {
            return val
        }
        return def
    }

    internal mappedIterator<R>(fn: (e: MapEntry<K, V>) => R): IterableIterator<R> {
        const headEntry = this.headEntry
        if (headEntry !== undefined) {
            return new MapIterator<K, V, R>(headEntry, headEntry, fn)
        } else {
            return new EmptyMapIterator<R>()
        }
    }

    /**
     * Returns elements from the Map as an keys Iterator
     *
     * @returns iterator with map keys
     */
    override keys(): IterableIterator<K> {
        return this.mappedIterator<K>((e: MapEntry<K, V>): K => e.key)
    }

    /**
     * Returns elements from the Map as an values Iterator
     *
     * @returns iterator with map values
     */
    override values(): IterableIterator<V> {
        return this.mappedIterator<V>((e: MapEntry<K, V>): V => e.val )
    }

    override $_iterator(): IterableIterator<[K, V]> {
        return this.entries()
    }

    /**
     * Returns elements from the Map as an array of Entries
     *
     * @returns an array of Entries
     */
    override entries(): IterableIterator<[K, V]> {
        return this.mappedIterator<[K, V]>((e: MapEntry<K, V>): [K, V] => [e.key, e.val])
    }

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    override forEach(callbackfn: (v: V, k: K, map: Map<K, V>) => void): void {
        const entriesIter = this.mappedIterator<MapEntry<K, V>>((e: MapEntry<K, V>): MapEntry<K, V> => e)
        iteratorForEach<MapEntry<K, V>>(entriesIter, (e: MapEntry<K, V>): void => {
            callbackfn(e.val, e.key, this)
        })
    }

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    override forEach(callbackfn: (v: V, k: K) => void): void {
        const entriesIter = this.mappedIterator<MapEntry<K, V>>((e: MapEntry<K, V>): MapEntry<K, V> => e)
        iteratorForEach<MapEntry<K, V>>(entriesIter, (e: MapEntry<K, V>): void => {
            callbackfn(e.val, e.key)
        })
    }

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    override forEach(callbackfn: (v: V) => void): void {
        iteratorForEach<V>(this.values(), callbackfn)
    }

    /**
     * Executes a provided function once per each key/value pair in the Map, in insertion order
     *
     * @param callbackfn to apply
     */
    override forEach(callbackfn: () => void): void {
        iteratorForEach<V>(this.values(), (v: V) => callbackfn())
    }
}

export class Record<K extends Numeric | string, V> extends Map<K, V> {
    $_get(k : K) : V | undefined {
        return super.get(k)
    }

    $_set(k: K, v: V) : void {
        super.set(k, v)
    }
}