/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file. DO NOT EDIT

package escompat

class Int8ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class Int8ArrayIterator implements IterableIterator<Number> {
    private parent: Int8Array
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int8ArrayIteratorEntries implements IterableIterator<[Number, Number]> {
    private parent: Int8Array
    private idx: int = 0

    constructor(parent: Int8Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, Number]> {
        return this
    }

    override next(): IteratorResult<[Number, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, Number]>()
        }
        return new IteratorResult<[Number, Number]>(
            false, [new Number(this.idx), new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * JS Int8Array API-compatible class
 */
export final class Int8Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: number = 1
    internal readonly lengthInt: int

    /**
     * Creates an empty Int8Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an Int8Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        let x = Int8Array.from(elements)
        this.byteLength = x.byteLength
        this.lengthInt = x.lengthInt
        this.buffer = x.buffer
        this.byteOffset = x.byteOffset
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / Int8Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Int8Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Int8Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * Int8Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int8Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int8Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 1 as Int8Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int8Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % Int8Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 1 as Int8Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int8Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * Int8Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).byteValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * Int8Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int8Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int8Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an Int8Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as byte)
        }
    }

    /**
     * Creates an Int8Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as byte)
        }
    }

    internal zeroIfInfinity(val: number): number {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as number
        }
        return val as number
    }

    internal zeroIfInfinity(val: byte): byte {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as byte
        }
        return val
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: number): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v as byte)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val as byte)
        this.setUnsafe(index, v as byte)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: byte): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: byte): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v)
    }

    /** Number of byte stored in Int8Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): Number {
        return this.$_get(index as int) as Number
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): number {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return this.getUnsafe(index) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): Number | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): Int8Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): Int8Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): Int8Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): Int8Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): Int8Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int8Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): Int8Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int8Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Int8Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int8Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, Number]> {
        return new Int8ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start?: number, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as byte, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: int, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as byte, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: int, end: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as byte, start as int, end as int)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: number, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as byte, start as int, end as int)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: int, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as byte, start as int, end as int)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start?: number, end?: number): this {
        this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: int, end?: number): this {
        this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: int, end: number): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: number, end: int): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(byte[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(byte[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: byte): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v as byte)
        }
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: byte[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v)
        }
    }

    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0 as number)
    }

    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: byte[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the Int8Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            let v = this.zeroIfInfinity(array[i])
            this.setUnsafe(insertPos + i, v as byte)
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int8Array
     */
    public static of(...items: number[]): Int8Array {
        let res = new Int8Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, res.zeroIfInfinity(items[i]) as byte)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int8Array
     */
    public static of(...items: int[]): Int8Array {
        let res = new Int8Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i] as byte)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int8Array
     */
    public static of(...items: byte[]): Int8Array {
        let res = new Int8Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i])
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int8Array
     */
    public static of(): Int8Array {
        return new Int8Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Int8Array
     */
    public static from(arrayLike: ArrayLike<number>): Int8Array {
        return Int8Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int8Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int8Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE: This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int8Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int8Array(result.buffer, 0, i)
                }
                result.setUnsafe(i, result.zeroIfInfinity((mapfn)!(x.value!, i)) as byte)
            }
            return result
        }

        // NOTE: Create builtin array as buffer
        let temp = new Int8Array(6)
        let index = new int[1]
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE: Progressive reallocation
                const curLength = (temp.buffer as Buffer).getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, (temp.buffer as Buffer).at(i))
                }
                temp = new Int8Array(tb)
            }
            temp.setUnsafe(index[0], temp.zeroIfInfinity((mapfn)!(x, index[0])) as byte)
            index[0]++
        })
        return new Int8Array(temp.buffer, 0, index[0])
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int8Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): Int8Array {
        let res = new Int8Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            res.setUnsafe(idx[0] as int, res.zeroIfInfinity(mapfn(x as T, idx[0] as number)) as byte)
            idx[0] += 1
        })
        return res
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int8Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: number): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if e is in Int8Array, false otherwise
     */
    public includes(searchElement: byte, fromIndex: int): boolean {
        return this.indexOf(searchElement as int, fromIndex) != -1
    }

    /**
     * Determines whether Int8Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int8Array, false otherwise
     */
    public includes(searchElement: byte): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) as number == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement as byte) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(this.getUnsafe(i) as number)
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(this.getUnsafe(this.lengthInt - 1) as number)
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in Int8Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new Int8ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) as number == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement as byte) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int8Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new Int8Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int8Array from data
    */
    public of(data: Object[]): Int8Array {
        throw new Error("Int8Array.of: not implemented")
    }

    /**
     * Creates a new Int8Array using reversed data from the current one
     *
     * @returns a new Int8Array using reversed data from the current one
     */
    public reverse(): Int8Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): Int8Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Int8Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): Int8Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): Int8Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int8Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * Int8Array.BYTES_PER_ELEMENT as int, relEnd * Int8Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new Int8Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * Int8Array.BYTES_PER_ELEMENT as int, relEnd * Int8Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new Int8Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current Int8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin, this.length)
     */
    public slice(begin: number): Int8Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin, this.length)
     */
    public slice(begin: int): Int8Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): Int8Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): Int8Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): Int8Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): Int8Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): Int8Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int8Array(this.buffer, relStart * Int8Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a Int8Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int8Array with the same ArrayBufferLike
     */
    public subarray(begin: number): Int8Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a Int8Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int8Array with the same ArrayBufferLike
     */
    public subarray(begin: int): Int8Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int8Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i) as Number).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1) as Number).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int8Array {
        return new Int8Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int8Array {
        return new Int8Array(this).sort()
    }

    /**
     * Returns a string representation of the Int8Array
     *
     * @returns a string representation of the Int8Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
        return new Int8ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int8Array with replaced value on index
     */
    public with(index: number, value: number): Int8Array {
        return this.with(index as int, value as byte)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int8Array with replaced value on index
     */
    public with(index: int, value: byte): Int8Array {
        let res = new Int8Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int8Array): boolean => predicate(element))
    }

    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int8Array {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: () => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int8Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int8Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int8Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int8Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number) => void): void {
        this.forEach((value: number, index: number, array: Int8Array): void => callbackfn(value))
    }

    /**
     * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array
     *
     * @param fn a function to apply for each element of current Int8Array
     *
     * @returns a new Int8Array where for each element from current Int8Array fn was applied
     */
    public map(fn: (val: number) => number): Int8Array {
        let newF: (val: number, index: number) => number =
            (val: number, index: number): number => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int8Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted Int8Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        let arr: byte[] = new byte[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: byte, r: byte): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: byte, r: byte): number => {
                return compareFn!(l as number, r as number)
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int8Array
     */
    public sort(compareFn: (a: number) => number): this {
        let cmp = (a: number, b: number) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int8Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: number, b: number) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int8Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: number, index: number, array: Int8Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.getUnsafe(0) as number
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int8Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.getUnsafe(this.lengthInt - 1) as number
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int8Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int8Array) =>
                        callbackfn())
    }

   /**
    * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array.
    *
    * @param fn a function to apply for each element of current Int8Array
    *
    * @returns a new Int8Array where for each element from current Int8Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int8Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int8Array.BYTES_PER_ELEMENT as int)
        let res = new Int8Array(resBuf, 0, resBuf.getByteLength() / Int8Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(this.getUnsafe(i) as number, i as number) as byte)
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(this.getUnsafe(i) as number, i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int8Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: number, index: number, array: Int8Array): boolean => predicate())
    }

    /**
     * Creates a new Int8Array from current Int8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int8Array) => boolean): Int8Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(this.getUnsafe(i) as number, i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int8Array.BYTES_PER_ELEMENT as int)
        let res = new Int8Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int8Array {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: () => boolean): Int8Array {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number, obj: Int8Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(val as number, i as number, this)) {
                return val as number
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int8Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int8Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int8Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int8Array) => boolean): byte {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return val
            }
        }
        throw new Error("Int8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): byte {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val as number, index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int8Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: number, array: Int8Array) => boolean =
            (val: number, index: number, array: Int8Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int8Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number, array: Int8Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(this.getUnsafe(i) as number, i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in Int8Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number) => void): void {
        this.forEach((value: number, index: number, array: Int8Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in Int8Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: number, index: number, array: Int8Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns Int8Array
     */
    public valueOf(): Int8Array {
        return this
    }

    internal getUnsafe(index: int): byte {
        let byteIndex = index * Int8Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : byte = 0
        let byteVal : byte
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    res = (res | byteVal << (8 * i)) as byte
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    res = (res | byteVal << (8 * i)) as byte
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 0 - i)
                    res = (res | byteVal << (8 * i)) as byte
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 0 - i)
                    res = (res | byteVal << (8 * i)) as byte
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        }
    }

    internal setUnsafe(insertPos: int, val: byte): void {
        let startByte = insertPos * Int8Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 0 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 0 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"Int8Array\" */
    public readonly name = "Int8Array"
}

class Int16ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class Int16ArrayIterator implements IterableIterator<Number> {
    private parent: Int16Array
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int16ArrayIteratorEntries implements IterableIterator<[Number, Number]> {
    private parent: Int16Array
    private idx: int = 0

    constructor(parent: Int16Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, Number]> {
        return this
    }

    override next(): IteratorResult<[Number, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, Number]>()
        }
        return new IteratorResult<[Number, Number]>(
            false, [new Number(this.idx), new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * JS Int16Array API-compatible class
 */
export final class Int16Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: number = 2
    internal readonly lengthInt: int

    /**
     * Creates an empty Int16Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an Int16Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        let x = Int16Array.from(elements)
        this.byteLength = x.byteLength
        this.lengthInt = x.lengthInt
        this.buffer = x.buffer
        this.byteOffset = x.byteOffset
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteLength % Int16Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % Int16Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / Int16Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Int16Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Int16Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * Int16Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int16Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int16Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int16Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % Int16Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int16Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * Int16Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).shortValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * Int16Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int16Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int16Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an Int16Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as short)
        }
    }

    /**
     * Creates an Int16Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as short)
        }
    }

    internal zeroIfInfinity(val: number): number {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as number
        }
        return val as number
    }

    internal zeroIfInfinity(val: short): short {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as short
        }
        return val
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: number): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v as short)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val as short)
        this.setUnsafe(index, v as short)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: short): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: short): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v)
    }

    /** Number of short stored in Int16Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): Number {
        return this.$_get(index as int) as Number
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): number {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return this.getUnsafe(index) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): Number | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): Int16Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): Int16Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): Int16Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): Int16Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): Int16Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int16Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): Int16Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int16Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Int16Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int16Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, Number]> {
        return new Int16ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start?: number, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as short, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: int, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as short, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: int, end: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as short, start as int, end as int)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: number, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as short, start as int, end as int)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: int, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as short, start as int, end as int)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start?: number, end?: number): this {
        this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: int, end?: number): this {
        this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: int, end: number): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: number, end: int): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(short[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(short[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: short): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v as short)
        }
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: short[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v)
        }
    }

    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0 as number)
    }

    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: short[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the Int16Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            let v = this.zeroIfInfinity(array[i])
            this.setUnsafe(insertPos + i, v as short)
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int16Array
     */
    public static of(...items: number[]): Int16Array {
        let res = new Int16Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, res.zeroIfInfinity(items[i]) as short)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int16Array
     */
    public static of(...items: int[]): Int16Array {
        let res = new Int16Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i] as short)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int16Array
     */
    public static of(...items: short[]): Int16Array {
        let res = new Int16Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i])
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int16Array
     */
    public static of(): Int16Array {
        return new Int16Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Int16Array
     */
    public static from(arrayLike: ArrayLike<number>): Int16Array {
        return Int16Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int16Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int16Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE: This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int16Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int16Array(result.buffer, 0, i)
                }
                result.setUnsafe(i, result.zeroIfInfinity((mapfn)!(x.value!, i)) as short)
            }
            return result
        }

        // NOTE: Create builtin array as buffer
        let temp = new Int16Array(6)
        let index = new int[1]
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE: Progressive reallocation
                const curLength = (temp.buffer as Buffer).getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, (temp.buffer as Buffer).at(i))
                }
                temp = new Int16Array(tb)
            }
            temp.setUnsafe(index[0], temp.zeroIfInfinity((mapfn)!(x, index[0])) as short)
            index[0]++
        })
        return new Int16Array(temp.buffer, 0, index[0])
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int16Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): Int16Array {
        let res = new Int16Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            res.setUnsafe(idx[0] as int, res.zeroIfInfinity(mapfn(x as T, idx[0] as number)) as short)
            idx[0] += 1
        })
        return res
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int16Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: number): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if e is in Int16Array, false otherwise
     */
    public includes(searchElement: short, fromIndex: int): boolean {
        return this.indexOf(searchElement as int, fromIndex) != -1
    }

    /**
     * Determines whether Int16Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int16Array, false otherwise
     */
    public includes(searchElement: short): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) as number == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement as short) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(this.getUnsafe(i) as number)
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(this.getUnsafe(this.lengthInt - 1) as number)
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in Int16Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new Int16ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) as number == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement as short) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int16Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new Int16Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int16Array from data
    */
    public of(data: Object[]): Int16Array {
        throw new Error("Int16Array.of: not implemented")
    }

    /**
     * Creates a new Int16Array using reversed data from the current one
     *
     * @returns a new Int16Array using reversed data from the current one
     */
    public reverse(): Int16Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): Int16Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Int16Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): Int16Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): Int16Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int16Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * Int16Array.BYTES_PER_ELEMENT as int, relEnd * Int16Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new Int16Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * Int16Array.BYTES_PER_ELEMENT as int, relEnd * Int16Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new Int16Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current Int16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin, this.length)
     */
    public slice(begin: number): Int16Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin, this.length)
     */
    public slice(begin: int): Int16Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): Int16Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): Int16Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): Int16Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): Int16Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): Int16Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int16Array(this.buffer, relStart * Int16Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a Int16Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int16Array with the same ArrayBufferLike
     */
    public subarray(begin: number): Int16Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a Int16Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int16Array with the same ArrayBufferLike
     */
    public subarray(begin: int): Int16Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int16Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i) as Number).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1) as Number).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int16Array {
        return new Int16Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int16Array {
        return new Int16Array(this).sort()
    }

    /**
     * Returns a string representation of the Int16Array
     *
     * @returns a string representation of the Int16Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
        return new Int16ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int16Array with replaced value on index
     */
    public with(index: number, value: number): Int16Array {
        return this.with(index as int, value as short)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int16Array with replaced value on index
     */
    public with(index: int, value: short): Int16Array {
        let res = new Int16Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int16Array): boolean => predicate(element))
    }

    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int16Array {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: () => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int16Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int16Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int16Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int16Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number) => void): void {
        this.forEach((value: number, index: number, array: Int16Array): void => callbackfn(value))
    }

    /**
     * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array
     *
     * @param fn a function to apply for each element of current Int16Array
     *
     * @returns a new Int16Array where for each element from current Int16Array fn was applied
     */
    public map(fn: (val: number) => number): Int16Array {
        let newF: (val: number, index: number) => number =
            (val: number, index: number): number => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int16Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted Int16Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        let arr: short[] = new short[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: short, r: short): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: short, r: short): number => {
                return compareFn!(l as number, r as number)
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int16Array
     */
    public sort(compareFn: (a: number) => number): this {
        let cmp = (a: number, b: number) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int16Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: number, b: number) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int16Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: number, index: number, array: Int16Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.getUnsafe(0) as number
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int16Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.getUnsafe(this.lengthInt - 1) as number
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int16Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int16Array) =>
                        callbackfn())
    }

   /**
    * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array.
    *
    * @param fn a function to apply for each element of current Int16Array
    *
    * @returns a new Int16Array where for each element from current Int16Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int16Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int16Array.BYTES_PER_ELEMENT as int)
        let res = new Int16Array(resBuf, 0, resBuf.getByteLength() / Int16Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(this.getUnsafe(i) as number, i as number) as short)
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(this.getUnsafe(i) as number, i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int16Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: number, index: number, array: Int16Array): boolean => predicate())
    }

    /**
     * Creates a new Int16Array from current Int16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int16Array) => boolean): Int16Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(this.getUnsafe(i) as number, i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int16Array.BYTES_PER_ELEMENT as int)
        let res = new Int16Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int16Array {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: () => boolean): Int16Array {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number, obj: Int16Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(val as number, i as number, this)) {
                return val as number
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int16Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int16Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int16Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int16Array) => boolean): short {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return val
            }
        }
        throw new Error("Int16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): short {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val as number, index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int16Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: number, array: Int16Array) => boolean =
            (val: number, index: number, array: Int16Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int16Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number, array: Int16Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(this.getUnsafe(i) as number, i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in Int16Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number) => void): void {
        this.forEach((value: number, index: number, array: Int16Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in Int16Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: number, index: number, array: Int16Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns Int16Array
     */
    public valueOf(): Int16Array {
        return this
    }

    internal getUnsafe(index: int): short {
        let byteIndex = index * Int16Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : short = 0
        let byteVal : short
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as short
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as short
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 1 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as short
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 1 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as short
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        }
    }

    internal setUnsafe(insertPos: int, val: short): void {
        let startByte = insertPos * Int16Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 1 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 1 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"Int16Array\" */
    public readonly name = "Int16Array"
}

class Int32ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class Int32ArrayIterator implements IterableIterator<Number> {
    private parent: Int32Array
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Int32ArrayIteratorEntries implements IterableIterator<[Number, Number]> {
    private parent: Int32Array
    private idx: int = 0

    constructor(parent: Int32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, Number]> {
        return this
    }

    override next(): IteratorResult<[Number, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, Number]>()
        }
        return new IteratorResult<[Number, Number]>(
            false, [new Number(this.idx), new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * JS Int32Array API-compatible class
 */
export final class Int32Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: number = 4
    internal readonly lengthInt: int

    /**
     * Creates an empty Int32Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an Int32Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        let x = Int32Array.from(elements)
        this.byteLength = x.byteLength
        this.lengthInt = x.lengthInt
        this.buffer = x.buffer
        this.byteOffset = x.byteOffset
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteLength % Int32Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % Int32Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / Int32Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Int32Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Int32Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * Int32Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Int32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Int32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Int32Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int32Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % Int32Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Int32Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * Int32Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).intValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * Int32Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int32Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an Int32Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as int)
        }
    }

    /**
     * Creates an Int32Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i]) as int)
        }
    }

    internal zeroIfInfinity(val: number): number {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as number
        }
        return val as number
    }

    internal zeroIfInfinity(val: int): int {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as int
        }
        return val
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: number): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v as int)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v)
    }

    /** Number of int stored in Int32Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): Number {
        return this.$_get(index as int) as Number
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): number {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return this.getUnsafe(index) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): Number | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): Int32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): Int32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): Int32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): Int32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): Int32Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int32Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): Int32Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Int32Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Int32Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the Int32Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, Number]> {
        return new Int32ArrayIteratorEntries(this)
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start?: number, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as int, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: int, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as int, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: int, end: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as int, start as int, end as int)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: number, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as int, start as int, end as int)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: int, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value as int, start as int, end as int)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start?: number, end?: number): this {
        this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: int, end?: number): this {
        this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: int, end: number): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: number, end: int): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(int[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(int[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: int): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v as int)
        }
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: int[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v)
        }
    }

    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0 as number)
    }

    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: int[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the Int32Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            let v = this.zeroIfInfinity(array[i])
            this.setUnsafe(insertPos + i, v as int)
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int32Array
     */
    public static of(...items: number[]): Int32Array {
        let res = new Int32Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, res.zeroIfInfinity(items[i]) as int)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int32Array
     */
    public static of(...items: int[]): Int32Array {
        let res = new Int32Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i])
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Int32Array
     */
    public static of(): Int32Array {
        return new Int32Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Int32Array
     */
    public static from(arrayLike: ArrayLike<number>): Int32Array {
        return Int32Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int32Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Int32Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE: This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Int32Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Int32Array(result.buffer, 0, i)
                }
                result.setUnsafe(i, result.zeroIfInfinity((mapfn)!(x.value!, i)) as int)
            }
            return result
        }

        // NOTE: Create builtin array as buffer
        let temp = new Int32Array(6)
        let index = new int[1]
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE: Progressive reallocation
                const curLength = (temp.buffer as Buffer).getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, (temp.buffer as Buffer).at(i))
                }
                temp = new Int32Array(tb)
            }
            temp.setUnsafe(index[0], temp.zeroIfInfinity((mapfn)!(x, index[0])) as int)
            index[0]++
        })
        return new Int32Array(temp.buffer, 0, index[0])
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Int32Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): Int32Array {
        let res = new Int32Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            res.setUnsafe(idx[0] as int, res.zeroIfInfinity(mapfn(x as T, idx[0] as number)) as int)
            idx[0] += 1
        })
        return res
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int32Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: number): boolean {
        if (isNaN(searchElement)) {
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if e is in Int32Array, false otherwise
     */
    public includes(searchElement: int, fromIndex: int): boolean {
        return this.indexOf(searchElement as int, fromIndex) != -1
    }

    /**
     * Determines whether Int32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Int32Array, false otherwise
     */
    public includes(searchElement: int): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) as number == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(this.getUnsafe(i) as number)
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(this.getUnsafe(this.lengthInt - 1) as number)
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in Int32Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new Int32ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) as number == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Int32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new Int32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int32Array from data
    */
    public of(data: Object[]): Int32Array {
        throw new Error("Int32Array.of: not implemented")
    }

    /**
     * Creates a new Int32Array using reversed data from the current one
     *
     * @returns a new Int32Array using reversed data from the current one
     */
    public reverse(): Int32Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): Int32Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Int32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): Int32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): Int32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * Int32Array.BYTES_PER_ELEMENT as int, relEnd * Int32Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new Int32Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * Int32Array.BYTES_PER_ELEMENT as int, relEnd * Int32Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new Int32Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current Int32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin, this.length)
     */
    public slice(begin: number): Int32Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin, this.length)
     */
    public slice(begin: int): Int32Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): Int32Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): Int32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): Int32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): Int32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): Int32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Int32Array(this.buffer, relStart * Int32Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a Int32Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int32Array with the same ArrayBufferLike
     */
    public subarray(begin: number): Int32Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a Int32Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Int32Array with the same ArrayBufferLike
     */
    public subarray(begin: int): Int32Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i) as Number).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1) as Number).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int32Array {
        return new Int32Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int32Array {
        return new Int32Array(this).sort()
    }

    /**
     * Returns a string representation of the Int32Array
     *
     * @returns a string representation of the Int32Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
        return new Int32ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int32Array with replaced value on index
     */
    public with(index: number, value: number): Int32Array {
        return this.with(index as int, value as int)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int32Array with replaced value on index
     */
    public with(index: int, value: int): Int32Array {
        let res = new Int32Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int32Array): boolean => predicate(element))
    }

    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int32Array {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: () => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int32Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int32Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int32Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number) => void): void {
        this.forEach((value: number, index: number, array: Int32Array): void => callbackfn(value))
    }

    /**
     * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array
     *
     * @param fn a function to apply for each element of current Int32Array
     *
     * @returns a new Int32Array where for each element from current Int32Array fn was applied
     */
    public map(fn: (val: number) => number): Int32Array {
        let newF: (val: number, index: number) => number =
            (val: number, index: number): number => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int32Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted Int32Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        let arr: int[] = new int[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: int, r: int): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: int, r: int): number => {
                return compareFn!(l as number, r as number)
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int32Array
     */
    public sort(compareFn: (a: number) => number): this {
        let cmp = (a: number, b: number) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Int32Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: number, b: number) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Int32Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: number, index: number, array: Int32Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.getUnsafe(0) as number
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Int32Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.getUnsafe(this.lengthInt - 1) as number
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int32Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Int32Array) =>
                        callbackfn())
    }

   /**
    * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array.
    *
    * @param fn a function to apply for each element of current Int32Array
    *
    * @returns a new Int32Array where for each element from current Int32Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int32Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Int32Array.BYTES_PER_ELEMENT as int)
        let res = new Int32Array(resBuf, 0, resBuf.getByteLength() / Int32Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(this.getUnsafe(i) as number, i as number) as int)
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(this.getUnsafe(i) as number, i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Int32Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: number, index: number, array: Int32Array): boolean => predicate())
    }

    /**
     * Creates a new Int32Array from current Int32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int32Array) => boolean): Int32Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(this.getUnsafe(i) as number, i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int32Array.BYTES_PER_ELEMENT as int)
        let res = new Int32Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int32Array {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: () => boolean): Int32Array {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number, obj: Int32Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(val as number, i as number, this)) {
                return val as number
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Int32Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int32Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: number, index: number, obj: Int32Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int32Array) => boolean): int {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return val
            }
        }
        throw new Error("Int32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): int {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val as number, index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int32Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: number, array: Int32Array) => boolean =
            (val: number, index: number, array: Int32Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Int32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number, array: Int32Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(this.getUnsafe(i) as number, i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in Int32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number) => void): void {
        this.forEach((value: number, index: number, array: Int32Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in Int32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: number, index: number, array: Int32Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns Int32Array
     */
    public valueOf(): Int32Array {
        return this
    }

    internal getUnsafe(index: int): int {
        let byteIndex = index * Int32Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : int = 0
        let byteVal : int
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 3 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 3 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        }
    }

    internal setUnsafe(insertPos: int, val: int): void {
        let startByte = insertPos * Int32Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 3 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 3 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"Int32Array\" */
    public readonly name = "Int32Array"
}

class BigInt64ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class BigInt64ArrayIterator implements IterableIterator<BigInt> {
    private parent: BigInt64Array
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<BigInt> {
        return this
    }

    override next(): IteratorResult<BigInt> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<BigInt>()
        }
        return new IteratorResult<BigInt>(false, new BigInt(this.parent[this.idx++]))
    }
}

class BigInt64ArrayIteratorEntries implements IterableIterator<[Number, BigInt]> {
    private parent: BigInt64Array
    private idx: int = 0

    constructor(parent: BigInt64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, BigInt]> {
        return this
    }

    override next(): IteratorResult<[Number, BigInt]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, BigInt]>()
        }
        return new IteratorResult<[Number, BigInt]>(
            false, [new Number(this.idx), new BigInt(this.parent[this.idx++])] as [Number, BigInt]
        )
    }
}


/**
 * JS BigInt64Array API-compatible class
 */
export final class BigInt64Array implements Iterable<BigInt>, ArrayLike<BigInt> {
    public static readonly BYTES_PER_ELEMENT: number = 8
    internal readonly lengthInt: int

    /**
     * Creates an empty BigInt64Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an BigInt64Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<BigInt>) {
        // NOTE (templin.konstantin): Please remove this code block after
        //  BigInt.from implementation

        let iterator = elements.$_iterator();
        let result = new IteratorResult<BigInt>()
        let length = 0
        while ((result = iterator.next()).done != true) {
            ++length
        }
        this.byteLength = length * BigInt64Array.BYTES_PER_ELEMENT as int
        this.lengthInt = length as int
        this.buffer = new ArrayBuffer(this.byteLength as int)
        this.byteOffset = 0
        iterator = elements.$_iterator();
        let i = 0
        while ((result = iterator.next()).done != true) {
            if (__runtimeIsSameReference(result.value, undefined)) {
                continue
            }
            this.setUnsafe(i++, (result.value as BigInt).getLong())
        }
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteLength % BigInt64Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % BigInt64Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / BigInt64Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / BigInt64Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / BigInt64Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * BigInt64Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an BigInt64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an BigInt64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % BigInt64Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / BigInt64Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % BigInt64Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / BigInt64Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * BigInt64Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).longValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * BigInt64Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of BigInt64Array.
     *
     * @param other data initializer
     */
    public constructor(other: BigInt64Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an BigInt64Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i] as long))
        }
    }

    /**
     * Creates an BigInt64Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, this.zeroIfInfinity(numbers[i] as long))
        }
    }

    internal zeroIfInfinity(val: BigInt): BigInt {
        if ((val.getLong() == Infinity) || (val.getLong() == -Infinity)) {
            return new BigInt(0)
        }
        return new BigInt(val)
    }

    internal zeroIfInfinity(val: long): long {
        if ((val == Infinity) || (val == -Infinity)) {
            return 0 as long
        }
        return val
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: BigInt): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: BigInt): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v.getLong())
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val as long)
        this.setUnsafe(index, v as long)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: long): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: long): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        let v = this.zeroIfInfinity(val)
        this.setUnsafe(index, v)
    }

    /** Number of long stored in BigInt64Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of BigInt at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): BigInt {
        return this.$_get(index as int) as BigInt
    }

    /**
     * Returns an instance of BigInt at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): BigInt {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return new BigInt(this.getUnsafe(index))
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): BigInt | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): BigInt | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new BigInt(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): BigInt64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): BigInt64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): BigInt64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): BigInt64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): BigInt64Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of BigInt64Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): BigInt64Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of BigInt64Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): BigInt64Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the BigInt64Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, BigInt]> {
        return new BigInt64ArrayIteratorEntries(this)
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start?: number, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value.getLong(), asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: int, end?: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value.getLong(), start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: int, end: number): this {
        value = this.zeroIfInfinity(value)
        this.fill(value.getLong(), start as int, end as int)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: number, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value.getLong(), start as int, end as int)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: int, end: int): this {
        value = this.zeroIfInfinity(value)
        this.fill(value.getLong(), start as int, end as int)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start?: number, end?: number): this {
        this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: int, end?: number): this {
        this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: int, end: number): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: number, end: int): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(long[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: BigInt): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(long[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: long): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: BigInt[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v.getLong())
        }
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: long[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            let v = this.zeroIfInfinity(arr[i])
            this.setUnsafe(offset + i, v)
        }
    }

    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: BigInt[]): void {
        this.set(arr, 0 as number)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: long[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the BigInt64Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<BigInt>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            let v = this.zeroIfInfinity(array[i])
            this.setUnsafe(insertPos + i, v.getLong())
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigInt64Array
     */
    public static of(...items: number[]): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigInt64Array
     */
    public static of(...items: int[]): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigInt64Array
     */
    public static of(...items: long[]): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new BigInt64Array
     */
    public static of(): BigInt64Array {
        return new BigInt64Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new BigInt64Array
     */
    public static from(arrayLike: ArrayLike<number>): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new BigInt64Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new BigInt64Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in BigInt64Array, false otherwise
     */
    public includes(searchElement: BigInt, fromIndex?: number): boolean {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if e is in BigInt64Array, false otherwise
     */
    public includes(searchElement: long, fromIndex: int): boolean {
        return this.indexOf(searchElement as int, fromIndex) != -1
    }

    /**
     * Determines whether BigInt64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in BigInt64Array, false otherwise
     */
    public includes(searchElement: long): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: BigInt, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: BigInt, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (new BigInt(this.getUnsafe(i)) == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement as long) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new BigInt(this.getUnsafe(i)))
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(new BigInt(this.getUnsafe(this.lengthInt - 1)))
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in BigInt64Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new BigInt64ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: BigInt, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: BigInt): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: BigInt, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (new BigInt(this.getUnsafe(k)) == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement as long) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in BigInt64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new BigInt64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new BigInt64Array from data
    */
    public of(data: Object[]): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Creates a new BigInt64Array using reversed data from the current one
     *
     * @returns a new BigInt64Array using reversed data from the current one
     */
    public reverse(): BigInt64Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): BigInt64Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): BigInt64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): BigInt64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): BigInt64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): BigInt64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * BigInt64Array.BYTES_PER_ELEMENT as int, relEnd * BigInt64Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new BigInt64Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * BigInt64Array.BYTES_PER_ELEMENT as int, relEnd * BigInt64Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new BigInt64Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin, this.length)
     */
    public slice(begin: number): BigInt64Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin, this.length)
     */
    public slice(begin: int): BigInt64Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): BigInt64Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): BigInt64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): BigInt64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): BigInt64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): BigInt64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new BigInt64Array(this.buffer, relStart * BigInt64Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a BigInt64Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new BigInt64Array with the same ArrayBufferLike
     */
    public subarray(begin: number): BigInt64Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a BigInt64Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new BigInt64Array with the same ArrayBufferLike
     */
    public subarray(begin: int): BigInt64Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("BigInt64Array.toLocaleString: not implemented")
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(new BigInt(this.getUnsafe(i)).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append(new BigInt(this.getUnsafe(this.lengthInt - 1)).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): BigInt64Array {
        return new BigInt64Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): BigInt64Array {
        return new BigInt64Array(this).sort()
    }

    /**
     * Returns a string representation of the BigInt64Array
     *
     * @returns a string representation of the BigInt64Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<BigInt> {
        return new BigInt64ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<BigInt> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigInt64Array with replaced value on index
     */
    public with(index: number, value: BigInt): BigInt64Array {
        return this.with(index as int, value.getLong())
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigInt64Array with replaced value on index
     */
    public with(index: int, value: long): BigInt64Array {
        let res = new BigInt64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: BigInt) => boolean): boolean {
        return this.every((element: BigInt, index: number, array: BigInt64Array): boolean => predicate(element))
    }

    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt) => boolean): BigInt64Array {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns BigInt | undefined
     */
    public find(predicate: () => boolean): BigInt | undefined {
        return this.find((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns BigInt | undefined
     */
    public find(predicate: (value: BigInt) => boolean): BigInt | undefined {
        return this.find((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: BigInt) => boolean): number {
        return this.findIndex((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt) => boolean): BigInt {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(val) }
        return new BigInt(this.findLast(newF))
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt) => boolean): number {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in BigInt64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: BigInt) => void): void {
        this.forEach((value: BigInt, index: number, array: BigInt64Array): void => callbackfn(value))
    }

    /**
     * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array
     *
     * @param fn a function to apply for each element of current BigInt64Array
     *
     * @returns a new BigInt64Array where for each element from current BigInt64Array fn was applied
     */
    public map(fn: (val: BigInt) => BigInt): BigInt64Array {
        let newF: (val: BigInt, index: number) => BigInt =
            (val: BigInt, index: number): BigInt => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: BigInt) => boolean): boolean {
        return this.some((element: BigInt, index: number, array: BigInt64Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted BigInt64Array
     */
    public sort(compareFn?: (a: BigInt, b: BigInt) => number): this {
        let arr: long[] = new long[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: long, r: long): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: long, r: long): number => {
                return compareFn!(new BigInt(l), new BigInt(r))
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted BigInt64Array
     */
    public sort(compareFn: (a: BigInt) => number): this {
        let cmp = (a: BigInt, b: BigInt) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted BigInt64Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: BigInt, b: BigInt) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: BigInt, index: number, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(new BigInt(this.getUnsafe(i)), i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: BigInt, index: number) => boolean): boolean {
        return this.some((element: BigInt, index: number, array: BigInt64Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: BigInt, index: number, array: BigInt64Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: number, array: BigInt64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = BigInt>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: number, array: BigInt64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = new BigInt(this.getUnsafe(0))
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: number) => BigInt): BigInt {
        return this.reduce(
                (prevVal: BigInt, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: BigInt, currentValue: BigInt) => BigInt): BigInt {
        return this.reduce(
                (prevVal: BigInt, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: BigInt) => BigInt): BigInt {
        return this.reduce(
                (prevVal: BigInt, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => BigInt): BigInt {
        return this.reduce(
                (prevVal: BigInt, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: number, array: BigInt64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U, currentValue: BigInt) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = BigInt>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: number, array: BigInt64Array) => BigInt): BigInt {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: BigInt = new BigInt(this.getUnsafe(this.lengthInt - 1))
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, new BigInt(this.getUnsafe(i)), i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: BigInt, currentValue: BigInt, currentIndex: number) => BigInt): BigInt {
        return this.reduceRight(
                (prevValue: BigInt, currValue: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: BigInt, currentValue: BigInt) => BigInt): BigInt {
        return this.reduceRight(
                (prevValue: BigInt, currValue: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: BigInt) => BigInt): BigInt {
        return this.reduceRight(
                (prevValue: BigInt, currValue: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => BigInt): BigInt {
        return this.reduceRight(
                (prevValue: BigInt, currValue: BigInt, currIndex: number, array: BigInt64Array) =>
                        callbackfn())
    }

   /**
    * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array.
    *
    * @param fn a function to apply for each element of current BigInt64Array
    *
    * @returns a new BigInt64Array where for each element from current BigInt64Array fn was applied
    */
    public map(fn: (val: BigInt, index: number) => BigInt): BigInt64Array {
        let resBuf = new ArrayBuffer(this.lengthInt * BigInt64Array.BYTES_PER_ELEMENT as int)
        let res = new BigInt64Array(resBuf, 0, resBuf.getByteLength() / BigInt64Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(new BigInt(this.getUnsafe(i)), i as number).getLong())
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: BigInt, index: number, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(new BigInt(this.getUnsafe(i)), i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: BigInt, index: number) => boolean): boolean {
        return this.every((element: BigInt, index: number, array: BigInt64Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: BigInt, index: number, array: BigInt64Array): boolean => predicate())
    }

    /**
     * Creates a new BigInt64Array from current BigInt64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): BigInt64Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(new BigInt(this.getUnsafe(i)), i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigInt64Array.BYTES_PER_ELEMENT as int)
        let res = new BigInt64Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number) => boolean): BigInt64Array {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: () => boolean): BigInt64Array {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns BigInt | undefined
     */
    public find(predicate: (value: BigInt, index: number, obj: BigInt64Array) => boolean): BigInt | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(new BigInt(val), i as number, this)) {
                return new BigInt(val)
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns BigInt | undefined
     */
    public find(predicate: (value: BigInt, index: number) => boolean): BigInt | undefined {
        return this.find((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: BigInt, index: number, obj: BigInt64Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(new BigInt(this.getUnsafe(i)), i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: BigInt, index: number) => boolean): number {
        return this.findIndex((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: BigInt, index: number, obj: BigInt64Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): long {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(new BigInt(val), i as number, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number) => boolean): long {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(new BigInt(val), i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number) => boolean): number {
        let newF: (val: BigInt, index: number, array: BigInt64Array) => boolean =
            (val: BigInt, index: number, array: BigInt64Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in BigInt64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: BigInt, index: number, array: BigInt64Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(new BigInt(this.getUnsafe(i)), i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in BigInt64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: BigInt, index: number) => void): void {
        this.forEach((value: BigInt, index: number, array: BigInt64Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in BigInt64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: BigInt, index: number, array: BigInt64Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns BigInt64Array
     */
    public valueOf(): BigInt64Array {
        return this
    }

    internal getUnsafe(index: int): long {
        let byteIndex = index * BigInt64Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : long = 0
        let byteVal : long
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 7 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 7 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return res
        }
    }

    internal setUnsafe(insertPos: int, val: long): void {
        let startByte = insertPos * BigInt64Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = val
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 7 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 7 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"BigInt64Array\" */
    public readonly name = "BigInt64Array"
}

class Float32ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class Float32ArrayIterator implements IterableIterator<Number> {
    private parent: Float32Array
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Float32ArrayIteratorEntries implements IterableIterator<[Number, Number]> {
    private parent: Float32Array
    private idx: int = 0

    constructor(parent: Float32Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, Number]> {
        return this
    }

    override next(): IteratorResult<[Number, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, Number]>()
        }
        return new IteratorResult<[Number, Number]>(
            false, [new Number(this.idx), new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * JS Float32Array API-compatible class
 */
export final class Float32Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: number = 4
    internal readonly lengthInt: int

    /**
     * Creates an empty Float32Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an Float32Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        let x = Float32Array.from(elements)
        this.byteLength = x.byteLength
        this.lengthInt = x.lengthInt
        this.buffer = x.buffer
        this.byteOffset = x.byteOffset
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteLength % Float32Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % Float32Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / Float32Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Float32Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Float32Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * Float32Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Float32Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Float32Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % Float32Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Float32Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * Float32Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).floatValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * Float32Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Float32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Float32Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an Float32Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i] as float)
        }
    }

    /**
     * Creates an Float32Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i] as float)
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: number): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        this.setUnsafe(index, val as float)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        this.setUnsafe(index, val as float)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: float): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: float): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        this.setUnsafe(index, val)
    }

    /** Number of float stored in Float32Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): Number {
        return this.$_get(index as int) as Number
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): number {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return this.getUnsafe(index) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): Number | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): Float32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): Float32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): Float32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): Float32Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): Float32Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float32Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): Float32Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float32Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Float32Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the Float32Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, Number]> {
        return new Float32ArrayIteratorEntries(this)
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start?: number, end?: number): this {
        this.fill(value as float, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: int, end?: number): this {
        this.fill(value as float, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: int, end: number): this {
        this.fill(value as float, start as int, end as int)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: number, end: int): this {
        this.fill(value as float, start as int, end as int)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: int, end: int): this {
        this.fill(value as float, start as int, end as int)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start?: number, end?: number): this {
        this.fill(value, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: int, end?: number): this {
        this.fill(value, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: int, end: number): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: number, end: int): this {
        this.fill(value, start as int, end as int)
        return this
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(float[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(float[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: float): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            this.setUnsafe(offset + i, arr[i] as float)
        }
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: float[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0 as number)
    }

    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: float[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the Float32Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            this.setUnsafe(insertPos + i, array[i] as float)
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float32Array
     */
    public static of(...items: number[]): Float32Array {
        let res = new Float32Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i] as float)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float32Array
     */
    public static of(...items: int[]): Float32Array {
        let res = new Float32Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i] as float)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float32Array
     */
    public static of(...items: float[]): Float32Array {
        let res = new Float32Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i])
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float32Array
     */
    public static of(): Float32Array {
        return new Float32Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Float32Array
     */
    public static from(arrayLike: ArrayLike<number>): Float32Array {
        return Float32Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Float32Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Float32Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE: This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Float32Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Float32Array(result.buffer, 0, i)
                }
                result.setUnsafe(i, (mapfn)!(x.value!, i) as float)
            }
            return result
        }

        // NOTE: Create builtin array as buffer
        let temp = new Float32Array(6)
        let index = new int[1]
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE: Progressive reallocation
                const curLength = (temp.buffer as Buffer).getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, (temp.buffer as Buffer).at(i))
                }
                temp = new Float32Array(tb)
            }
            temp.setUnsafe(index[0], (mapfn)!(x, index[0]) as float)
            index[0]++
        })
        return new Float32Array(temp.buffer, 0, index[0])
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Float32Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): Float32Array {
        let res = new Float32Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            res.setUnsafe(idx[0] as int, mapfn(x as T, idx[0] as number) as float)
            idx[0] += 1
        })
        return res
    }

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Float32Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: number): boolean {
        if (isNaN(searchElement)) {
            let fromIndexInt: int = normalizeIndex(asIntOrDefault(fromIndex, 0), this.lengthInt)
            for (let i = fromIndexInt; i < this.lengthInt; i++) {
                if (isNaN(this.getUnsafe(i))) {
                    return true
                }
            }
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if e is in Float32Array, false otherwise
     */
    public includes(searchElement: float, fromIndex: int): boolean {
        return this.indexOf(searchElement as int, fromIndex) != -1
    }

    /**
     * Determines whether Float32Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Float32Array, false otherwise
     */
    public includes(searchElement: float): boolean {
        return this.includes(searchElement, 0)
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) as number == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement as float) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(this.getUnsafe(i) as number)
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(this.getUnsafe(this.lengthInt - 1) as number)
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in Float32Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new Float32ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) as number == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement as float) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Float32Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new Float32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Float32Array from data
    */
    public of(data: Object[]): Float32Array {
        throw new Error("Float32Array.of: not implemented")
    }

    /**
     * Creates a new Float32Array using reversed data from the current one
     *
     * @returns a new Float32Array using reversed data from the current one
     */
    public reverse(): Float32Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): Float32Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Float32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): Float32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): Float32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Float32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * Float32Array.BYTES_PER_ELEMENT as int, relEnd * Float32Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new Float32Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * Float32Array.BYTES_PER_ELEMENT as int, relEnd * Float32Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new Float32Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current Float32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin, this.length)
     */
    public slice(begin: number): Float32Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin, this.length)
     */
    public slice(begin: int): Float32Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): Float32Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): Float32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): Float32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): Float32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): Float32Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Float32Array(this.buffer, relStart * Float32Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a Float32Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Float32Array with the same ArrayBufferLike
     */
    public subarray(begin: number): Float32Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a Float32Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Float32Array with the same ArrayBufferLike
     */
    public subarray(begin: int): Float32Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Float32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i) as Number).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1) as Number).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Float32Array {
        return new Float32Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Float32Array {
        return new Float32Array(this).sort()
    }

    /**
     * Returns a string representation of the Float32Array
     *
     * @returns a string representation of the Float32Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
        return new Float32ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float32Array with replaced value on index
     */
    public with(index: number, value: number): Float32Array {
        return this.with(index as int, value as float)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float32Array with replaced value on index
     */
    public with(index: int, value: float): Float32Array {
        let res = new Float32Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Float32Array): boolean => predicate(element))
    }

    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Float32Array {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: () => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float32Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float32Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float32Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Float32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number) => void): void {
        this.forEach((value: number, index: number, array: Float32Array): void => callbackfn(value))
    }

    /**
     * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array
     *
     * @param fn a function to apply for each element of current Float32Array
     *
     * @returns a new Float32Array where for each element from current Float32Array fn was applied
     */
    public map(fn: (val: number) => number): Float32Array {
        let newF: (val: number, index: number) => number =
            (val: number, index: number): number => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Float32Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted Float32Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        let arr: float[] = new float[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: float, r: float): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: float, r: float): number => {
                return compareFn!(l as number, r as number)
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Float32Array
     */
    public sort(compareFn: (a: number) => number): this {
        let cmp = (a: number, b: number) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Float32Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: number, b: number) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Float32Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: number, index: number, array: Float32Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.getUnsafe(0) as number
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float32Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.getUnsafe(this.lengthInt - 1) as number
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float32Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float32Array) =>
                        callbackfn())
    }

   /**
    * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array.
    *
    * @param fn a function to apply for each element of current Float32Array
    *
    * @returns a new Float32Array where for each element from current Float32Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Float32Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Float32Array.BYTES_PER_ELEMENT as int)
        let res = new Float32Array(resBuf, 0, resBuf.getByteLength() / Float32Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(this.getUnsafe(i) as number, i as number) as float)
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(this.getUnsafe(i) as number, i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Float32Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: number, index: number, array: Float32Array): boolean => predicate())
    }

    /**
     * Creates a new Float32Array from current Float32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Float32Array) => boolean): Float32Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(this.getUnsafe(i) as number, i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float32Array.BYTES_PER_ELEMENT as int)
        let res = new Float32Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Float32Array {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: () => boolean): Float32Array {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number, obj: Float32Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(val as number, i as number, this)) {
                return val as number
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float32Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float32Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float32Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Float32Array) => boolean): float {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return val
            }
        }
        throw new Error("Float32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): float {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val as number, index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Float32Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: number, array: Float32Array) => boolean =
            (val: number, index: number, array: Float32Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Float32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number, array: Float32Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(this.getUnsafe(i) as number, i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in Float32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number) => void): void {
        this.forEach((value: number, index: number, array: Float32Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in Float32Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: number, index: number, array: Float32Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns Float32Array
     */
    public valueOf(): Float32Array {
        return this
    }

    internal getUnsafe(index: int): float {
        let byteIndex = index * Float32Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : int = 0
        let byteVal : int
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return Float.bitCastFromInt(res)
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 3 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 3 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as int
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return Float.bitCastFromInt(res)
        }
    }

    internal setUnsafe(insertPos: int, val: float): void {
        let startByte = insertPos * Float32Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = Float.bitCastToInt(val)
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 3 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 3 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"Float32Array\" */
    public readonly name = "Float32Array"
}

class Float64ArrayIteratorKeys implements IterableIterator<number> {
    private length: int
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.length = parent.length as int
    }

    public override $_iterator(): IterableIterator<number> {
        return this
    }

    override next(): IteratorResult<number> {
        if (this.idx < 0 || this.idx >= this.length) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(false, this.idx++ as number)
    }
}

class Float64ArrayIterator implements IterableIterator<Number> {
    private parent: Float64Array
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<Number> {
        return this
    }

    override next(): IteratorResult<Number> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<Number>()
        }
        return new IteratorResult<Number>(false, new Number(this.parent[this.idx++]))
    }
}

class Float64ArrayIteratorEntries implements IterableIterator<[Number, Number]> {
    private parent: Float64Array
    private idx: int = 0

    constructor(parent: Float64Array) {
        this.parent = parent
    }

    public override $_iterator(): IterableIterator<[Number, Number]> {
        return this
    }

    override next(): IteratorResult<[Number, Number]> {
        if (this.idx < 0 || this.idx >= this.parent.length as int) {
            return new IteratorResult<[Number, Number]>()
        }
        return new IteratorResult<[Number, Number]>(
            false, [new Number(this.idx), new Number(this.parent[this.idx++])]
        )
    }
}


/**
 * JS Float64Array API-compatible class
 */
export final class Float64Array implements Iterable<Number>, ArrayLike<Number> {
    public static readonly BYTES_PER_ELEMENT: number = 8
    internal readonly lengthInt: int

    /**
     * Creates an empty Float64Array.
     */
    public constructor() {
        this(0 as int)
    }

    /**
     * Creates an Float64Array with respect to data accessed via Iterable<Number> interface
     */
    public constructor(elements: Iterable<Number>) {
        let x = Float64Array.from(elements)
        this.byteLength = x.byteLength
        this.lengthInt = x.lengthInt
        this.buffer = x.buffer
        this.byteOffset = x.byteOffset
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined, length: Number | undefined) {
        let intByteOffset: int = 0
        if (byteOffset != undefined) {
            intByteOffset = byteOffset.intValue()
            if (intByteOffset < 0) {
                throw new RangeError("Range Error: byteOffset " + intByteOffset + " is outside the bounds of the buffer")
            }
        }
        let intByteLength: int
        if (buf instanceof ArrayBuffer) {
            intByteLength = (buf as ArrayBuffer).getByteLength()
        } else if (buf instanceof SharedArrayBuffer) {
            intByteLength = (buf as SharedArrayBuffer).getByteLength()
        } else {
            throw new Error("unexpected type of ArrayBufferLike")
        }
        intByteLength = intByteLength - intByteOffset
        if (intByteLength < 0) {
            throw new RangeError("Range Error: byteLength " + intByteLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
        }

        if (intByteLength % Float64Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
        }
        if (intByteOffset % Float64Array.BYTES_PER_ELEMENT as int != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
        }

        let intLength: int
        if (length != undefined) {
            intLength = length.intValue()
            if (intLength > intByteLength / Float64Array.BYTES_PER_ELEMENT as int) {
                throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer with byteOffset " + intByteOffset)
            }
        } else {
            intLength = intByteLength / Float64Array.BYTES_PER_ELEMENT as int
        }
        if (intLength < 0) {
            throw new RangeError("Range Error: length " + intLength + " is outside the bounds of the buffer")
        }
        if (intLength < intByteLength / Float64Array.BYTES_PER_ELEMENT as int) {
            intByteLength = intLength * Float64Array.BYTES_PER_ELEMENT as int
        }
        this.byteLength = intByteLength
        this.byteOffset = intByteOffset
        this.lengthInt = intLength
        this.buffer = buf
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: Number | undefined) {
        this(buf, byteOffset, undefined)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number, length: number) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: number) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int, length: int) {
        this(buf, new Number(byteOffset), new Number(length))
    }

    /**
     * Creates an Float64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBufferLike, byteOffset: int) {
        this(buf, new Number(byteOffset), undefined)
    }

    /**
     * Creates an Float64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayLike<Number> | ArrayBufferLike) {
        if (buf instanceof ArrayBuffer) {
            this.byteLength = (buf as ArrayBuffer).getByteLength()
            if (this.byteLength % Float64Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Float64Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as ArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof SharedArrayBuffer) {
            this.byteLength = (buf as SharedArrayBuffer).getByteLength()
            if (this.byteLength % Float64Array.BYTES_PER_ELEMENT as int != 0) {
               throw new RangeError("ArrayBufferLike.byteLength should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
            }
            this.lengthInt = this.byteLength / Float64Array.BYTES_PER_ELEMENT as int
            this.buffer = buf as SharedArrayBuffer
            this.byteOffset = 0
        } else if (buf instanceof ArrayLike) {
            // NOTE (ikorobkov): dealing with this overload is tricky
            // with banned `instanceof` generic, so it is delegated to array here. Initial idea from Set.sts
            let arr = Array.from<Number>((buf as ArrayLike<Number>))
            this.byteLength = arr.length as int * Float64Array.BYTES_PER_ELEMENT as int
            this.lengthInt = arr.length as int
            this.buffer = new ArrayBuffer(this.byteLength as int)
            this.byteOffset = 0
            for (let i: int = 0; i < this.lengthInt; ++i) {
                this.setUnsafe(i, arr.$_get(i).doubleValue())
            }
        } else {
            throw new Error("unexpected type of buf")
        }
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        if (length < 0) {
            throw new RangeError("Range Error: length " + length + " is outside the bounds of the buffer")
        }
        this.lengthInt = length
        this.byteLength = length * Float64Array.BYTES_PER_ELEMENT as int
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength as int)
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Float64Array.
     *
     * @param other data initializer
     */
    public constructor(other: Float64Array) {
        if (other.buffer instanceof ArrayBuffer) {
            this.buffer = (other.buffer as ArrayBuffer).slice(0 as int, other.byteLength as int) as ArrayBuffer
        } else if (other.buffer instanceof SharedArrayBuffer) {
            this.buffer = (other.buffer as SharedArrayBuffer).slice(0 as int, other.byteLength as int) as SharedArrayBuffer
        } else {
            throw new Error("unexpected type of buffer")
        }
        this.byteLength = other.byteLength
        this.lengthInt = other.length as int
        this.byteOffset = 0
    }

    /**
     * Creates an Float64Array from number[]
     */
    public constructor(numbers: number[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i] as double)
        }
    }

    /**
     * Creates an Float64Array from int[]
     */
    public constructor(numbers: int[]) {
        this(numbers.length)
        for (let i: int = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, numbers[i] as double)
        }
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: number): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: number): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        this.setUnsafe(index, val as double)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: number, val: int): void {
        this.$_set(index as int, val)
    }

    /**
     * Assigns val as element on index.
     *
     * @param val value to set
     *
     * @param index index to change
     */
    public $_set(index: int, val: int): void {
        // NOTE (ikorobkov): TS doesn't throw exception. Exception was added to avoid memory's out-of-range access
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        this.setUnsafe(index, val as double)
    }

    /** Number of double stored in Float64Array */
    public get length(): number {
        return this.lengthInt
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public override $_get(index: number): Number {
        return this.$_get(index as int) as Number
    }

    /**
     * Returns an instance of number at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public $_get(index: int): number {
        if (index < 0 || index >= this.lengthInt) {
            throw new RangeError("invalid index")
        }
        return this.getUnsafe(index) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): Number | undefined {
        return this.at(index as int)
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): Number | undefined {
        let k: int
        if (index >= 0) {
            k = index
        } else {
            k = this.lengthInt + index
        }
        if (k < 0 || k >= this.lengthInt) {
            return undefined
        }
        return new Number(this.getUnsafe(k))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: number, end?: number): Float64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: number, end?: number): Float64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: number, start: int, end?: number): Float64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end?: number): Float64Array {
        return this.copyWithin(target as int, start as int, asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Makes a copy of internal elements to targetPos from startPos to endPos.
     *
     * @param target insert index to place copied elements
     *
     * @param start start index to begin copy from
     *
     * @param end last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(target: int, start: int, end: int): Float64Array {
        let toPos = normalizeIndex(target, this.lengthInt)
        let fromPos = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        let count: int = finalPos - fromPos
        if (count > (this.lengthInt - toPos)) {
            count = this.lengthInt - toPos
        }
        let direction: int = 1
        if ((fromPos < toPos) && (toPos < fromPos + count)) {
            fromPos = fromPos + count - 1
            toPos   = toPos   + count - 1
            direction = -1
        }
        while (count > 0) {
            const value = this.getUnsafe(fromPos)
            this.setUnsafe(toPos, value)
            fromPos = fromPos + direction
            toPos = toPos + direction
            --count
        }
        return this
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float64Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: number): Float64Array {
        return this.copyWithin(target as int)
    }

    /**
     * Makes a copy of internal elements to targetPos from begin to end of Float64Array.
     *
     * @param target insert index to place copied elements
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(target: int): Float64Array {
        return this.copyWithin(target, 0, this.lengthInt)
    }

    /**
     * Returns an array of key, value pairs for every entry in the Float64Array
     *
     * @returns key, value pairs for every entry in the array
     */
    public entries(): IterableIterator<[Number, Number]> {
        return new Float64ArrayIteratorEntries(this)
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start?: number, end?: number): this {
        this.fill(value as double, asIntOrDefault(start, 0 as int), asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: int, end?: number): this {
        this.fill(value as double, start as int, asIntOrDefault(end, this.lengthInt))
        return this
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: int, end: number): this {
        this.fill(value as double, start as int, end as int)
        return this
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: number, end: int): this {
        this.fill(value as double, start as int, end as int)
        return this
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: int, end: int): this {
        const k = normalizeIndex(start, this.lengthInt)
        const finalPos = normalizeIndex(end, this.lengthInt)
        for (let i: int = k; i < finalPos; ++i) {
            this.setUnsafe(i, value)
        }
        return this
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(double[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.$_set(insertPos, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(double[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: double): void {
        this.$_set(insertPos, val)
    }

    /**
     * Copies all elements of arr to the current Float64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos: number): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            this.setUnsafe(offset + i, arr[i] as double)
        }
    }

    /**
     * Copies all elements of arr to the current Float64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: double[], insertPos: int): void {
        const offset = insertPos as int
        if (offset < 0 || offset + arr.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < arr.length as int; ++i) {
            this.setUnsafe(offset + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Float64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: double[]): void {
        this.set(arr, 0 as int)
    }

    /**
     * Copies elements from an ArrayLike object to the Float64Array.
     *
     * @param array An ArrayLike object containing the elements to copy.
     *
     * @param offset Optional. The offset into the target array at which to begin writing values from the source array
     */
    public set(array: ArrayLike<number>, offset: number = 0): void {
        const insertPos = offset as int
        if (insertPos < 0 || insertPos + array.length > this.lengthInt) {
            throw new RangeError("offset is out of bounds")
        }
        for (let i = 0; i < array.length as int; ++i) {
            this.setUnsafe(insertPos + i, array[i] as double)
        }
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float64Array
     */
    public static of(...items: number[]): Float64Array {
        let res = new Float64Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i])
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float64Array
     */
    public static of(...items: int[]): Float64Array {
        let res = new Float64Array(items.length as int)
        for (let i: int = 0; i < items.length; i++) {
            res.setUnsafe(i, items[i] as double)
        }
        return res
    }

    /**
     * Returns a new array from a set of elements.
     *
     * @param items a set of elements to include in the new array object.
     *
     * @returns new Float64Array
     */
    public static of(): Float64Array {
        return new Float64Array(0 as int)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @returns new Float64Array
     */
    public static from(arrayLike: ArrayLike<number>): Float64Array {
        return Float64Array.from<number>(arrayLike, (x: number, k: number): number => x)
    }

    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Float64Array
     */
    public static from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number): Float64Array {
        if (mapfn == undefined) {
            mapfn = (v: number, k: number): number => { return v }
        }

        let iter = arrayLike.$_iterator()
        // NOTE: This code section is responsible for optimizing for some types
        //  of iterators that we can learn the length of (e.g. ArrayValuesIterator).
        //  We are trying to use "reflection" to find the "__Iterator_getLength" method and if it exists,
        //  we can make one pass through the iterator without the need for memory reallocation.
        const maybeLength = tryGetIteratorLength(arrayLike)
        if (maybeLength) {
            const result = new Float64Array(maybeLength)
            for (let i = 0; i < maybeLength; ++i) {
                const x = iter.next()
                if (x.done) {
                    return new Float64Array(result.buffer, 0, i)
                }
                result.setUnsafe(i, (mapfn)!(x.value!, i) as double)
            }
            return result
        }

        // NOTE: Create builtin array as buffer
        let temp = new Float64Array(6)
        let index = new int[1]
        index[0] = 0

        iteratorForEach<number>(iter, (x: number): void => {
            if (index[0] + 1 > temp.lengthInt) {
                // NOTE: Progressive reallocation
                const curLength = (temp.buffer as Buffer).getByteLength()
                const tb = new ArrayBuffer(curLength * 2)
                for (let i = 0; i < curLength; ++i) {
                    tb.set(i, (temp.buffer as Buffer).at(i))
                }
                temp = new Float64Array(tb)
            }
            temp.setUnsafe(index[0], (mapfn)!(x, index[0]) as double)
            index[0]++
        })
        return new Float64Array(temp.buffer, 0, index[0])
    }


    /**
     * Creates an array from an array-like or iterable object.
     *
     * @param arrayLike An array-like or iterable object to convert to an array.
     *
     * @param mapfn A mapping function to call on every element of the array.
     *
     * @returns new Float64Array
     */
    public static from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => Number): Float64Array {
        let res = new Float64Array(arrayLike.length)
        // NOTE (ikorobkov): Please don't replace idx as int[1] with int-variable, because of value of single variable doesn't change (idx++) into lambda call by unknown reason
        const idx = new int[1]
        idx[0] = 0
        iteratorForEach<T>(arrayLike.$_iterator(), (x: T): void => {
            res.setUnsafe(idx[0] as int, mapfn(x as T, idx[0] as number) as double)
            idx[0] += 1
        })
        return res
    }

    /**
     * Determines whether Float64Array includes a certain element, returning true or false as appropriate
     *
     * @param searchElement The element to search for
     *
     * @param fromIndex The position in this array at which to begin searching for searchElement
     *
     * @returns true if searchElement is in Float64Array, false otherwise
     */
    public includes(searchElement: number, fromIndex?: number): boolean {
        if (isNaN(searchElement)) {
            let fromIndexInt: int = normalizeIndex(asIntOrDefault(fromIndex, 0), this.lengthInt)
            for (let i = fromIndexInt; i < this.lengthInt; i++) {
                if (isNaN(this.getUnsafe(i))) {
                    return true
                }
            }
            return false
        }
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0)) != -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex?: number): number {
        return this.indexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int, fromIndex: int): number {
        fromIndex = normalizeIndex(fromIndex, this.lengthInt)
        for (let i = fromIndex; i < this.lengthInt; i++) {
            if (this.getUnsafe(i) == searchElement as double) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index of the first occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the
     *  search starts at index 0.
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(searchElement: int): number {
        return this.indexOf(searchElement, 0)
    }

    /**
     * Adds all the elements of an array separated by the specified separator string
     *
     * @param separator A string used to separate one element of an array from the next in the
     * resulting String. If omitted, the array elements are separated with a comma
     *
     * @returns joined representation
     */
    public join(separator?: String): string {
        if (separator == undefined) {
            return this.join(",")
        }
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append(this.getUnsafe(i) as number)
            res.append(separator)
        }
        if (this.lengthInt > 0) {
            res.append(this.getUnsafe(this.lengthInt - 1) as number)
        }
        return res.toString()
    }

    /**
     * Returns an list of keys in Float64Array
     *
     * @returns iterator over keys
     */
    public keys(): IterableIterator<number> {
        return new Float64ArrayIteratorKeys(this)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: number|undefined): number {
        return this.lastIndexOf(searchElement, asIntOrDefault(fromIndex, 0))
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: number, fromIndex: int): number {
        if (isNaN(searchElement)) {
            return -1
        }
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int, fromIndex: int): number {
        if (this.lengthInt == 0) {
            return -1
        }
        let k: int = this.lengthInt + fromIndex
        if (fromIndex >= 0) {
            k = (this.lengthInt - 1 < fromIndex) ? this.lengthInt - 1 : fromIndex
        }
        while (k >= 0) {
            if (this.getUnsafe(k) == searchElement as double) {
                return k
            }
            k--
        }
        return -1
    }

    /**
     * Returns the index of the last occurrence of a value in Float64Array.
     *
     * @param searchElement The value to locate in the array.
     *
     * @param fromIndex The array index at which to begin the search. If fromIndex is undefined, the
     * search starts at index 0. If fromIndex is ommited, the search begins at index length-1
     *
     * @returns right-most index of searchElement. It must be less or equal than fromIndex. -1 if not found
     */
    public lastIndexOf(searchElement: int): number {
        return this.lastIndexOf(searchElement, this.lengthInt - 1)
    }

    /**
    * Creates a new Float64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Float64Array from data
    */
    public of(data: Object[]): Float64Array {
        throw new Error("Float64Array.of: not implemented")
    }

    /**
     * Creates a new Float64Array using reversed data from the current one
     *
     * @returns a new Float64Array using reversed data from the current one
     */
    public reverse(): Float64Array {
        for (let i: int = 0; i < this.lengthInt / 2 as int; i++) {
            const tmp = this.getUnsafe(this.lengthInt - 1 - i)
            this.setUnsafe(this.lengthInt - 1 - i, this.getUnsafe(i))
            this.setUnsafe(i, tmp)
        }
        return this
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin?: number, end?: number): Float64Array {
        return this.slice(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Float64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: int): Float64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: number): Float64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Float64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        if (this.buffer instanceof ArrayBuffer) {
            let buf = (this.buffer as ArrayBuffer).slice(relStart * Float64Array.BYTES_PER_ELEMENT as int, relEnd * Float64Array.BYTES_PER_ELEMENT as int) as ArrayBuffer
            return new Float64Array(buf)
        } else if (this.buffer instanceof SharedArrayBuffer) {
            let buf = (this.buffer as SharedArrayBuffer).slice(relStart * Float64Array.BYTES_PER_ELEMENT as int, relEnd * Float64Array.BYTES_PER_ELEMENT as int) as SharedArrayBuffer
            return new Float64Array(buf)
        } else {
            throw new Error("unexpected type of buffer")
        }
    }

    /**
     * Creates a slice of current Float64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin, this.length)
     */
    public slice(begin: number): Float64Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin, this.length)
     */
    public slice(begin: int): Float64Array {
        return this.slice(begin, this.lengthInt)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin?: number, end?: number): Float64Array {
        return this.subarray(asIntOrDefault(begin, 0 as int), asIntOrDefault(end, this.lengthInt))
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: number): Float64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: number, end: int): Float64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: number): Float64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBufferLike
     */
    public subarray(begin: int, end: int): Float64Array {
        const len: int = this.lengthInt
        const relStart = normalizeIndex(begin, len)
        const relEnd = normalizeIndex(end, len)
        let count = relEnd - relStart
        if (count < 0) {
            count = 0
        }
        return new Float64Array(this.buffer, relStart * Float64Array.BYTES_PER_ELEMENT as int, count)
    }

    /**
     * Creates a Float64Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Float64Array with the same ArrayBufferLike
     */
    public subarray(begin: number): Float64Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Creates a Float64Array with the same ArrayBufferLike
     *
     * @param begin start index, inclusive
     *
     * @returns new Float64Array with the same ArrayBufferLike
     */
    public subarray(begin: int): Float64Array {
        return this.subarray(begin as int, this.lengthInt)
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Float64Array.toLocaleString: not implemented")
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.lengthInt - 1; ++i) {
            res.append((this.getUnsafe(i) as Number).toLocaleString())
            res.append(",")
        }
        if (this.lengthInt > 0) {
            res.append((this.getUnsafe(this.lengthInt - 1) as Number).toLocaleString())
        }
        return res.toString()
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Float64Array {
        return new Float64Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Float64Array {
        return new Float64Array(this).sort()
    }

    /**
     * Returns a string representation of the Float64Array
     *
     * @returns a string representation of the Float64Array
     */
    public override toString(): string {
        return this.join(",")
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): IterableIterator<Number> {
        return new Float64ArrayIterator(this)
    }

    /**
     * Iteratorable interface implementation
     *
     * @returns iterator over all elements
     */
    public override $_iterator(): IterableIterator<Number> {
        return this.values()
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float64Array with replaced value on index
     */
    public with(index: number, value: number): Float64Array {
        return this.with(index as int, value as double)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float64Array with replaced value on index
     */
    public with(index: int, value: double): Float64Array {
        let res = new Float64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts one argument.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Float64Array): boolean => predicate(element))
    }

    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Float64Array {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: () => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float64Array): boolean => predicate())
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float64Array): boolean => predicate(value))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float64Array): boolean => predicate(value)) as number
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Float64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number) => void): void {
        this.forEach((value: number, index: number, array: Float64Array): void => callbackfn(value))
    }

    /**
     * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array
     *
     * @param fn a function to apply for each element of current Float64Array
     *
     * @returns a new Float64Array where for each element from current Float64Array fn was applied
     */
    public map(fn: (val: number) => number): Float64Array {
        let newF: (val: number, index: number) => number =
            (val: number, index: number): number => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts one argument.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Float64Array): boolean => predicate(element))
    }

    // NOTE (kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     * If omitted, the elements are sorted in ascending order.
     *
     * @returns sorted Float64Array
     */
    public sort(compareFn?: (a: number, b: number) => number): this {
        let arr: double[] = new double[this.lengthInt]
        for (let i = 0; i < this.lengthInt; ++i) {
            arr[i] = this.getUnsafe(i)
        }
        let cmp = (l: double, r: double): number => {
                return (l - r) as number
            }
        if (compareFn != undefined) {
            cmp = (l: double, r: double): number => {
                return compareFn!(l as number, r as number)
            }
        }
        sort(arr, cmp)
        for (let i = 0; i < this.lengthInt; ++i) {
            this.setUnsafe(i, arr[i])
        }
        return this
    }

    /**
     * Sorts in-place
     *
     * @param compareFn comparator   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Float64Array
     */
    public sort(compareFn: (a: number) => number): this {
        let cmp = (a: number, b: number) => { return compareFn(a)}
        this.sort(cmp)
        return this
    }

    /**
     * Sorts in-place
     *
     * @param fn compareFn   used to determine the order of the elements.
     * compareFn returns a negative value if first argument is less than second argument,
     * zero if they're equal and a positive value otherwise.
     *
     * @returns sorted Float64Array
     */
    public sort(compareFn: () => number): this {
        let cmp = (a: number, b: number) => { return compareFn()}
        this.sort(cmp)
        return this
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: (element: number, index: number) => boolean): boolean {
        return this.some((element: number, index: number, array: Float64Array): boolean => predicate(element, index as number))
    }

    /**
     * Determines whether the specified callback function returns true for any element of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The some method calls the predicate function for each element in the array
     * until the predicate returns a true or until the end of the array.
     *
     * @returns false unless predicate function returns true for an array element,
     * in which case true is immediately returned.
     */
    public some(predicate: () => boolean): boolean {
        return this.some((element: number, index: number, array: Float64Array): boolean => predicate())
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = 0; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments
     * The reduce method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduce<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduce(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue = this.getUnsafe(0) as number
        for (let i = 1; i < this.lengthInt; ++i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: (previousValue: number) => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal))
    }

    /**
     * Calls the specified callback function for all the elements in an array.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduce method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array first element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduce method on an empty array without an initial value creates a TypeError
     */
    public reduce(callbackfn: () => number): number {
        return this.reduce(
                (prevVal: number, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn())
    }


    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U,
                initialValue: U): U {
        let accumulatedValue = initialValue
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number, currentIndex: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal, currIndex), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U, currentValue: number) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal, currVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: (previousValue: U) => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevVal), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     *
     * @param initialValue The parameter which value is used as the initial value to start the accumulation.
     * The first call to the callbackfn function provides this value as an argument.
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     */
    public reduceRight<U = number>(
                callbackfn: () => U,
                initialValue: U): U {
        return this.reduceRight(
                (prevVal: U, currVal: number, currIndex: number, array: Float64Array) =>
                        callbackfn(), initialValue)
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts four arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number {
        if (this.lengthInt == 0) {
            throw new TypeError("Reduce of empty array with no initial value")
        }

        let accumulatedValue: number = this.getUnsafe(this.lengthInt - 1) as number
        for (let i = this.lengthInt - 2; i >= 0; --i) {
            accumulatedValue = callbackfn(accumulatedValue, this.getUnsafe(i) as number, i as number, this)
        }
        return accumulatedValue
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts three arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevValue, currValue, currIndex))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts two arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number, currentValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevValue, currValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts one argument.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: (previousValue: number) => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float64Array) =>
                        callbackfn(prevValue))
    }

    /**
     * Calls the specified callback function for all the elements in an array, in descending order.
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param callbackfn A function that accepts no arguments.
     * The reduceRight method calls the callbackfn function one time for each element in the array.
     * The first call to the callbackfn function provides array last element value as an argument
     *
     * @returns The value that results from running the callback function to completion over the entire typed array.
     * calling reduceRight method on an empty array without an initial value creates a TypeError
     */
    public reduceRight(callbackfn: () => number): number {
        return this.reduceRight(
                (prevValue: number, currValue: number, currIndex: number, array: Float64Array) =>
                        callbackfn())
    }

   /**
    * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array.
    *
    * @param fn a function to apply for each element of current Float64Array
    *
    * @returns a new Float64Array where for each element from current Float64Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Float64Array {
        let resBuf = new ArrayBuffer(this.lengthInt * Float64Array.BYTES_PER_ELEMENT as int)
        let res = new Float64Array(resBuf, 0, resBuf.getByteLength() / Float64Array.BYTES_PER_ELEMENT as int)
        for (let i = 0; i < this.lengthInt; ++i) {
            res.set(i, fn(this.getUnsafe(i) as number, i as number) as double)
        }
        return res
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts three arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (!predicate(this.getUnsafe(i) as number, i as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts two arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: (element: number, index: number) => boolean): boolean {
        return this.every((element: number, index: number, array: Float64Array): boolean => predicate(element, index))
    }

    /**
     * Determines whether the specified callback function returns true for all elements of an array.
     *
     * @param predicate A function that accepts no arguments.
     * The every method calls the predicate function for each element in the array until the predicate returns a false,
     * or until the end of the array.
     *
     * @returns true unless predicate function returns a false for an array element,
     * in which case false is immediately returned.
     */
    public every(predicate: () => boolean): boolean {
        return this.every((element: number, index: number, array: Float64Array): boolean => predicate())
    }

    /**
     * Creates a new Float64Array from current Float64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Float64Array) => boolean): Float64Array {
        let markers = new boolean[this.lengthInt]
        let resLen = 0
        for (let i = 0; i < this.lengthInt; ++i) {
            markers[i] = fn(this.getUnsafe(i) as number, i as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float64Array.BYTES_PER_ELEMENT as int)
        let res = new Float64Array(resBuf, 0)
        for (let i = 0, j = 0; i < this.lengthInt; ++i) {
            if (markers[i]) {
                res.set(j, this.getUnsafe(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Float64Array {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val, index as number) }
        return this.filter(newF)
    }

    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: () => boolean): Float64Array {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn() }
        return this.filter(newF)
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number, obj: Float64Array) => boolean): number | undefined {
        for (let i = 0; i < this.lengthInt; ++i) {
            let val = this.getUnsafe(i)
            if (predicate(val as number, i as number, this)) {
                return val as number
            }
        }
        return undefined
    }

    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined
     *
     * @returns number | undefined
     */
    public find(predicate: (value: number, index: number) => boolean): number | undefined {
        return this.find((value: number, index: number, obj: Float64Array): boolean => predicate(value, index))
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean): number {
        for (let i = 0; i < this.lengthInt; ++i) {
            if (predicate(this.getUnsafe(i) as number, i as number, this)) {
                return i as number
            }
        }
        return -1 as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: (value: number, index: number) => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float64Array): boolean => predicate(value, index as number)) as number
    }

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise
     *
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1
     *
     * @returns number
     */
    public findIndex(predicate: () => boolean): number {
        return this.findIndex((value: number, index: number, obj: Float64Array): boolean => predicate()) as number
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Float64Array) => boolean): double {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return val
            }
        }
        throw new Error("Float64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): double {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val as number, index as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Float64Array) => boolean): number {
        for (let i = this.lengthInt - 1; i >= 0; --i) {
            let val = this.getUnsafe(i)
            if (fn(val as number, i as number, this)) {
                return i
            }
        }
        return -1 as number
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: number, array: Float64Array) => boolean =
            (val: number, index: number, array: Float64Array): boolean => { return fn(val, index as number) }
        return this.findLastIndex(newF) as number
    }

    /**
     * Performs the specified action for each element in Float64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number, array: Float64Array) => void): void {
        for (let i = 0; i < this.lengthInt; ++i) {
            callbackfn(this.getUnsafe(i) as number, i as number, this)
        }
    }

    /**
     * Performs the specified action for each element in Float64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: (value: number, index: number) => void): void {
        this.forEach((value: number, index: number, array: Float64Array): void => callbackfn(value, index))
    }

    /**
     * Performs the specified action for each element in Float64Array
     *
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the
     * callbackfn function one time for each element in the array.
     *
     * @returns None
     */
    public forEach(callbackfn: () => void): void {
        this.forEach((value: number, index: number, array: Float64Array): void => callbackfn())
    }

    /**
     * Returns the object itself
     *
     * @returns Float64Array
     */
    public valueOf(): Float64Array {
        return this
    }

    internal getUnsafe(index: int): double {
        let byteIndex = index * Float64Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let res : long = 0
        let byteVal : long
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return Double.bitCastFromLong(res)
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i: int = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as ArrayBuffer).at(byteIndex as int + 7 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i: int = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    byteVal = (this.buffer as SharedArrayBuffer).at(byteIndex as int + 7 - i)
                    byteVal &= 0xff
                    res = (res | byteVal << (8 * i)) as long
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
            return Double.bitCastFromLong(res)
        }
    }

    internal setUnsafe(insertPos: int, val: double): void {
        let startByte = insertPos * Float64Array.BYTES_PER_ELEMENT as int + this.byteOffset as int
        let bits = Double.bitCastToLong(val)
        if (IS_LITTLE_ENDIAN) {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT as int; ++i) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        } else {
            if (this.buffer instanceof ArrayBuffer) {
                for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as ArrayBuffer).set(startByte + 7 - i, byteVal)
                }
            } else if (this.buffer instanceof SharedArrayBuffer) {
                for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT as int; i++) {
                    let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
                    (this.buffer as SharedArrayBuffer).set(startByte + 7 - i, byteVal)
                }
            } else {
                throw new Error("unexpected type of ArrayBufferLike")
            }
        }
    }

    /** Underlying ArrayBufferLike */
    public readonly buffer: ArrayBufferLike

    /** Byte offset within the underlying ArrayBufferLike */
    public readonly byteOffset: number

    /** Number of bytes used */
    public readonly byteLength: number

    /** String \"Float64Array\" */
    public readonly name = "Float64Array"
}
