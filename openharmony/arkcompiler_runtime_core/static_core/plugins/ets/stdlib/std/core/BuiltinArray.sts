/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file

function asIntOrDefault(n: Number | undefined, def: int): int {
    if (__runtimeIsSameReference(n, undefined)) {
        return def
    }
    return (n! as Object as Number) as number as int;
}

function normalizeIndex(idx: int, len: int): int {
    if (idx < -len) {
        return 0
    }
    if (idx < 0) {
        return len + idx
    }
    if (idx > len) {
        return len
    }
    return idx
}

// Range is [startIndex, endIndex), i.e. startIndex included and endIndex is excluded
function checkRange(arrLen: int, startIndex: int, endIndex: int): boolean {
    // Since mostly everywhere for loop is used from startIndex till endIndex exclusive,
    // startIndex <= endIndex is used to cover empty array case
    return ((0 <= startIndex) && (startIndex <= endIndex) && (endIndex <= arrLen));
}

native function __alloc_array<T>(len: int, ofType: Object | null): T[]

class BuiltinArrayKeysIterator implements IterableIterator<number> {
    private len: int
    private idx: int = 0

    constructor(len: int) {
        this.len = len
    }

    override next(): IteratorResult<number> {
        if (this.idx >= this.len) {
            return new IteratorResult<number>()
        }
        return new IteratorResult<number>(this.idx++ as number)
    }

    override $_iterator(): IterableIterator<number> {
        return this
    }
}

function cloneArray(self: boolean[]): boolean[] {
    const ret = new boolean[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: boolean[], index: number): Boolean | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: boolean[], ...items: (boolean | Concatboolean[])[]): boolean[] {
//     throw new Error("not implemented")
// }

export function concat(self: boolean[], ...items: ConcatArray<boolean>[]): boolean[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new boolean[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: boolean[], index: int): Boolean | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: number, start: number, end?: Number): boolean[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int, start: int, end: int): boolean[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int, start: int): boolean[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: boolean[], target: int): boolean[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: boolean[], value: boolean, start?: Number, end?: Number): boolean[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: boolean[], value: boolean, start: int, end: int): boolean[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: boolean[], predicate: (value: boolean, index: number, array: boolean[]) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], predicate: (value: boolean, index: number, array: boolean[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], predicate: (elem: boolean, index: number, array: boolean[]) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], predicate: (value: boolean, index: number, array: boolean[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], predicate: (value: boolean, index: number, array: boolean[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: boolean[], predicate: (value: boolean, index: number, array: boolean[]) => boolean): boolean[] {
    return filter(self, (value: boolean, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: boolean[], predicate: (element: boolean, index: number, array: boolean[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean, index: number, array: boolean[]) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = boolean>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean, index: number, array: boolean[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean, index: number, array: boolean[]) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean, index: number, array: boolean[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: boolean[], callbackfn: (value: boolean, index: number, array: boolean[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: boolean[], predicate: (value: boolean, index: number) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], predicate: (value: boolean, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], predicate: (elem: boolean, index: number) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], predicate: (value: boolean, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], predicate: (value: boolean, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: boolean[], predicate: (element: boolean, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean, index: number) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = boolean>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean, index: number) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: boolean[], callbackfn: (value: boolean, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: boolean[], predicate: (value: boolean) => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], predicate: (value: boolean) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], predicate: (elem: boolean) => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], predicate: (value: boolean) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], predicate: (value: boolean) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: boolean[], predicate: (value: boolean) => boolean): boolean[] {
    return filter(self, (value: boolean, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: boolean[], predicate: (element: boolean) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = boolean>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: boolean[], callbackfn: (previousValue: boolean, currentValue: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: boolean[], callbackfn: (previousValue: U, currentValue: boolean) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: boolean[], callbackfn: (value: boolean) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start?: Number, end?: Number): boolean[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start: int, end: int): boolean[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new boolean[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: boolean[], start: int): boolean[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: boolean[], element: boolean, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: boolean[], element: boolean, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: boolean[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: boolean[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: boolean[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start?: Number, delete?: Number): boolean[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: number, delete: number, ...items: boolean[]): boolean[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: int, delete: int, ...items: boolean[]): boolean[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new boolean[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: boolean[], start: int): boolean[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: boolean[], val: boolean, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: boolean[], val: boolean, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: boolean[], val: boolean, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: boolean[], ): boolean[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: boolean[], comparator: (a: boolean, b: boolean) => number): boolean[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: boolean[], ): boolean[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: boolean[], ): boolean[] {
    let arr = new boolean[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: boolean[], index: number, value: boolean): boolean[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: boolean[], index: int, value: boolean): boolean[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: boolean[], ): IterableIterator<boolean> {
    return new ArrayValuesIterator_boolean(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: boolean[], ): IterableIterator<[number, boolean]> {
    return new ArrayEntriesIterator_boolean(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: boolean[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: boolean[], predicate: () => boolean): boolean[] {
    return filter(self, (value: boolean, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: boolean[], predicate: () => boolean): Boolean | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: boolean[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: boolean[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: boolean[], callbackfn: (previousValue: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: boolean[], callbackfn: () => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = boolean>(self: boolean[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = boolean>(self: boolean[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: boolean[], callbackfn: (previousValue: boolean) => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: boolean[], callbackfn: () => boolean): boolean {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: boolean = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: boolean[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: boolean[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: boolean[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: boolean[], predicate: () => boolean): Boolean | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: boolean[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], callbackfn: (value: boolean, index: number, array: boolean[]) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], callbackfn: (value: boolean, index: number) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], callbackfn: (value: boolean) => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: boolean[], callbackfn: () => boolean): boolean[] {
    const len = self.length;
    let res = new boolean[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: boolean[], fn: (v: boolean, k: number) => boolean): boolean[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new boolean[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: boolean[], fst: boolean[], ...more: boolean[][]): boolean[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new boolean[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: boolean[], comparator: (a: boolean, b: boolean) => number): boolean[] {
    sort_subarray(self, 0, self.length, (l: boolean, r: boolean): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: boolean[], ): boolean[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: boolean[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_boolean implements IterableIterator<boolean> {
    private parent: boolean[]
    private idx: int = 0

    constructor(parent: boolean[]) {
        this.parent = parent
    }

    override next(): IteratorResult<boolean> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<boolean>()
        }
        return new IteratorResult<boolean>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<boolean> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_boolean implements IterableIterator<[number, boolean]> {
    private parent: boolean[]
    private idx: int = 0

    constructor(parent: boolean[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, boolean]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, boolean]>()
        }
        const i = this.idx++;
        const vl: [number, boolean] = [i as number, this.parent[i]]
        return new IteratorResult<[number, boolean]>(vl);
    }

    override $_iterator(): IterableIterator<[number, boolean]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: byte[]): byte[] {
    const ret = new byte[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: byte[], index: number): Byte | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: byte[], ...items: (byte | Concatbyte[])[]): byte[] {
//     throw new Error("not implemented")
// }

export function concat(self: byte[], ...items: ConcatArray<byte>[]): byte[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new byte[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: byte[], index: int): Byte | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: number, start: number, end?: Number): byte[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int, start: int, end: int): byte[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int, start: int): byte[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: byte[], target: int): byte[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: byte[], value: byte, start?: Number, end?: Number): byte[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: byte[], value: byte, start: int, end: int): byte[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: byte[], predicate: (value: byte, index: number, array: byte[]) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], predicate: (value: byte, index: number, array: byte[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], predicate: (elem: byte, index: number, array: byte[]) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], predicate: (value: byte, index: number, array: byte[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], predicate: (value: byte, index: number, array: byte[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: byte[], predicate: (value: byte, index: number, array: byte[]) => boolean): byte[] {
    return filter(self, (value: byte, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: byte[], predicate: (element: byte, index: number, array: byte[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: byte[], callbackfn: (previousValue: byte, currentValue: byte, index: number, array: byte[]) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = byte>(self: byte[], callbackfn: (previousValue: U, currentValue: byte, index: number, array: byte[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: byte[], callbackfn: (previousValue: byte, currentValue: byte, index: number, array: byte[]) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: byte[], callbackfn: (previousValue: U, currentValue: byte, index: number, array: byte[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: byte[], callbackfn: (value: byte, index: number, array: byte[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: byte[], predicate: (value: byte, index: number) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], predicate: (value: byte, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], predicate: (elem: byte, index: number) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], predicate: (value: byte, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], predicate: (value: byte, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: byte[], predicate: (element: byte, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: byte[], callbackfn: (previousValue: byte, currentValue: byte, index: number) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = byte>(self: byte[], callbackfn: (previousValue: U, currentValue: byte, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: byte[], callbackfn: (previousValue: byte, currentValue: byte, index: number) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: byte[], callbackfn: (previousValue: U, currentValue: byte, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: byte[], callbackfn: (value: byte, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: byte[], predicate: (value: byte) => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], predicate: (value: byte) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], predicate: (elem: byte) => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], predicate: (value: byte) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], predicate: (value: byte) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: byte[], predicate: (value: byte) => boolean): byte[] {
    return filter(self, (value: byte, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: byte[], predicate: (element: byte) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: byte[], callbackfn: (previousValue: byte, currentValue: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = byte>(self: byte[], callbackfn: (previousValue: U, currentValue: byte) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: byte[], callbackfn: (previousValue: byte, currentValue: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: byte[], callbackfn: (previousValue: U, currentValue: byte) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: byte[], callbackfn: (value: byte) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start?: Number, end?: Number): byte[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start: int, end: int): byte[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new byte[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: byte[], start: int): byte[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: byte[], element: byte, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: byte[], element: byte, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: byte[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: byte[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: byte[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start?: Number, delete?: Number): byte[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: number, delete: number, ...items: byte[]): byte[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: int, delete: int, ...items: byte[]): byte[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new byte[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: byte[], start: int): byte[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: byte[], val: byte, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: byte[], val: byte, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: byte[], val: byte, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: byte[], ): byte[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: byte[], comparator: (a: byte, b: byte) => number): byte[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: byte[], ): byte[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: byte[], ): byte[] {
    let arr = new byte[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: byte[], index: number, value: byte): byte[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: byte[], index: int, value: byte): byte[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: byte[], ): IterableIterator<byte> {
    return new ArrayValuesIterator_byte(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: byte[], ): IterableIterator<[number, byte]> {
    return new ArrayEntriesIterator_byte(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: byte[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: byte[], predicate: () => boolean): byte[] {
    return filter(self, (value: byte, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: byte[], predicate: () => boolean): Byte | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: byte[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: byte[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: byte[], callbackfn: (previousValue: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: byte[], callbackfn: () => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = byte>(self: byte[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = byte>(self: byte[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: byte[], callbackfn: (previousValue: byte) => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: byte[], callbackfn: () => byte): byte {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: byte = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: byte[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: byte[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: byte[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: byte[], predicate: () => boolean): Byte | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: byte[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], callbackfn: (value: byte, index: number, array: byte[]) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], callbackfn: (value: byte, index: number) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], callbackfn: (value: byte) => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: byte[], callbackfn: () => byte): byte[] {
    const len = self.length;
    let res = new byte[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: byte[], fn: (v: byte, k: number) => boolean): byte[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new byte[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: byte[], fst: byte[], ...more: byte[][]): byte[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new byte[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: byte[], comparator: (a: byte, b: byte) => number): byte[] {
    sort_subarray(self, 0, self.length, (l: byte, r: byte): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: byte[], ): byte[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: byte[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_byte implements IterableIterator<byte> {
    private parent: byte[]
    private idx: int = 0

    constructor(parent: byte[]) {
        this.parent = parent
    }

    override next(): IteratorResult<byte> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<byte>()
        }
        return new IteratorResult<byte>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<byte> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_byte implements IterableIterator<[number, byte]> {
    private parent: byte[]
    private idx: int = 0

    constructor(parent: byte[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, byte]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, byte]>()
        }
        const i = this.idx++;
        const vl: [number, byte] = [i as number, this.parent[i]]
        return new IteratorResult<[number, byte]>(vl);
    }

    override $_iterator(): IterableIterator<[number, byte]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: short[]): short[] {
    const ret = new short[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: short[], index: number): Short | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: short[], ...items: (short | Concatshort[])[]): short[] {
//     throw new Error("not implemented")
// }

export function concat(self: short[], ...items: ConcatArray<short>[]): short[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new short[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: short[], index: int): Short | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: number, start: number, end?: Number): short[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int, start: int, end: int): short[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int, start: int): short[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: short[], target: int): short[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: short[], value: short, start?: Number, end?: Number): short[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: short[], value: short, start: int, end: int): short[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: short[], predicate: (value: short, index: number, array: short[]) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], predicate: (value: short, index: number, array: short[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], predicate: (elem: short, index: number, array: short[]) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], predicate: (value: short, index: number, array: short[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], predicate: (value: short, index: number, array: short[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: short[], predicate: (value: short, index: number, array: short[]) => boolean): short[] {
    return filter(self, (value: short, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: short[], predicate: (element: short, index: number, array: short[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: short[], callbackfn: (previousValue: short, currentValue: short, index: number, array: short[]) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = short>(self: short[], callbackfn: (previousValue: U, currentValue: short, index: number, array: short[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: short[], callbackfn: (previousValue: short, currentValue: short, index: number, array: short[]) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: short[], callbackfn: (previousValue: U, currentValue: short, index: number, array: short[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: short[], callbackfn: (value: short, index: number, array: short[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: short[], predicate: (value: short, index: number) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], predicate: (value: short, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], predicate: (elem: short, index: number) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], predicate: (value: short, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], predicate: (value: short, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: short[], predicate: (element: short, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: short[], callbackfn: (previousValue: short, currentValue: short, index: number) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = short>(self: short[], callbackfn: (previousValue: U, currentValue: short, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: short[], callbackfn: (previousValue: short, currentValue: short, index: number) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: short[], callbackfn: (previousValue: U, currentValue: short, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: short[], callbackfn: (value: short, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: short[], predicate: (value: short) => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], predicate: (value: short) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], predicate: (elem: short) => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], predicate: (value: short) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], predicate: (value: short) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: short[], predicate: (value: short) => boolean): short[] {
    return filter(self, (value: short, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: short[], predicate: (element: short) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: short[], callbackfn: (previousValue: short, currentValue: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = short>(self: short[], callbackfn: (previousValue: U, currentValue: short) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: short[], callbackfn: (previousValue: short, currentValue: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: short[], callbackfn: (previousValue: U, currentValue: short) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: short[], callbackfn: (value: short) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start?: Number, end?: Number): short[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start: int, end: int): short[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new short[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: short[], start: int): short[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: short[], element: short, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: short[], element: short, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: short[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: short[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: short[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start?: Number, delete?: Number): short[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: number, delete: number, ...items: short[]): short[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: int, delete: int, ...items: short[]): short[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new short[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: short[], start: int): short[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: short[], val: short, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: short[], val: short, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: short[], val: short, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: short[], ): short[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: short[], comparator: (a: short, b: short) => number): short[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: short[], ): short[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: short[], ): short[] {
    let arr = new short[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: short[], index: number, value: short): short[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: short[], index: int, value: short): short[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: short[], ): IterableIterator<short> {
    return new ArrayValuesIterator_short(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: short[], ): IterableIterator<[number, short]> {
    return new ArrayEntriesIterator_short(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: short[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: short[], predicate: () => boolean): short[] {
    return filter(self, (value: short, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: short[], predicate: () => boolean): Short | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: short[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: short[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: short[], callbackfn: (previousValue: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: short[], callbackfn: () => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = short>(self: short[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = short>(self: short[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: short[], callbackfn: (previousValue: short) => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: short[], callbackfn: () => short): short {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: short = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: short[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: short[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: short[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: short[], predicate: () => boolean): Short | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: short[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], callbackfn: (value: short, index: number, array: short[]) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], callbackfn: (value: short, index: number) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], callbackfn: (value: short) => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: short[], callbackfn: () => short): short[] {
    const len = self.length;
    let res = new short[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: short[], fn: (v: short, k: number) => boolean): short[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new short[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: short[], fst: short[], ...more: short[][]): short[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new short[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: short[], comparator: (a: short, b: short) => number): short[] {
    sort_subarray(self, 0, self.length, (l: short, r: short): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: short[], ): short[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: short[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_short implements IterableIterator<short> {
    private parent: short[]
    private idx: int = 0

    constructor(parent: short[]) {
        this.parent = parent
    }

    override next(): IteratorResult<short> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<short>()
        }
        return new IteratorResult<short>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<short> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_short implements IterableIterator<[number, short]> {
    private parent: short[]
    private idx: int = 0

    constructor(parent: short[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, short]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, short]>()
        }
        const i = this.idx++;
        const vl: [number, short] = [i as number, this.parent[i]]
        return new IteratorResult<[number, short]>(vl);
    }

    override $_iterator(): IterableIterator<[number, short]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: int[]): int[] {
    const ret = new int[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: int[], index: number): Int | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: int[], ...items: (int | Concatint[])[]): int[] {
//     throw new Error("not implemented")
// }

export function concat(self: int[], ...items: ConcatArray<int>[]): int[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new int[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: int[], index: int): Int | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: number, start: number, end?: Number): int[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int, start: int, end: int): int[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int, start: int): int[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: int[], target: int): int[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: int[], value: int, start?: Number, end?: Number): int[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: int[], value: int, start: int, end: int): int[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: int[], predicate: (value: int, index: number, array: int[]) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], predicate: (value: int, index: number, array: int[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], predicate: (elem: int, index: number, array: int[]) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], predicate: (value: int, index: number, array: int[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], predicate: (value: int, index: number, array: int[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: int[], predicate: (value: int, index: number, array: int[]) => boolean): int[] {
    return filter(self, (value: int, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: int[], predicate: (element: int, index: number, array: int[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: int[], callbackfn: (previousValue: int, currentValue: int, index: number, array: int[]) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = int>(self: int[], callbackfn: (previousValue: U, currentValue: int, index: number, array: int[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: int[], callbackfn: (previousValue: int, currentValue: int, index: number, array: int[]) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: int[], callbackfn: (previousValue: U, currentValue: int, index: number, array: int[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: int[], callbackfn: (value: int, index: number, array: int[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: int[], predicate: (value: int, index: number) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], predicate: (value: int, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], predicate: (elem: int, index: number) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], predicate: (value: int, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], predicate: (value: int, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: int[], predicate: (element: int, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: int[], callbackfn: (previousValue: int, currentValue: int, index: number) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = int>(self: int[], callbackfn: (previousValue: U, currentValue: int, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: int[], callbackfn: (previousValue: int, currentValue: int, index: number) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: int[], callbackfn: (previousValue: U, currentValue: int, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: int[], callbackfn: (value: int, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: int[], predicate: (value: int) => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], predicate: (value: int) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], predicate: (elem: int) => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], predicate: (value: int) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], predicate: (value: int) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: int[], predicate: (value: int) => boolean): int[] {
    return filter(self, (value: int, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: int[], predicate: (element: int) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: int[], callbackfn: (previousValue: int, currentValue: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = int>(self: int[], callbackfn: (previousValue: U, currentValue: int) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: int[], callbackfn: (previousValue: int, currentValue: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: int[], callbackfn: (previousValue: U, currentValue: int) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: int[], callbackfn: (value: int) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start?: Number, end?: Number): int[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start: int, end: int): int[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new int[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: int[], start: int): int[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: int[], element: int, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: int[], element: int, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: int[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: int[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: int[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start?: Number, delete?: Number): int[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: number, delete: number, ...items: int[]): int[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: int, delete: int, ...items: int[]): int[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new int[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: int[], start: int): int[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: int[], val: int, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: int[], val: int, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: int[], val: int, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: int[], ): int[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: int[], comparator: (a: int, b: int) => number): int[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: int[], ): int[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: int[], ): int[] {
    let arr = new int[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: int[], index: number, value: int): int[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: int[], index: int, value: int): int[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: int[], ): IterableIterator<int> {
    return new ArrayValuesIterator_int(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: int[], ): IterableIterator<[number, int]> {
    return new ArrayEntriesIterator_int(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: int[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: int[], predicate: () => boolean): int[] {
    return filter(self, (value: int, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: int[], predicate: () => boolean): Int | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: int[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: int[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: int[], callbackfn: (previousValue: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: int[], callbackfn: () => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = int>(self: int[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = int>(self: int[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: int[], callbackfn: (previousValue: int) => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: int[], callbackfn: () => int): int {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: int = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: int[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: int[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: int[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: int[], predicate: () => boolean): Int | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: int[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], callbackfn: (value: int, index: number, array: int[]) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], callbackfn: (value: int, index: number) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], callbackfn: (value: int) => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: int[], callbackfn: () => int): int[] {
    const len = self.length;
    let res = new int[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: int[], fn: (v: int, k: number) => boolean): int[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new int[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: int[], fst: int[], ...more: int[][]): int[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new int[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: int[], comparator: (a: int, b: int) => number): int[] {
    sort_subarray(self, 0, self.length, (l: int, r: int): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: int[], ): int[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: int[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_int implements IterableIterator<int> {
    private parent: int[]
    private idx: int = 0

    constructor(parent: int[]) {
        this.parent = parent
    }

    override next(): IteratorResult<int> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<int>()
        }
        return new IteratorResult<int>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<int> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_int implements IterableIterator<[number, int]> {
    private parent: int[]
    private idx: int = 0

    constructor(parent: int[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, int]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, int]>()
        }
        const i = this.idx++;
        const vl: [number, int] = [i as number, this.parent[i]]
        return new IteratorResult<[number, int]>(vl);
    }

    override $_iterator(): IterableIterator<[number, int]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: long[]): long[] {
    const ret = new long[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: long[], index: number): Long | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: long[], ...items: (long | Concatlong[])[]): long[] {
//     throw new Error("not implemented")
// }

export function concat(self: long[], ...items: ConcatArray<long>[]): long[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new long[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: long[], index: int): Long | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: number, start: number, end?: Number): long[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int, start: int, end: int): long[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int, start: int): long[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: long[], target: int): long[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: long[], value: long, start?: Number, end?: Number): long[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: long[], value: long, start: int, end: int): long[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: long[], predicate: (value: long, index: number, array: long[]) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], predicate: (value: long, index: number, array: long[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], predicate: (elem: long, index: number, array: long[]) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], predicate: (value: long, index: number, array: long[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], predicate: (value: long, index: number, array: long[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: long[], predicate: (value: long, index: number, array: long[]) => boolean): long[] {
    return filter(self, (value: long, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: long[], predicate: (element: long, index: number, array: long[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: long[], callbackfn: (previousValue: long, currentValue: long, index: number, array: long[]) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = long>(self: long[], callbackfn: (previousValue: U, currentValue: long, index: number, array: long[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: long[], callbackfn: (previousValue: long, currentValue: long, index: number, array: long[]) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: long[], callbackfn: (previousValue: U, currentValue: long, index: number, array: long[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: long[], callbackfn: (value: long, index: number, array: long[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: long[], predicate: (value: long, index: number) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], predicate: (value: long, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], predicate: (elem: long, index: number) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], predicate: (value: long, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], predicate: (value: long, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: long[], predicate: (element: long, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: long[], callbackfn: (previousValue: long, currentValue: long, index: number) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = long>(self: long[], callbackfn: (previousValue: U, currentValue: long, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: long[], callbackfn: (previousValue: long, currentValue: long, index: number) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: long[], callbackfn: (previousValue: U, currentValue: long, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: long[], callbackfn: (value: long, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: long[], predicate: (value: long) => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], predicate: (value: long) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], predicate: (elem: long) => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], predicate: (value: long) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], predicate: (value: long) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: long[], predicate: (value: long) => boolean): long[] {
    return filter(self, (value: long, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: long[], predicate: (element: long) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: long[], callbackfn: (previousValue: long, currentValue: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = long>(self: long[], callbackfn: (previousValue: U, currentValue: long) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: long[], callbackfn: (previousValue: long, currentValue: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: long[], callbackfn: (previousValue: U, currentValue: long) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: long[], callbackfn: (value: long) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start?: Number, end?: Number): long[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start: int, end: int): long[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new long[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: long[], start: int): long[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: long[], element: long, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: long[], element: long, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: long[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: long[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: long[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start?: Number, delete?: Number): long[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: number, delete: number, ...items: long[]): long[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: int, delete: int, ...items: long[]): long[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new long[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: long[], start: int): long[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: long[], val: long, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: long[], val: long, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: long[], val: long, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: long[], ): long[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: long[], comparator: (a: long, b: long) => number): long[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: long[], ): long[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: long[], ): long[] {
    let arr = new long[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: long[], index: number, value: long): long[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: long[], index: int, value: long): long[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: long[], ): IterableIterator<long> {
    return new ArrayValuesIterator_long(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: long[], ): IterableIterator<[number, long]> {
    return new ArrayEntriesIterator_long(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: long[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: long[], predicate: () => boolean): long[] {
    return filter(self, (value: long, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: long[], predicate: () => boolean): Long | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: long[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: long[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: long[], callbackfn: (previousValue: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: long[], callbackfn: () => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = long>(self: long[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = long>(self: long[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: long[], callbackfn: (previousValue: long) => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: long[], callbackfn: () => long): long {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: long = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: long[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: long[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: long[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: long[], predicate: () => boolean): Long | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: long[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], callbackfn: (value: long, index: number, array: long[]) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], callbackfn: (value: long, index: number) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], callbackfn: (value: long) => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: long[], callbackfn: () => long): long[] {
    const len = self.length;
    let res = new long[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: long[], fn: (v: long, k: number) => boolean): long[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new long[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: long[], fst: long[], ...more: long[][]): long[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new long[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: long[], comparator: (a: long, b: long) => number): long[] {
    sort_subarray(self, 0, self.length, (l: long, r: long): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: long[], ): long[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: long[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_long implements IterableIterator<long> {
    private parent: long[]
    private idx: int = 0

    constructor(parent: long[]) {
        this.parent = parent
    }

    override next(): IteratorResult<long> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<long>()
        }
        return new IteratorResult<long>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<long> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_long implements IterableIterator<[number, long]> {
    private parent: long[]
    private idx: int = 0

    constructor(parent: long[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, long]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, long]>()
        }
        const i = this.idx++;
        const vl: [number, long] = [i as number, this.parent[i]]
        return new IteratorResult<[number, long]>(vl);
    }

    override $_iterator(): IterableIterator<[number, long]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: float[]): float[] {
    const ret = new float[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: float[], index: number): Float | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: float[], ...items: (float | Concatfloat[])[]): float[] {
//     throw new Error("not implemented")
// }

export function concat(self: float[], ...items: ConcatArray<float>[]): float[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new float[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: float[], index: int): Float | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: number, start: number, end?: Number): float[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int, start: int, end: int): float[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int, start: int): float[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: float[], target: int): float[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: float[], value: float, start?: Number, end?: Number): float[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: float[], value: float, start: int, end: int): float[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: float[], predicate: (value: float, index: number, array: float[]) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], predicate: (value: float, index: number, array: float[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], predicate: (elem: float, index: number, array: float[]) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], predicate: (value: float, index: number, array: float[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], predicate: (value: float, index: number, array: float[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: float[], predicate: (value: float, index: number, array: float[]) => boolean): float[] {
    return filter(self, (value: float, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: float[], predicate: (element: float, index: number, array: float[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: float[], callbackfn: (previousValue: float, currentValue: float, index: number, array: float[]) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = float>(self: float[], callbackfn: (previousValue: U, currentValue: float, index: number, array: float[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: float[], callbackfn: (previousValue: float, currentValue: float, index: number, array: float[]) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: float[], callbackfn: (previousValue: U, currentValue: float, index: number, array: float[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: float[], callbackfn: (value: float, index: number, array: float[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: float[], predicate: (value: float, index: number) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], predicate: (value: float, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], predicate: (elem: float, index: number) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], predicate: (value: float, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], predicate: (value: float, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: float[], predicate: (element: float, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: float[], callbackfn: (previousValue: float, currentValue: float, index: number) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = float>(self: float[], callbackfn: (previousValue: U, currentValue: float, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: float[], callbackfn: (previousValue: float, currentValue: float, index: number) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: float[], callbackfn: (previousValue: U, currentValue: float, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: float[], callbackfn: (value: float, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: float[], predicate: (value: float) => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], predicate: (value: float) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], predicate: (elem: float) => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], predicate: (value: float) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], predicate: (value: float) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: float[], predicate: (value: float) => boolean): float[] {
    return filter(self, (value: float, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: float[], predicate: (element: float) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: float[], callbackfn: (previousValue: float, currentValue: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = float>(self: float[], callbackfn: (previousValue: U, currentValue: float) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: float[], callbackfn: (previousValue: float, currentValue: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: float[], callbackfn: (previousValue: U, currentValue: float) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: float[], callbackfn: (value: float) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start?: Number, end?: Number): float[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start: int, end: int): float[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new float[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: float[], start: int): float[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: float[], element: float, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: float[], element: float, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: float[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: float[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: float[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start?: Number, delete?: Number): float[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: number, delete: number, ...items: float[]): float[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: int, delete: int, ...items: float[]): float[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new float[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: float[], start: int): float[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: float[], val: float, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    if (isNaN(val)) {
        for (let i = fi; i < len; i++) {
            if (isNaN(self[i])) {
                return true;
            }
        }
        return false;
    }
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: float[], val: float, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: float[], val: float, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: float[], ): float[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: float[], comparator: (a: float, b: float) => number): float[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: float[], ): float[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: float[], ): float[] {
    let arr = new float[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: float[], index: number, value: float): float[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: float[], index: int, value: float): float[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: float[], ): IterableIterator<float> {
    return new ArrayValuesIterator_float(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: float[], ): IterableIterator<[number, float]> {
    return new ArrayEntriesIterator_float(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: float[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: float[], predicate: () => boolean): float[] {
    return filter(self, (value: float, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: float[], predicate: () => boolean): Float | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: float[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: float[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: float[], callbackfn: (previousValue: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: float[], callbackfn: () => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = float>(self: float[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = float>(self: float[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: float[], callbackfn: (previousValue: float) => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: float[], callbackfn: () => float): float {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: float = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: float[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: float[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: float[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: float[], predicate: () => boolean): Float | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: float[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], callbackfn: (value: float, index: number, array: float[]) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], callbackfn: (value: float, index: number) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], callbackfn: (value: float) => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: float[], callbackfn: () => float): float[] {
    const len = self.length;
    let res = new float[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: float[], fn: (v: float, k: number) => boolean): float[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new float[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: float[], fst: float[], ...more: float[][]): float[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new float[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: float[], comparator: (a: float, b: float) => number): float[] {
    sort_subarray(self, 0, self.length, (l: float, r: float): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: float[], ): float[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: float[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_float implements IterableIterator<float> {
    private parent: float[]
    private idx: int = 0

    constructor(parent: float[]) {
        this.parent = parent
    }

    override next(): IteratorResult<float> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<float>()
        }
        return new IteratorResult<float>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<float> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_float implements IterableIterator<[number, float]> {
    private parent: float[]
    private idx: int = 0

    constructor(parent: float[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, float]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, float]>()
        }
        const i = this.idx++;
        const vl: [number, float] = [i as number, this.parent[i]]
        return new IteratorResult<[number, float]>(vl);
    }

    override $_iterator(): IterableIterator<[number, float]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: double[]): double[] {
    const ret = new double[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: double[], index: number): Double | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: double[], ...items: (double | Concatdouble[])[]): double[] {
//     throw new Error("not implemented")
// }

export function concat(self: double[], ...items: ConcatArray<double>[]): double[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new double[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: double[], index: int): Double | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: number, start: number, end?: Number): double[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int, start: int, end: int): double[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int, start: int): double[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: double[], target: int): double[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: double[], value: double, start?: Number, end?: Number): double[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: double[], value: double, start: int, end: int): double[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: double[], predicate: (value: double, index: number, array: double[]) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], predicate: (value: double, index: number, array: double[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], predicate: (elem: double, index: number, array: double[]) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], predicate: (value: double, index: number, array: double[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], predicate: (value: double, index: number, array: double[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: double[], predicate: (value: double, index: number, array: double[]) => boolean): double[] {
    return filter(self, (value: double, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: double[], predicate: (element: double, index: number, array: double[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: double[], callbackfn: (previousValue: double, currentValue: double, index: number, array: double[]) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = double>(self: double[], callbackfn: (previousValue: U, currentValue: double, index: number, array: double[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: double[], callbackfn: (previousValue: double, currentValue: double, index: number, array: double[]) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: double[], callbackfn: (previousValue: U, currentValue: double, index: number, array: double[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: double[], callbackfn: (value: double, index: number, array: double[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: double[], predicate: (value: double, index: number) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], predicate: (value: double, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], predicate: (elem: double, index: number) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], predicate: (value: double, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], predicate: (value: double, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: double[], predicate: (element: double, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: double[], callbackfn: (previousValue: double, currentValue: double, index: number) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = double>(self: double[], callbackfn: (previousValue: U, currentValue: double, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: double[], callbackfn: (previousValue: double, currentValue: double, index: number) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: double[], callbackfn: (previousValue: U, currentValue: double, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: double[], callbackfn: (value: double, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: double[], predicate: (value: double) => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], predicate: (value: double) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], predicate: (elem: double) => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], predicate: (value: double) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], predicate: (value: double) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: double[], predicate: (value: double) => boolean): double[] {
    return filter(self, (value: double, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: double[], predicate: (element: double) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: double[], callbackfn: (previousValue: double, currentValue: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = double>(self: double[], callbackfn: (previousValue: U, currentValue: double) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: double[], callbackfn: (previousValue: double, currentValue: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: double[], callbackfn: (previousValue: U, currentValue: double) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: double[], callbackfn: (value: double) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start?: Number, end?: Number): double[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start: int, end: int): double[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new double[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: double[], start: int): double[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: double[], element: double, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: double[], element: double, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: double[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: double[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: double[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start?: Number, delete?: Number): double[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: number, delete: number, ...items: double[]): double[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: int, delete: int, ...items: double[]): double[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new double[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: double[], start: int): double[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: double[], val: double, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    if (isNaN(val)) {
        for (let i = fi; i < len; i++) {
            if (isNaN(self[i])) {
                return true;
            }
        }
        return false;
    }
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: double[], val: double, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: double[], val: double, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: double[], ): double[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: double[], comparator: (a: double, b: double) => number): double[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: double[], ): double[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: double[], ): double[] {
    let arr = new double[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: double[], index: number, value: double): double[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: double[], index: int, value: double): double[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: double[], ): IterableIterator<double> {
    return new ArrayValuesIterator_double(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: double[], ): IterableIterator<[number, double]> {
    return new ArrayEntriesIterator_double(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: double[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: double[], predicate: () => boolean): double[] {
    return filter(self, (value: double, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: double[], predicate: () => boolean): Double | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: double[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: double[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: double[], callbackfn: (previousValue: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: double[], callbackfn: () => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = double>(self: double[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = double>(self: double[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: double[], callbackfn: (previousValue: double) => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: double[], callbackfn: () => double): double {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: double = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: double[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: double[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: double[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: double[], predicate: () => boolean): Double | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: double[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], callbackfn: (value: double, index: number, array: double[]) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], callbackfn: (value: double, index: number) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], callbackfn: (value: double) => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: double[], callbackfn: () => double): double[] {
    const len = self.length;
    let res = new double[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: double[], fn: (v: double, k: number) => boolean): double[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new double[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: double[], fst: double[], ...more: double[][]): double[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new double[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: double[], comparator: (a: double, b: double) => number): double[] {
    sort_subarray(self, 0, self.length, (l: double, r: double): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: double[], ): double[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: double[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_double implements IterableIterator<double> {
    private parent: double[]
    private idx: int = 0

    constructor(parent: double[]) {
        this.parent = parent
    }

    override next(): IteratorResult<double> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<double>()
        }
        return new IteratorResult<double>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<double> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_double implements IterableIterator<[number, double]> {
    private parent: double[]
    private idx: int = 0

    constructor(parent: double[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, double]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, double]>()
        }
        const i = this.idx++;
        const vl: [number, double] = [i as number, this.parent[i]]
        return new IteratorResult<[number, double]>(vl);
    }

    override $_iterator(): IterableIterator<[number, double]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function cloneArray(self: char[]): char[] {
    const ret = new char[self.length];;
    for (let i = 0; i < self.length; i++) {
        ret[i] = self[i];
    }
    return ret;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: char[], index: number): Char | undefined {
    return at(self, index as int)
}

/**
 * Creates a new `Array` from this `Array` instance and given `Array` instance.
 *
 * @param other to concatenate into a new array.
 *
 * @returns New `Array` instance, constructed from `this` and given `other` instances of `Array` class.
 */
// export function concat(self: char[], ...items: (char | Concatchar[])[]): char[] {
//     throw new Error("not implemented")
// }

export function concat(self: char[], ...items: ConcatArray<char>[]): char[] {
    let totalAdd = self.length;
    for (let i = 0; i < items.length; i++) {
        totalAdd += items[i].length as int
    }

    const buf = new char[totalAdd];

    for (let i = 0; i < self.length; i++) {
        buf[i] = self[i];
    }

    let insertTo = self.length;
    for (let i = 0; i < items.length; i++) {
        const arr = items[i]
        const len = arr.length as int
        for (let j = 0; j < len; j++) {
            buf[insertTo++] = arr.$_get(j)
        }
    }

    return buf;
}

/**
 * Takes an integer value and returns the item at that index,
 * allowing for positive and negative integers. Negative integers count back
 * from the last item in the array.
 *
 * @param index Zero-based index of the array element to be returned.
 * Negative index counts back from the end of the array — if `index` < 0, index + `array.length()` is accessed.
 *
 * @returns The element in the array matching the given index.
 * Returns undefined if `index` < `-length()` or `index` >= `length()`.
 */
export function at(self: char[], index: int): Char | undefined {
    let len = self.length;
    let k: int;
    if (index >= 0) {
        k = index;
    } else {
        k = len + index;
    }

    if (k < 0 || k >= len) {
        return undefined;
    }

    return self[k];
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: number, start: number, end?: Number): char[] {
    copyWithin(self, target as int, start as int, asIntOrDefault(end, self.length));
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @param end index at which to end copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int, start: int, end: int): char[] {
    target = normalizeIndex(target, self.length)
    start = normalizeIndex(start, self.length)
    end = normalizeIndex(end, self.length)

    if (end <= start) {
        return self;
    }

    if (target <= start) {
        while (start < end) {
            const read = self[start++];
            self[target++] = read;
        }
    } else {
        let len = end - start;
        if (target + len > self.length) {
            len = self.length - target
        }
        for (let i = 0; i < len; i++) {
            const read = self[start + len - 1 - i];
            self[target + len - 1 - i] = read;
        }
    }

    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @param start index at which to start copying elements from
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int, start: int): char[] {
    copyWithin(self, target, start, self.length);
    return self;
}

/**
 * Makes a shallow copy of the Array part to another location in the same Array and returns it without modifying its length.
 *
 * @param target index at which to copy the sequence
 *
 * @returns this array after transformation
 */
export function copyWithin(self: char[], target: int): char[] {
    copyWithin(self, target, 0, self.length);
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: char[], value: char, start?: Number, end?: Number): char[] {
    fill(self, value, asIntOrDefault(start, 0), asIntOrDefault(end, self.length));
    return self;
}

/**
 * Changes all elements in the Array to a static value, from a start index to an end index
 *
 * @param value to fill the array with
 *
 * @param start index at which to start filling
 *
 * @param end index at which to end filling, but not including
 *
 * @returns this array after transformation
 */
export function fill(self: char[], value: char, start: int, end: int): char[] {
    start = normalizeIndex(start, self.length);
    end = normalizeIndex(end, self.length)

    for (let i = start; i < end; i++) {
        self[i] = value;
    }

    return self;
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: char[], predicate: (value: char, index: number, array: char[]) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], predicate: (value: char, index: number, array: char[]) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], predicate: (elem: char, index: number, array: char[]) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number, self)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], predicate: (value: char, index: number, array: char[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number, self)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], predicate: (value: char, index: number, array: char[]) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number, self)) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: char[], predicate: (value: char, index: number, array: char[]) => boolean): char[] {
    return filter(self, (value: char, index: number): boolean => predicate(value, index, self));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: char[], predicate: (element: char, index: number, array: char[]) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number, self)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: char[], callbackfn: (previousValue: char, currentValue: char, index: number, array: char[]) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = char>(self: char[], callbackfn: (previousValue: U, currentValue: char, index: number, array: char[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: char[], callbackfn: (previousValue: char, currentValue: char, index: number, array: char[]) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: char[], callbackfn: (previousValue: U, currentValue: char, index: number, array: char[]) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number, self)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: char[], callbackfn: (value: char, index: number, array: char[]) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number, self)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: char[], predicate: (value: char, index: number) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], predicate: (value: char, index: number) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], predicate: (elem: char, index: number) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val, i as number)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], predicate: (value: char, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i], i as number)) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], predicate: (value: char, index: number) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i], i as number)) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: char[], predicate: (element: char, index: number) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i], i as number)) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: char[], callbackfn: (previousValue: char, currentValue: char, index: number) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = char>(self: char[], callbackfn: (previousValue: U, currentValue: char, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: char[], callbackfn: (previousValue: char, currentValue: char, index: number) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: char[], callbackfn: (previousValue: U, currentValue: char, index: number) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i], i as number)
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: char[], callbackfn: (value: char, index: number) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i], i as number)
    }
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: char[], predicate: (value: char) => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], predicate: (value: char) => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return i;
        }
    }
    return -1;
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], predicate: (elem: char) => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate(val)) {
            return val;
        }
    }
    return undefined;
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], predicate: (value: char) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate(self[i])) {
            return false
        }
    }
    return true;
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], predicate: (value: char) => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate(self[i])) {
            return true
        }
    }
    return false
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: char[], predicate: (value: char) => boolean): char[] {
    return filter(self, (value: char, index: number): boolean => predicate(value));
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: char[], predicate: (element: char) => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate(self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: char[], callbackfn: (previousValue: char, currentValue: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = char>(self: char[], callbackfn: (previousValue: U, currentValue: char) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: char[], callbackfn: (previousValue: char, currentValue: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: char[], callbackfn: (previousValue: U, currentValue: char) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc, self[i])
    }
    return acc
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: char[], callbackfn: (value: char) => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn(self[i])
    }
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start?: Number, end?: Number): char[] {
    const len: int = self.length;
    return slice(self, asIntOrDefault(start, 0), asIntOrDefault(end, len))
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `end` (`end` not included) where `start` and `end` represent the index of items in that array.
 *
 * @param start zero-based index at which to start extraction
 *
 * @param end zero-based index at which to end extraction. `slice()` extracts up to but not including end.
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start: int, end: int): char[] {
    const len: int = self.length;
    const relStart = normalizeIndex(start, len)
    const relEnd = normalizeIndex(end, len)

    let count = relEnd - relStart;
    if (count < 0) {
        count = 0;
    }
    let res = new char[count]
    for (let i = 0; i < count; i++) {
        res[i] = self[relStart + i];
    }

    return res
}

/**
 * Creates a new `Array` object and populates it with elements of `this` instance of `Array` class
 * selected from `start` to `Int.MAX_VALUE`, which means 'to the end of an array'.
 *
 * @param start zero-based index at which to start extraction
 *
 * @returns `Array` instance, constructed from extracted elements of `this` instance.
 */
export function slice(self: char[], start: int): char[] {
    return slice(self, start, Int.MAX_VALUE as int);
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: char[], element: char, fromIndex: int): int {
    if (self.length == 0) {
        return -1;
    }
    let n = fromIndex;
    let k: int;
    if (n >= 0) {
        k = min(self.length - 1, n);
    } else {
        k = self.length + n;
    }

    while (k >= 0) {
        if (__runtimeEquals(self[k], element)) {
            return k;
        }
        k--;
    }
    return -1;
}

/**
 * Returns the last index at which a given element can be found in the array,
 * or -1 if it is not present. The array is searched backwards, starting at fromIndex.
 *
 * @param element element to locate in the array.
 * @param fromIndex zero-based index at which to start searching backwards.
 * Negative index counts back from the end of the array — if `fromIndex` < 0, `fromIndex` + `length()` is used.
 * If `fromIndex` < `-length()`, the array is not searched and -1 is returned.
 * If `fromIndex` >= `length()` then `array.length - 1` is used, causing the entire array to be searched.
 *
 * @returns The last index of the element in the array; -1 if not found.
 */
export function lastIndexOf(self: char[], element: char, fromIndex?: Number): number {
    return lastIndexOf(self, element, asIntOrDefault(fromIndex, self.length - 1));
}

/**
 * Creates and returns a new string by concatenating all of the elements in an `Array`,
 * separated by a specified separator string.
 * If the array has only one item, then that item will be returned without using the separator.
 *
 * @param sep specifies a separator
 *
 * @returns A string with all array elements joined. If `length()` is 0, the empty string is returned.
 */
export function join(self: char[], sep?: String): string {
    if (self.length == 0) {
        return ""
    }
    const sepReal = __runtimeIsSameReference(sep, undefined) ? "," : sep!
    let sb = new StringBuilder(new String(self[0]))
    for (let i: int = 1; i < self.length; i++) {
        const tmp = self[i]
        sb.append(sepReal);
        sb.append(tmp)
    }

    return sb.toString();
}

/**
 * Returns a string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toString(self: char[], ): string {
    return join(self, ",");
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param locales
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], locales: Object, options: Object): string {
    throw new Error("Array.toLocaleString: not implemented")
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @param options
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], locales: Object): string {
    return toLocaleString(self, new Object(), new Object())
}

/**
 * Returns a locale string representing the specified array and its elements.
 *
 * @returns string representation
 */
export function toLocaleString(self: char[], ): string {
    const sb = new StringBuilder()
    const len = self.length;
    for (let i = 0; i < len; i++) {
        if (i != 0) {
            sb.append(",")
        }
        let x = self[i] as NullishType;
        if (!__runtimeIsSameReference(null, x) && !__runtimeIsSameReference(undefined, x)) {
            sb.append(x!.toLocaleString())
        }
    }
    return sb.toString()
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start?: Number, delete?: Number): char[] {
    const len = self.length;
    return toSpliced(self, asIntOrDefault(start, len), asIntOrDefault(delete, len))
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: number, delete: number, ...items: char[]): char[] {
    const len = self.length;
    return toSpliced(self, start as int, delete as int, ...items)
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @param delete number of items after start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: int, delete: int, ...items: char[]): char[] {
    const len = self.length;
    start = normalizeIndex(start, len);
    if (delete < 0) {
        delete = 0;
    } else if (delete > len) {
        delete = len;
    }
    if (start > len - delete) {
        delete = len - start
    }
    const res = new char[len - delete + items.length];
    for (let i = 0; i < start; i++) {
        res[i] = self[i]
    }
    for (let i = 0; i < items.length; i++) {
        res[start + i] = items[i]
    }
    for (let i = start + delete; i < len; i++) {
        res[i - delete + items.length] = self[i]
    }
    return res;
}

/**
 * Copying version of the splice() method.
 *
 * @param start index
 *
 * @returns a new Array with some elements removed and/or replaced at a given index.
 */
export function toSpliced(self: char[], start: int): char[] {
    return toSpliced(self, start, self.length)
}

/**
 * Checks whether an Array includes a certain value among its entries,
 * returning true or false as appropriate.
 *
 * @param val value to search
 *
 * @param fromIndex start index
 *
 * @returns true if val is in Array
 */
export function includes(self: char[], val: char, fromIndex?: Number): boolean {
    const len = self.length;
    const fi = normalizeIndex(asIntOrDefault(fromIndex, 0), len);
    for (let i = fi; i < len; i++) {
        if (val == self[i]) {
            return true;
        }
    }
    return false;
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: char[], val: char, fromIndex: int): int {
    fromIndex = normalizeIndex(fromIndex, self.length)
    for (let i = fromIndex; i < self.length; i++) {
        if (__runtimeEquals(val, self[i])) {
            return i
        }
    }
    return -1
}

/**
 * Returns the first index at which a given element
 * can be found in the array, or -1 if it is not present.
 *
 * @param val value to search
 *
 * @param fromIndex index to search from
 *
 * @returns index of val, -1 otherwise
 */
export function indexOf(self: char[], val: char, fromIndex?: Number): number {
    return indexOf(self, val, asIntOrDefault(fromIndex, 0))
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @returns sorted copy of hte current instance using default comparator
 */
export function toSorted(self: char[], ): char[] {
    let arr = cloneArray(self);
    sort(arr, )
    return arr
}

/**
 * Copying version of the sort() method.
 * It returns a new array with the elements sorted in ascending order.
 *
 * @param comparator function to compare to elements of the Array
 *
 * @returns sorted copy of the current instance comparator
 */
export function toSorted(self: char[], comparator: (a: char, b: char) => number): char[] {
    let arr = cloneArray(self);
    sort(arr, comparator)
    return arr
}

/**
 * Modifies `this` instance of `Array` class and populates
 * it with same elements ordered towards the direction opposite to that previously stated.
 *
 * @note Mutating method
 */
export function reverse(self: char[], ): char[] {
    for (let i = 0; i < self.length / 2; i++) {
        const tmp = self[i];
        const idx_r = self.length - 1 - i;
        const val_r = self[idx_r];
        self[i] = val_r;
        self[idx_r] = tmp;
    }
    return self;
}

/**
 * Copying version of the reverse() method.
 * It returns a new array with the elements in reversed order.
 *
 * @returns reversed copy of the current Array
 */
export function toReversed(self: char[], ): char[] {
    let arr = new char[self.length]
    for (let i = 0; i < self.length; i++) {
        arr[self.length - 1 - i] = self[i]
    }
    return arr
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: char[], index: number, value: char): char[] {
    return with(self, index as int, value)
}

/**
 * Copying version of using the bracket notation to change the value of a given index.
 * It returns a new Array with the element at the given index replaced with the given value.
 *
 * @param index to replace
 *
 * @param value new value
 *
 * @returns a new Array with the element at the given index replaced with the given value
 */
export function with(self: char[], index: int, value: char): char[] {
    if (index < 0) {
        index += self.length;
    }
    if (index >= self.length) {
        throw new RangeError("Invalid index")
    }
    let arr = cloneArray(self);
    arr[index] = value;
    return arr
}

/**
 * Returns an iterator over all values
 */
export function values(self: char[], ): IterableIterator<char> {
    return new ArrayValuesIterator_char(self);
}

/**
 * Returns an iterable of key, value pairs for every entry in the array
 */
export function entries(self: char[], ): IterableIterator<[number, char]> {
    return new ArrayEntriesIterator_char(self);
}

/**
 * Determines whether all the members of an array satisfy the specified test.
 *
 * @param predicate A function that accepts up to three arguments. The every method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value false, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for every array element. Otherwise, `false`.
 */
export function every(self: char[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (!predicate()) {
            return false
        }
    }
    return true
}

/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 *
 * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `predicate`.
 */
export function filter(self: char[], predicate: () => boolean): char[] {
    return filter(self, (value: char, index: number): boolean => predicate());
}

/**
 * Returns the value of the first element in the array where predicate is true, and undefined
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found, find
 * immediately returns that element value. Otherwise, find returns undefined.
 *
 * @returns the value of the first element in the array or undefined
 */
export function find(self: char[], predicate: () => boolean): Char | undefined {
    const res = findIndex(self, predicate)
    if (res == -1) {
        return undefined
    }
    return self[res as int];
}

/**
 * Returns the index of the first element in the array where predicate is true, and -1
 * otherwise.
 *
 * @param predicate find calls predicate once for each element of the array, in ascending
 * order, until it finds one where predicate returns true. If such an element is found,
 * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
 *
 * @returns found element index or -1 otherwise
 */
export function findIndex(self: char[], predicate: () => boolean): number {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return i;
        }
    }
    return -1;
}

/**
 * Performs the specified action for each element in an array.
 *
 * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
 */
export function forEach(self: char[], callbackfn: () => void): void {
    const len0 = self.length;
    for (let i = 0; i < len0; i++) {
        callbackfn()
    }
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: char[], callbackfn: (previousValue: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce(self: char[], callbackfn: () => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[0];
    for (let i = 1; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = char>(self: char[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduce<U = char>(self: char[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = 0; i < self.length; i++) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: char[], callbackfn: (previousValue: char) => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight(self: char[], callbackfn: () => char): char {
    if (self.length == 0) {
        throw new TypeError("Reduce of empty array with no initial value")
    }
    let acc: char = self[self.length - 1];
    for (let i = self.length - 2; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: char[], callbackfn: (previousValue: U) => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn(acc)
    }
    return acc
}

/**
 * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
 *
 * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
 *
 * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
 *
 * @returns a result after applying callbackfn over all elements of the Array
 */
export function reduceRight<U>(self: char[], callbackfn: () => U, initialValue: U): U {
    let acc = initialValue
    for (let i = self.length - 1; i >= 0; i--) {
        acc = callbackfn()
    }
    return acc
}

/**
 * Determines whether the specified callback function returns true for any element of an array.
 *
 * @param predicate A function that accepts up to three arguments. The some method calls
 * the predicate function for each element in the array until the predicate returns a value
 * which is coercible to the Boolean value true, or until the end of the array.
 *
 * @returns `true` if `predicate` returns a `true` value for at least one array element. Otherwise, `false`.
 */
export function some(self: char[], predicate: () => boolean): boolean {
    for (let i = 0; i < self.length; i++) {
        if (predicate()) {
            return true
        }
    }
    return false
}

/**
 * Iterates the array in reverse order and returns the value of the first element
 * that satisfies the provided testing function
 *
 * @param predicate testing function
 *
 * @returns found element or undefined otherwise
 */
export function findLast(self: char[], predicate: () => boolean): Char | undefined {
    for (let i = self.length - 1; i >= 0; i--) {
        const val = self[i];
        if (predicate()) {
            return val;
        }
    }
    return undefined;
}

/**
 * Iterates the array in reverse order and returns the index of
 * the first element that satisfies the provided testing function.
 * If no elements satisfy the testing function, -1 is returned.
 *
 * @param predicate testing function
 *
 * @returns index of first element satisfying to predicate, -1 if no such element
 */
export function findLastIndex(self: char[], predicate: () => boolean): number {
    for (let i = self.length - 1; i >= 0; i--) {
        if (predicate()) {
            return i
        }
    }
    return -1
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], callbackfn: (value: char, index: number, array: char[]) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number, self);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], callbackfn: (value: char, index: number) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i], i as number);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], callbackfn: (value: char) => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn(self[i]);
    }
    return res;
}

/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 *
 * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
 *
 * @returns `Array` instance, constructed from `this` and given function.
 */
export function map(self: char[], callbackfn: () => char): char[] {
    const len = self.length;
    let res = new char[len];
    for (let i = 0; i < len; i++) {
        res[i] = callbackfn();
    }
    return res;
}

/**
 * Constructs a new `Array` instance and populates it with
 * portion of a given array, filtered down to just the elements from the
 * given array that pass the test implemented by the provided function.
 *
 * @param fn test function, applied to each element of an array.
 *
 * @returns New `Array` instance constructed from `this` with elements filtered using test function `fn`.
 */
export function filter(self: char[], fn: (v: char, k: number) => boolean): char[] {
    const mask = new boolean[self.length]
    let cnt = 0

    for (let i: int = 0; i < self.length; i++) {
        const val = self[i];
        if (fn(val, i)) {
            mask[i] = true
            cnt++;
        }
    }
    const res = new char[cnt];
    let idx_store = 0;
    for (let i: int = 0; i < self.length; i++) {
        if (mask[i]) {
            res[idx_store++] = self[i]
        }
    }
    return res;
}

export function concat(self: char[], fst: char[], ...more: char[][]): char[] {
    const lnMin = self.length + fst.length;
    let ln = lnMin;
    for (let i = 0; i < more.length; i++) {
        ln += more[i].length
    }
    const r = new char[ln];
    try {
        copyTo(self, r, 0, 0, self.length);
        copyTo(fst, r, self.length, 0, fst.length);
        let idx = lnMin;
        for (let i = 0; i < more.length; i++) {
            copyTo(more[i], r, idx, 0, more[i].length);
            idx += more[i].length;
        }
    } catch (e) {
        // impossible
    }
    return r
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: char[], comparator: (a: char, b: char) => number): char[] {
    sort_subarray(self, 0, self.length, (l: char, r: char): boolean => {
        return comparator(l, r ) < 0;
    });
    return self;
}

/**
 * Reorders elements of `this` using comparator function.
 *
 * @param comparator function that defines the sort order.
 *
 * @note Mutating method
 */
export function sort(self: char[], ): char[] {
    sort(self, 0, self.length);
    return self;
}

export function keys(self: char[]): IterableIterator<number> {
    return new BuiltinArrayKeysIterator(self.length);
}

class ArrayValuesIterator_char implements IterableIterator<char> {
    private parent: char[]
    private idx: int = 0

    constructor(parent: char[]) {
        this.parent = parent
    }

    override next(): IteratorResult<char> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<char>()
        }
        return new IteratorResult<char>(this.parent[this.idx++])
    }

    override $_iterator(): IterableIterator<char> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

class ArrayEntriesIterator_char implements IterableIterator<[number, char]> {
    private parent: char[]
    private idx: int = 0

    constructor(parent: char[]) {
        this.parent = parent
    }

    override next(): IteratorResult<[number, char]> {
        if (this.idx >= this.parent.length) {
            return new IteratorResult<[number, char]>()
        }
        const i = this.idx++;
        const vl: [number, char] = [i as number, this.parent[i]]
        return new IteratorResult<[number, char]>(vl);
    }

    override $_iterator(): IterableIterator<[number, char]> {
        return this;
    }

    public __Iterator_getLength(): int {
        return this.parent.length as int
    }
}

function builtin_insertion_sort<T>(arr: T[], startIndex: int, endIndex: int, comp: (lhs: T, rhs: T) => number): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i];
        if (comp(tmp, arr[startIndex]) as int < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
            }
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (comp(tmp, arr[j]) as int < 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = tmp;
        }
    }
}

function perform_merge<T>(arr: T[], startIndex: int, midIndex: int, endIndex: int, comp: (lhs: T, rhs: T) => number): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    let left = new T[len1];
    let right = new T[len2];
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i];
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i];
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (comp(left[i], right[j]) as int <= 0) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

export function sort_stable<T>(arr: T[], startIndex: int, endIndex: int, comp: (lhs: T, rhs: T) => number): void {
    if (endIndex <= startIndex) {
        return;
    }

    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        builtin_insertion_sort<T>(arr, i, min(i + INS_SORT_DELTA , endIndex), comp)
    }
    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid+1....right]
            if (mid < right) {
                perform_merge(arr, left, mid, right, comp);
            }
        }
    }
}

function defaultComparatorStr(a: String, b: String): number {
    return a.compareTo(b)
}

type buffStr = String | null
function stringified_insertion_sort<T>(arr: T[], arrStr: buffStr[], startIndex: int, endIndex: int): void {
    for (let i = startIndex + 1; i < endIndex; i++) {
        const tmp = arr[i]
        const tmpStr = arrStr[i];
        if (defaultComparatorStr(tmpStr!, arrStr[startIndex]!) < 0) {
            for (let j = i; j > startIndex; j--) {
                arr[j] = arr[j - 1]
                arrStr[j] = arrStr[j - 1]
            }
            arrStr[startIndex] = tmpStr
            arr[startIndex] = tmp
        } else {
            let j = i - 1;
            while (defaultComparatorStr(tmpStr!, arrStr[j]!) < 0) {
                arr[j + 1] = arr[j];
                arrStr[j + 1] = arrStr[j]
                j--;
            }
            arr[j + 1] = tmp;
            arrStr[j + 1] = tmpStr
        }
    }
}

function stringified_perform_merge<T>(arr: T[], arrStr: buffStr[], startIndex: int, midIndex: int, endIndex: int): void {
    const len1 = midIndex - startIndex + 1;
    const len2 = endIndex - midIndex;
    type buffType = T | null
    let left = new buffType[len1]
    let right = new buffType[len2]
    let leftStr = new buffStr[len1]
    let rightStr = new buffStr[len2]
    for (let i = 0; i < len1; i++) {
        left[i] = arr[startIndex + i]
        leftStr[i] = arrStr[startIndex + i]
    }
    for (let i = 0; i < len2; i++) {
        right[i] = arr[midIndex + 1 + i]
        rightStr[i] = arrStr[midIndex + 1 + i]
    }
    let i = 0;
    let j = 0;
    let k = startIndex;
    while (i < len1 && j < len2) {
        if (defaultComparatorStr(leftStr[i]!, rightStr[j]!) <= 0) {
            arr[k] = left[i]!;
            arrStr[k] = leftStr[i]!;
            i++;
        } else {
            arr[k] = right[j]!;
            arrStr[k] = rightStr[j]!;
            j++;
        }
        k++;
    }
    while (i < len1) {
        arr[k] = left[i]!;
        arrStr[k] = leftStr[i]!;
        k++;
        i++;
    }
    while (j < len2) {
        arr[k] = right[j]!;
        arrStr[k] = rightStr[j]!;
        k++;
        j++;
    }
}

export function sort_default<T>(arr: T[], arrStr: buffStr[], startIndex: int, endIndex: int): void {
    if (endIndex <= startIndex) {
        return;
    }
    const INS_SORT_DELTA = 16
    for (let i = startIndex; i < endIndex; i += INS_SORT_DELTA ) {
        stringified_insertion_sort<T>(arr, arrStr, i, min(i + INS_SORT_DELTA , endIndex))
    }

    if ((endIndex - startIndex) < INS_SORT_DELTA) {
        return;
    }
    for (let size = INS_SORT_DELTA; size < endIndex; size = 2 * size) {
        for (let left = startIndex; left < endIndex; left += 2 * size) {

            // Find ending point of left subarray and right subarray
            const mid = min(left + size - 1, endIndex - 1);
            const right = min((left + 2 * size - 1), (endIndex - 1));

            // Merge sub array arr[left.....mid] and arr[mid+1....right]
            if (mid < right) {
                stringified_perform_merge(arr, arrStr, left, mid, right);
            }
        }
    }
}
