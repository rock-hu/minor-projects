/**
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

// NOTE: autogenerated file

export const KEY_NOT_FOUND = -1;

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of. It may be not in arr, lower bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<boolean>, key: boolean, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] == false && key == true) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of. It may be not in arr, lower bound will present anyway
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<boolean>, key: boolean): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<boolean>, key: boolean, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] == false && key == true || arr[middle] == key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<boolean>, key: boolean): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<boolean>): FixedArray<boolean> {
    const r : FixedArray<boolean> = new boolean[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<boolean>, dst: FixedArray<boolean>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<byte>, key: byte, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<byte>, key: byte): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<byte>, key: byte, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<byte>, key: byte): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<byte>): FixedArray<byte> {
    const r : FixedArray<byte> = new byte[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<byte>, dst: FixedArray<byte>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<short>, key: short, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<short>, key: short): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<short>, key: short, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<short>, key: short): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<short>): FixedArray<short> {
    const r : FixedArray<short> = new short[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<short>, dst: FixedArray<short>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<int>, key: int, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<int>, key: int): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<int>, key: int, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<int>, key: int): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<int>): FixedArray<int> {
    const r : FixedArray<int> = new int[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<int>, dst: FixedArray<int>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<long>, key: long, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<long>, key: long): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<long>, key: long, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<long>, key: long): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<long>): FixedArray<long> {
    const r : FixedArray<long> = new long[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<long>, dst: FixedArray<long>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<float>, key: float, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<float>, key: float): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<float>, key: float, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<float>, key: float): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<float>): FixedArray<float> {
    const r : FixedArray<float> = new float[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<float>, dst: FixedArray<float>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<double>, key: double, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<double>, key: double): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<double>, key: double, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<double>, key: double): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<double>): FixedArray<double> {
    const r : FixedArray<double> = new double[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<double>, dst: FixedArray<double>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

// C++ semantics
// (lower|upper)BoundSearch([1, 1, 2, 2, 2, 3, 3], 2, 0, 7)
//                                 ^        ^
//                                 |        |
//                                 |    upper bound
//                             lower bound

/**
 * tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is endIndex
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than endIndex
 */
export function lowerBoundSearch(arr: FixedArray<char>, key: char, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)){
        throw new RangeError("lowerBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] < key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 *  tries to find a lower bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Lower bound is an index of a first element, where (element < key) is false. If no such element is found than lower bound is arr.length
 *
 * @param arr array to find a lower bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find lower bound of
 *
 * @returns index such (arr[index] < key) is false. If no such index is found than arr.length
 */
export function lowerBoundSearch(arr: FixedArray<char>, key: char): int {
    return lowerBoundSearch(arr, key, 0, arr.length);
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @param startIndex an index of arr to begin search with
 *
 * @param endIndex a last index to stop search in arr, i.e. arr[endIndex] is not checked
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than endIndex
 */
export function upperBoundSearch(arr: FixedArray<char>, key: char, startIndex: int, endIndex: int): int {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new RangeError("upperBoundSearch: bounds verification failed")
    }

    let left: int = startIndex;
    let len: int = endIndex - startIndex;

    while (len > 0) {
        let half: int = len >>> 1;
        let middle: int = left + half;

        if (arr[middle] <= key) {
            left = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    }

    return left;
}

/**
 * tries to find an upper bound of a key in sorted arr.
 * The array has to be sorted before calling this function.
 * Upper bound is an index of a first element, where (key < element) is true. If no such element is found than upper bound is endIndex
 *
 * @param arr array to find a upper bound of a key. Has to be sorted, otherwise the answer is implementation-defined and may be incorrect
 *
 * @param key a value to find upper bound of. It may be not in arr, upper bound will present anyway
 *
 * @returns index such (key < arr[index]) is true. If no such index is found than arr.length
 */
export function upperBoundSearch(arr: FixedArray<char>, key: char): int {
    return upperBoundSearch(arr, key, 0, arr.length);
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<char>): FixedArray<char> {
    const r : FixedArray<char> = new char[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<char>, dst: FixedArray<char>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}

/**
 * Makes an array shallow copy
 *
 * @param src source array to be copied
 * @returns copy of `src`
 */
export function copyOf(src: FixedArray<NullishType>): FixedArray<NullishType> {
    const r : FixedArray<NullishType> = new NullishType[src.length];
    try {
        copyTo(src, r, 0, 0, src.length);
    } catch (e) {
        // ignore
    }
    return r;
}

/**
 * copies src array into dst with respect to passed indexes.
 * dst must have enough space, otherwise out-of-bounds might occur
 *
 * @param src source array to be copied
 *
 * @param dst destination array
 *
 * @param dstStart index of dst to start from
 *
 * @param srcStart index of src to start from
 *
 * @param srcEnd last index of src to copy, exclusive, i.e. src[srcEnd] is not copied
 *
 * @example: copy src to dst
 * ```
 * copyTo(src, dst, 0, 0, src.length)
 * ```
 */
export function copyTo(src: FixedArray<NullishType>, dst: FixedArray<NullishType>, dstStart: int, srcStart: int, srcEnd: int): void {
    if (!checkRange(src.length, srcStart, srcEnd)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: src bounds verification failed")
    }
    if (!checkRange(dst.length, dstStart, dst.length)) {
        throw new ArrayIndexOutOfBoundsError("copyTo: dst bounds verification failed")
    }
    if (!((srcEnd - srcStart) <= (dst.length - dstStart))) {
        throw new ArrayIndexOutOfBoundsError("Destination array must have enough space")
    }

    let j: int = dstStart;
    for (let i: int = srcStart; i < srcEnd; i++) {
        dst[j] = src[i];
        j++;
    }
}
