/*
 * Copyright (c) 2021-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS of ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package std.core;

export type TypeDesc = string

/*
    Type intrinsics
*/
native function TypeAPIGetTypeDescriptor(o: NullishType): string

native function TypeAPIGetTypeKind(td: TypeDesc): byte

native function TypeAPIIsValueType(td: TypeDesc): boolean

native function TypeAPIGetTypeName(td: TypeDesc): string

native function TypeAPIGetTypeId(td: TypeDesc): long

/*
    Class type intrinsics
*/
native function TypeAPIGetClassAttributes(td: TypeDesc): int

native function TypeAPIGetFieldsNum(td: TypeDesc): long

native function TypeAPIGetOwnFieldsNum(td: TypeDesc): long

native function TypeAPIGetField(td: TypeDesc, i: long): Field

native function TypeAPIGetOwnField(td: TypeDesc, i: long): Field

native function TypeAPIGetFieldByName(td: TypeDesc, name: string): Field

native function TypeAPIGetStaticFieldValue(ownerTD: TypeDesc, name: string): NullishType

native function TypeAPIGetMethodsNum(td: TypeDesc): long

native function TypeAPIGetMethod(td: TypeDesc, i: long): Method

native function TypeAPIGetConstructorsNum(td: TypeDesc): long

native function TypeAPIGetConstructor(td: TypeDesc, i: long): Method

native function TypeAPIGetBaseType(td: TypeDesc): TypeDesc

native function TypeAPIGetInterfacesNum(td: TypeDesc): long

native function TypeAPIGetInterface(td: TypeDesc, i: long): TypeDesc

native function TypeAPISetStaticFieldValue(ownerTD: TypeDesc, name: string, val: NullishType): void

native function TypeAPIIsInheritedFrom(ltd: TypeDesc, rtd:TypeDesc): boolean

/*
    Function (Lambda or Method) type intrinsics
*/
native function TypeAPIGetFunctionAttributes(td: TypeDesc): int

native function TypeAPIGetReceiverType(td: TypeDesc): TypeDesc

native function TypeAPIGetParametersNum(td: TypeDesc): long

native function TypeAPIGetParameter(td: TypeDesc, i: long): Parameter

native function TypeAPIGetResultType(td: TypeDesc): TypeDesc

/*
    Array type intrinsics
*/
native function TypeAPIGetArrayElementType(td: TypeDesc): TypeDesc

native function TypeAPIMakeArrayInstance(td: TypeDesc, len: long): Object

// NOTE(shumilov-petr): replace to enum, enum not available now
export class TypeKind {
    public static readonly NONE: byte       = 0x0
    public static readonly VOID: byte       = 0x1

    public static readonly CHAR: byte       = 0x2
    public static readonly BOOLEAN: byte    = 0x3
    public static readonly BYTE: byte       = 0x4
    public static readonly SHORT: byte      = 0x5
    public static readonly INT: byte        = 0x6
    public static readonly LONG: byte       = 0x7
    public static readonly FLOAT: byte      = 0x8
    public static readonly DOUBLE: byte     = 0x9

    public static readonly CLASS: byte      = 0xA
    public static readonly STRING: byte     = 0xB
    public static readonly INTERFACE: byte  = 0xC
    public static readonly ARRAY: byte      = 0xD
    public static readonly TUPLE: byte      = 0xE
    public static readonly LAMBDA: byte     = 0xF
    public static readonly METHOD: byte     = 0x10

    public static readonly UNION: byte      = 0x11
    public static readonly UNDEFINED: byte  = 0x12
    public static readonly NULL: byte       = 0x13

    public static readonly ENUM: byte       = 0x14

    private constructor() {}
}

// 5 lower bits stores kind's id
const TypeKindMask: byte = (1 << 6) - 1

// NOTE(shumilov-petr): replace to enum, enum not available now
export class ValueTypeDesc {
    public static readonly BOOLEAN: TypeDesc   = "Z"
    public static readonly BYTE: TypeDesc      = "B"
    public static readonly SHORT: TypeDesc     = "S"
    public static readonly CHAR: TypeDesc      = "C"
    public static readonly INT: TypeDesc       = "I"
    public static readonly LONG: TypeDesc      = "J"
    public static readonly FLOAT: TypeDesc     = "F"
    public static readonly DOUBLE: TypeDesc    = "D"
}

const ObjectTD = "Lstd/core/Object;" // NOTE(shumilov-petr): get td from runtime

export const ObjectType: ClassType = new ClassType(ObjectTD)

export class Attributes {
    public static readonly STATIC: int      = 1 << 0  // Field, Method
    public static readonly INHERITED: int   = 1 << 1  // Field, Method
    public static readonly READONLY: int    = 1 << 2  // Field
    public static readonly FINAL: int       = 1 << 3  // Method, Class
    public static readonly ABSTRACT: int    = 1 << 4  // Method
    public static readonly CONSTRUCTOR: int = 1 << 5  // Method
    public static readonly REST: int        = 1 << 6  // Parameter
    public static readonly OPTIONAL: int    = 1 << 7  // Parameter
    public static readonly THROWING: int    = 1 << 8  // Method, Lambda
    public static readonly NATIVE: int      = 1 << 9  // Method, Lambda
    public static readonly ASYNC: int       = 1 << 10 // Method, Lambda
    public static readonly NEVERRESULT: int = 1 << 11 // Method, Lambda
    public static readonly GETTER: int      = 1 << 12 // Method
    public static readonly SETTER: int      = 1 << 13 // Method

    private constructor() {}
}

export class AccessModifier {
    public static readonly PUBLIC: byte       = 0
    public static readonly PRIVATE: byte      = 1
    public static readonly PROTECTED: byte    = 2

    private constructor() {}
}

/**
 * Runtime ArkTS type representation
 */
export abstract class Type extends Object {
    internal td: TypeDesc = new TypeDesc()


    /**
     * Resolves type by descriptor
     *
     * @param td type descriptor
     *
     * @returns instance of appropriate type or null if resolving is failed
     */
    public static resolve(td: TypeDesc): Type | null {
        let kind = (TypeAPIGetTypeKind(td) & TypeKindMask) as byte
        switch (kind) {
            case TypeKind.NONE:
                return null
            case TypeKind.VOID:
                return VoidType.REF
            case TypeKind.CHAR:
                return TypeAPIIsValueType(td) ? CharType.VAL : CharType.REF
            case TypeKind.BOOLEAN:
                return TypeAPIIsValueType(td) ? BooleanType.VAL : BooleanType.REF
            case TypeKind.BYTE:
                return TypeAPIIsValueType(td) ? ByteType.VAL : ByteType.REF
            case TypeKind.SHORT:
                return TypeAPIIsValueType(td) ? ShortType.VAL : ShortType.REF
            case TypeKind.INT:
                return TypeAPIIsValueType(td) ? IntType.VAL : IntType.REF
            case TypeKind.LONG:
                return TypeAPIIsValueType(td) ? LongType.VAL : LongType.REF
            case TypeKind.FLOAT:
                return TypeAPIIsValueType(td) ? FloatType.VAL : FloatType.REF
            case TypeKind.DOUBLE:
                return TypeAPIIsValueType(td) ? DoubleType.VAL : DoubleType.REF

            case TypeKind.CLASS:
                return new ClassType(td)
            case TypeKind.STRING:
                return StringType.REF
            case TypeKind.INTERFACE:
                return new InterfaceType(td)
            case TypeKind.ARRAY:
                return ArrayType.getInstance(td)
            case TypeKind.TUPLE:
                return new TupleType(td)
            case TypeKind.LAMBDA:
                return new LambdaType(td)
            case TypeKind.METHOD:
                return new MethodType(td)
            case TypeKind.UNION:
                return new UnionType(td)
            case TypeKind.UNDEFINED:
                return UndefinedType.REF
            case TypeKind.NULL:
                return NullType.REF

            case TypeKind.ENUM:
                return new EnumType(td)
            default:
                // NOTE(shumilov-petr): unknown type, need error
                assert(false)
        }

        return null;
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: boolean): Type {
        return BooleanType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: char): Type {
        return CharType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: byte): Type {
        return ByteType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: short): Type {
        return ShortType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: int): Type {
        return IntType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: long): Type {
        return LongType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: float): Type {
        return FloatType.VAL
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: double): Type {
        return DoubleType.VAL
    }

    // -----

    public static of(o: NullishType): Type {
        let td = TypeAPIGetTypeDescriptor(o)
        return Type.resolve(td)!
    }

    // -----

    public static of(v: Boolean): Type {
        return BooleanType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Char): Type {
        return CharType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Byte): Type {
        return ByteType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Short): Type {
        return ShortType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Int): Type {
        return IntType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Long): Type {
        return LongType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Float): Type {
        return FloatType.REF
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Double): Type {
        return DoubleType.REF
    }

    // -----

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: string): Type {
        return StringType.REF
    }

    // -----

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: boolean[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.BOOLEAN)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: char[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.CHAR)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: byte[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.BYTE)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: short[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.SHORT)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: int[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.INT)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: long[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.LONG)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: float[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.FLOAT)
    }

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: double[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v), ValueTypeDesc.DOUBLE)
    }

    // -----

    /**
     * Returns Type of value
     *
     * @param v value
     *
     * @returns Type instance of this value
     */
    public static of(v: Object[]): Type {
        return ArrayType.getInstance(TypeAPIGetTypeDescriptor(v))
    }

    public abstract isPrimitive(): boolean // Or Composite

    public abstract isReference(): boolean // Or Value

    public abstract hasName(): boolean

    // T.subTypeOf(U) means that `T extends U`
    protected subTypeOf(other: Type): boolean {
        if (this.equals(other)) {
            return true
        } else if (other.equals(ObjectType)) {
            let isNullish = (this) instanceof UndefinedType || (this) instanceof NullType
            return this.isReference() && !isNullish
        }
        return false
    }

    // T.assignableFrom(U) means that `T <- U`
    public assignableFrom(other: Type): boolean {
        if (other.subTypeOf(this)) {
            return true
        }
        if (this.isNumericType() && other.isNumericType()) {
            return true
        }
        return false
    }

    internal abstract convertObject(obj: NullishType): NullishType;

    private isNumericType(): boolean {
        return (this) instanceof ByteType
            || (this) instanceof ShortType
            || (this) instanceof IntType
            || (this) instanceof LongType
            || (this) instanceof FloatType
            || (this) instanceof DoubleType
    }

    public getId(): long {
        return TypeAPIGetTypeId(this.td);
    }

    public abstract getName(): string

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public abstract getLiteral(): string

    public override toString(): string {
        if (this.hasName()) {
            return this.getName()
        }
        return this.getLiteral()
    }

    abstract equals(other: Type): boolean
}

/**
 * Represents null type
 */
export final class NullType extends Type {
    public static readonly REF: NullType = new NullType()

    private constructor() {
        this.td = TypeAPIGetTypeDescriptor(null)
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns type name
     */
    public override getName(): string {
        return "null"
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        return "null"
    }

    /**
     * Checks for equality this instance with provided object, treated as a DoubleType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has NullType
     */
    public override equals(other: Type): boolean {
        return other instanceof NullType
    }

    internal override convertObject(obj: NullishType): NullishType {
        if (obj != null) {
            throw new Error("invalid conversion")
        }
        return null
    }
}

export final class UndefinedType extends Type {
    public static readonly REF: UndefinedType = new UndefinedType()

    private constructor() {
        this.td = TypeAPIGetTypeDescriptor(undefined)
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type if exists and empty string otherwise
     *
     * @returns type name
     */
    public override getName(): string {
        return "undefined"
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        return "undefined"
    }

    /**
     * Checks for equality this instance with provided object, treated as a UndefinedType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has UndefinedType
     */
    public override equals(other: Type): boolean {
        return other instanceof UndefinedType
    }

    internal override convertObject(obj: NullishType): NullishType {
        throw new Error("todo(kprokopenko): add when undefined becomes available")
    }
}

/**
 * Represents void type
 */
export final class VoidType extends Type {
    public static readonly REF: VoidType = new VoidType()

    private constructor() {
        this.td = TypeAPIGetTypeDescriptor(Void.void_instance)
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type if exists and empty string otherwise
     *
     * @returns type name
     */
    public override getName(): string {
        return "void"
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        return "void"
    }

    /**
     * Checks for equality this instance with provided object, treated as a VoidType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has VoidType
     */
    public override equals(other: Type): boolean {
        return other instanceof VoidType
    }

    internal override convertObject(obj: NullishType): NullishType {
        if (!this.assignableFrom(Type.of(obj))) {
            throw new Error("invalid conversion")
        }
        return Void.void_instance
    }
}

/**
 * Represents char type
 *
 * @note Boxed Char and primitive char both have CharType
 */

export final class CharType extends Type {
    public static readonly VAL: CharType = new CharType(ValueTypeDesc.CHAR, true)
    public static readonly REF: CharType = new CharType(TypeAPIGetTypeDescriptor(new Char()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "char"
        }
        return "Char"
    }

    public override equals(other: Type): boolean {
        return other instanceof CharType && this.isValue != (other as CharType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (!this.equals(objType)) {
            throw new Error("invalid type for conversion")
        }
        return obj
    }
}

/**
 * Represents boolean type
 *
 * @note Boxed Boolean and primitive boolean both have BooleanType
 */
export final class BooleanType extends Type {
    public static readonly VAL: BooleanType = new BooleanType(ValueTypeDesc.BOOLEAN, true)
    public static readonly REF: BooleanType = new BooleanType(TypeAPIGetTypeDescriptor(new Boolean()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "boolean"
        }
        return "Boolean"
    }

    override equals(other: Type): boolean {
        return other instanceof BooleanType && this.isValue != (other as BooleanType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (!this.equals(objType)) {
            throw new Error("invalid type for conversion")
        }
        return obj
    }
}

/**
 * Represents byte type
 *
 * @note Boxed Byte and primitive byte both have ByteType
 */
export final class ByteType extends Type {
    public static readonly VAL: ByteType = new ByteType(ValueTypeDesc.BYTE, true)
    public static readonly REF: ByteType = new ByteType(TypeAPIGetTypeDescriptor(new Byte()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "byte"
        }
        return "Byte"
    }

    public override equals(other: Type): boolean {
        return other instanceof ByteType && this.isValue != (other as ByteType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).byteValue()
    }
}

/**
 * Represents short type
 *
 * @note Boxed Short and primitive short both have ShortType
 */
export final class ShortType extends Type {
    public static readonly VAL: ShortType = new ShortType(ValueTypeDesc.SHORT, true)
    public static readonly REF: ShortType = new ShortType(TypeAPIGetTypeDescriptor(new Short()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "short"
        }
        return "Short"
    }

    /**
     * Checks for equality this instance with provided object, treated as a ShortType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has ShortType and
     * this type and other type both are reference or value
     */
    public override equals(other: Type): boolean {
        return other instanceof ShortType && this.isValue != (other as ShortType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).shortValue()
    }
}

/**
 * Represents int type
 *
 * @note Boxed Int and primitive int both have IntType
 */
export final class IntType extends Type {
    public static readonly VAL: IntType = new IntType(ValueTypeDesc.INT, true)
    public static readonly REF: IntType = new IntType(TypeAPIGetTypeDescriptor(new Int()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type if exists and empty string otherwise
     *
     * @throws error in case of absence of name
     *
     * @returns type name
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "int"
        }
        return "Int"
    }

    /**
     * Checks for equality this instance with provided object, treated as a IntType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has IntType and
     * this type and other type both are reference or value
     */
    public override equals(other: Type): boolean {
        return other instanceof IntType && this.isValue != (other as IntType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).intValue()
    }
}

/**
 * Represents long type
 *
 * @note Boxed Long and primitive long both have LongType
 */
export final class LongType extends Type {
    public static readonly VAL = new LongType(ValueTypeDesc.LONG, true)
    public static readonly REF = new LongType(TypeAPIGetTypeDescriptor(new Long()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type if exists and empty string otherwise
     *
     * @throws error in case of absence of name
     *
     * @returns type name
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "long"
        }
        return "Long"
    }

    /**
     * Checks for equality this instance with provided object, treated as a LongType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has LongType and
     * this type and other type both are reference or value
     */
    public override equals(other: Type): boolean {
        return other instanceof LongType && this.isValue != (other as LongType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).longValue()
    }
}

/**
 * Represents float type
 *
 * @note Boxed Float and primitive float both have FloatType
 */
export final class FloatType extends Type {
    public static readonly VAL: FloatType = new FloatType(ValueTypeDesc.FLOAT, true)
    public static readonly REF: FloatType = new FloatType(TypeAPIGetTypeDescriptor(new Float()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "float"
        }
        return "Float"
    }

    /**
     * Checks for equality this instance with provided object, treated as a FloatType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has FloatType and
     * this type and other type both are reference or value
     */
    public override equals(other: Type): boolean {
        return other instanceof FloatType && this.isValue != (other as FloatType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).floatValue()
    }
}

/**
 * Represents double type
 *
 * @note Boxed Double and primitive double both have DoubleType
 */
export final class DoubleType extends Type {
    public static readonly VAL: DoubleType = new DoubleType(ValueTypeDesc.DOUBLE, true)
    public static readonly REF: DoubleType = new DoubleType(TypeAPIGetTypeDescriptor(new Double()), false)

    private isValue: boolean

    private constructor(td: TypeDesc, isValue: boolean) {
        this.td = td
        this.isValue = isValue
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return !this.isValue
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return !this.isValue
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    //NOTE(kirill-mitkin): add error
    public override getName(): string {
        if (this.isValue) {
            return ""
        }
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        if (this.isValue) {
            return "double"
        }
        return "Double"
    }

    /**
     * Checks for equality this instance with provided object, treated as a DoubleType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has DoubleType and
     * this type and other type both are reference or value
     */
    public override equals(other: Type): boolean {
        return other instanceof DoubleType && this.isValue != (other as DoubleType).isReference()
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return (obj as Numeric).doubleValue()
    }
}

/**
 * Represents type of classes
 */
export final class ClassType extends Type {
    private readonly attrs: int

    internal constructor(td: TypeDesc) {
        this.td = td
        this.attrs = TypeAPIGetClassAttributes(td)
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type
     *
     * @returns type name
     */
    public override getName(): string {
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        // NOTE(shumilov-petr): not implemented
        return "class{...}"
    }

    /**
     * Checks for equality this instance with provided object, treated as a ClassType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has ClassType and their names are the same
     */
    public override equals(other: Type): boolean {
        return (other instanceof ClassType) && (other as ClassType).td == this.td
    }

    /**
     * Returns base type of this class
     * If this type is the type of Object class then returns this
     *
     * @returns base type of class
     */
    public getBaseType(): ClassType {
        return Type.resolve(TypeAPIGetBaseType(this.td))! as ClassType
    }

    /**
     * Returns number of direct superinterfaces of this class
     *
     * @returns number of interfaces that was implemented by this class directly
     */
    public getInterfacesNum(): long {
        return TypeAPIGetInterfacesNum(this.td)
    }

    /**
     * Returns ith direct superinterface of this class
     *
     * @param i index
     *
     * @throws error when i greater then num of interfaces
     *
     * @returns type of ith superinterface
     */
    public getInterface(i: long): InterfaceType {
        return Type.resolve(TypeAPIGetInterface(this.td, i))! as InterfaceType
    }

    /**
     * Returns number of all fields
     * including static, instance and also fields of all its superclasses
     *
     * @returns number of fields
     *
     * @example
     *
     * ```
     * class A {
     *     a : int
     * }
     *
     * class B extends A {
     *     b : int
     * }
     * ```
     * let bType class type of B, then `bType.getFieldsNum()` returns 2
     * Note that Object class also is super class of B
     */
    public getFieldsNum(): long {
        return TypeAPIGetFieldsNum(this.td)
    }

    public getOwnFieldsNum(): long {
        return TypeAPIGetOwnFieldsNum(this.td)
    }

    /**
     * Returns ith Field of this class
     *
     * @param i index (using flat semantic)
     *
     * @throws error when i greater then number of fields
     *
     * @returns ith Field
     */
    //NOTE(kirill-mitkin): add error
    public getField(i: long): Field {
        return TypeAPIGetField(this.td, i)
    }

    public getOwnField(i: long): Field {
        return TypeAPIGetOwnField(this.td, i)
    }

    /**
     * Find Field by name
     *
     * @param name name of field
     *
     * @throws error when class doesn't have field with this name
     *
     * @returns Field instance with this name
     */
    //NOTE(kirill-mitkin): add error
    public getFieldByName(name: string): Field {
        return TypeAPIGetFieldByName(this.td, name)
    }

    /**
     * Returns number of methods of this class
     * including static methods and methods of super classes
     * @example
     *
     * ```
     * class A {
     *     a(): void {}
     * }
     *
     * class B extends A {
     *     b(): void {}
     * }
     * ```
     * let bType class type of B, then `bType.getMethodsNum()` returns at least 2
     * Note that Object class also super class of B
     * @returns number of methods
     */
    public getMethodsNum(): long {
        return TypeAPIGetMethodsNum(this.td)
    }

    /**
     * Returns ith Method of this class
     *
     * @param i index (using flat semantic)
     *
     * @throws error when i greater then number of methods
     *
     * @returns ith method
     */
    //NOTE(kirill-mitkin): add error
    public getMethod(i: long): Method {
        return TypeAPIGetMethod(this.td, i)
    }

    /**
     * Returns number of constructors of this class
     * Note that constructors of super class isn't considered as constructors of this class
     *
     * @returns number of constructors
     */
    public getConstructorsNum(): long {
        return TypeAPIGetConstructorsNum(this.td)
    }

    /**
     * Returns ith constructor of this class
     *
     * @param i index
     *
     * @throws error then i greater then number of constructors
     *
     * @returns {@link Method} instance representing ith constructor
     */
    //NOTE(kirill-mitkin): add error
    public getConstructor(i: long): Method {
        return TypeAPIGetConstructor(this.td, i)
    }

    /**
     * Checks for existence of empty constructor of this class
     *
     * @returns true if there is empty constructor of this class
     */
    public hasEmptyConstructor(): boolean {
        let num = this.getConstructorsNum()
        for (let i = 0; i < num; i++) {
            if (this.getConstructor(i).getType().getParametersNum() == 0) {
                return true
            }
        }
        return false
    }

    public isFinal(): boolean {
        return (this.attrs & Attributes.FINAL) != 0
    }

    public hasField(name: string): boolean {
        // NOTE(shumilov-petr): may be faster if implement via intrinsic
        let fnum = this.getFieldsNum()
        for (let i = 0; i < fnum; i++) {
            if (this.getField(i).getName() == name) {
                return true
            }
        }
        return false
    }

    /**
     * Returns number of type parameters of this class
     *
     * @returns number of type parameters
     */
    public getTypeParametersNum(): long {
        // NOTE(shumilov-petr): not implemented
        throw new Error("Not implemented")
    }

    /**
     * Returns ith type parameter of this class
     *
     * @param i index
     *
     * @throws error then i greater then number of type parameters
     *
     * @returns NOTE(kirill-mitkin): we cannot return concrete type in this method
     */
    public getTypeParameter(i: long): Type {
        // NOTE(shumilov-petr): not implemented
        throw new Error("Not implemented")
    }

    /**
     * Makes instance of this type by invoking
     * empty constructor of this class
     *
     * @throws error when class doesn't have an empty constructor
     */
    public make(): Object {
        const emptyArgs = new NullishType[0]
        return this.make(emptyArgs)
    }

    // todo(kprokopenko): make varargs
    public make(args: NullishType[]): Object {
        const argTypes = new Array<Type>(args.length)
        for (let i = 0; i < args.length; i++) {
            argTypes[i] = Type.of(args[i])
        }
        // collect all applicable constructors
        const ctors = new Array<Method>()
        const ctorNum = this.getConstructorsNum()
        for (let i = 0; i < ctorNum; i++) {
            const c = this.getConstructor(i)
            const ct = c.getType()
            if (ct.getParametersNum() == args.length) {
                let ok = true
                for (let arg = 0; arg < args.length; arg++) {
                    if (!ct.getParameter(arg).getType().assignableFrom(argTypes[arg])) {
                        ok = false
                        break
                    }
                }
                if (ok) {
                    ctors.push(c)
                }
            }
        }
        // inspect if constructor has a more specific one (O(n^2))
        for (let inspect = 0; inspect < ctors.length; inspect++) {
            const toRem = ctors.at(inspect)!.getType()
            let rem = false
            for (let c = 0; c < ctors.length; c++) {
                if (c == inspect) {
                    continue
                }
                rem = true
                const cur = ctors.at(c)!.getType()
                for (let a = 0; a < args.length; a++) {
                    if (!toRem.getParameter(a).getType().assignableFrom(cur.getParameter(a).getType())) {
                        rem = false;
                        break;
                    }
                }
                if (rem) {
                    break
                }
            }
            if (rem) {
                ctors.splice(inspect, 1)
                inspect--
            }
        }
        if (ctors.length != 1) {
            throw new Error("can't select consturctor: " + ctors.length + " left")
        }
        return ctors.at(0)!.invoke(null, args)!
    }

    // class.subTypeOf(U) means that `class extends U` or `class implements U`
    protected override subTypeOf(other: Type): boolean {
        if (super.subTypeOf(other)) {
            return true
        }
        // `this` is derived of `other` class?
        if (other instanceof ClassType) {
            let bt = this;
            while (!bt.equals(bt.getBaseType())) {
                if (bt.equals(other)) {
                    return true
                }
                bt = bt.getBaseType()
            }
            return false
        }
        // `this` implements `other` interface?
        if (other instanceof InterfaceType) {
            let iface = other as InterfaceType
            let ifaceNum = this.getInterfacesNum()
            for (let i = 0; i < ifaceNum; i++) {
                if (this.getInterface(i).hasSuperInterface(iface)) {
                    return true
                }
            }
        }
        return false
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return obj
    }
}

/**
 * Represents interface type
 */
export final class InterfaceType extends Type {
    public constructor() {}

    public constructor(td: TypeDesc) {
        this.td = td
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type
     *
     * @returns name of type
     */
    public override getName(): string {
        return TypeAPIGetTypeName(this.td)
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        // NOTE(shumilov-petr): not implemented
        return "interface{...}"
    }

    /**
     * Checks for equality this instance with provided object, treated as a InterfaceType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has InterfaceType and
     * their names are the same
     */
    public override equals(other: Type): boolean {
        return other instanceof InterfaceType && this.td == (other as InterfaceType).td
    }

    // `this` extends of `other` interface?
    protected override subTypeOf(other: Type): boolean {
        if (super.subTypeOf(other)) {
            return true
        }
        if (other instanceof InterfaceType) {
            return this.hasSuperInterface(other as InterfaceType)
        }
        return false
    }

    public getInterfacesNum(): long {
        return TypeAPIGetInterfacesNum(this.td)
    }

    public getInterface(i: long): InterfaceType {
        return Type.resolve(TypeAPIGetInterface(this.td, i))! as InterfaceType
    }

    /**
     * Returns number of methods of this interface
     * including static methods and methods of super interfaces
     * @example
     *
     * ```
     * class A {
     *     a(): void {}
     * }
     *
     * class B extends A {
     *     b(): void {}
     * }
     * ```
     * let bType interface type of B, then `bType.getMethodsNum()` returns at least 2
     * Note that Object class also super class of B
     * @returns number of methods
     */
    public getMethodsNum(): long {
        return TypeAPIGetMethodsNum(this.td)
    }

    /**
     * Returns ith Method of this interface
     *
     * @param i index (using flat semantic)
     *
     * @throws error when i greater then number of methods
     *
     * @returns ith method
     */
    public getMethod(i: long): Method {
        return TypeAPIGetMethod(this.td, i)
    }

    /**
     * Returns number of type parameters of this class
     *
     * @returns number of type parameters
     */
    public getTypeParametersNum(): long {
        // NOTE(shumilov-petr): not implemented
        throw new Error("Not implemented")
    }

    /**
     * Returns ith type parameter of this class
     *
     * @param i index
     *
     * @throws error then i greater then number of type parameters
     *
     * @returns NOTE(kirill-mitkin): we cannot return concrete type in this method
     */
    public getTypeParameter(i: long): Type {
        // NOTE(shumilov-petr): not implemented
        throw new Error("Not implemented")
    }

    internal hasSuperInterface(expected: InterfaceType): boolean {
        if (this.equals(expected)) {
            return true
        }
        return TypeAPIIsInheritedFrom(this.td, expected.td)
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return obj
    }
}

/**
 * Represents array type
 */
export final class ArrayType extends Type {
    private elemTD: TypeDesc

    public static readonly BOOLEAN_VAL: ArrayType   = new ArrayType(TypeAPIGetTypeDescriptor(new boolean[0]), ValueTypeDesc.BOOLEAN)
    public static readonly BOOLEAN_REF: ArrayType   = new ArrayType(TypeAPIGetTypeDescriptor(new Boolean[0]), TypeAPIGetTypeDescriptor(new Boolean()))
    public static readonly CHAR_VAL: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new char[0]), ValueTypeDesc.CHAR)
    public static readonly CHAR_REF: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new Char[0]), TypeAPIGetTypeDescriptor(new Char()))
    public static readonly BYTE_VAL: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new byte[0]), ValueTypeDesc.BYTE)
    public static readonly BYTE_REF: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new Byte[0]), TypeAPIGetTypeDescriptor(new Byte()))
    public static readonly SHORT_VAL: ArrayType     = new ArrayType(TypeAPIGetTypeDescriptor(new short[0]), ValueTypeDesc.SHORT)
    public static readonly SHORT_REF: ArrayType     = new ArrayType(TypeAPIGetTypeDescriptor(new Short[0]), TypeAPIGetTypeDescriptor(new Short()))
    public static readonly INT_VAL: ArrayType       = new ArrayType(TypeAPIGetTypeDescriptor(new int[0]), ValueTypeDesc.INT)
    public static readonly INT_REF: ArrayType       = new ArrayType(TypeAPIGetTypeDescriptor(new Int[0]), TypeAPIGetTypeDescriptor(new Int()))
    public static readonly LONG_VAL: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new long[0]), ValueTypeDesc.LONG)
    public static readonly LONG_REF: ArrayType      = new ArrayType(TypeAPIGetTypeDescriptor(new Long[0]), TypeAPIGetTypeDescriptor(new Long()))
    public static readonly FLOAT_VAL: ArrayType     = new ArrayType(TypeAPIGetTypeDescriptor(new float[0]), ValueTypeDesc.FLOAT)
    public static readonly FLOAT_REF: ArrayType     = new ArrayType(TypeAPIGetTypeDescriptor(new Float[0]), TypeAPIGetTypeDescriptor(new Float()))
    public static readonly DOUBLE_VAL: ArrayType    = new ArrayType(TypeAPIGetTypeDescriptor(new double[0]), ValueTypeDesc.DOUBLE)
    public static readonly DOUBLE_REF: ArrayType    = new ArrayType(TypeAPIGetTypeDescriptor(new Double[0]), TypeAPIGetTypeDescriptor(new Double()))

    private constructor(td: TypeDesc, elemTD: TypeDesc) {
        this.td = td
        this.elemTD = elemTD
    }

    public override assignableFrom(other: Type): boolean {
        if (super.assignableFrom(other)) {
            return true
        }
        return other instanceof ArrayType && (other as ArrayType).getElementType().subTypeOf(this.getElementType())
    }

    internal static getInstance(td: TypeDesc, elemTD: TypeDesc): ArrayType {
        let ek = (TypeAPIGetTypeKind(elemTD) & TypeKindMask) as byte
        switch (ek) {
            case TypeKind.BOOLEAN:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.BOOLEAN_VAL : ArrayType.BOOLEAN_REF
            case TypeKind.CHAR:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.CHAR_VAL : ArrayType.CHAR_REF
            case TypeKind.BYTE:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.BYTE_VAL : ArrayType.BYTE_REF
            case TypeKind.SHORT:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.SHORT_VAL : ArrayType.SHORT_REF
            case TypeKind.INT:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.INT_VAL : ArrayType.INT_REF
            case TypeKind.LONG:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.LONG_VAL : ArrayType.LONG_REF
            case TypeKind.FLOAT:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.FLOAT_VAL : ArrayType.FLOAT_REF
            case TypeKind.DOUBLE:
                return (TypeAPIIsValueType(elemTD)) ? ArrayType.DOUBLE_VAL : ArrayType.DOUBLE_REF
            case TypeKind.CLASS:
            case TypeKind.STRING:
            case TypeKind.INTERFACE:
            case TypeKind.ARRAY:
            case TypeKind.TUPLE:
            case TypeKind.LAMBDA:
            case TypeKind.METHOD:
            case TypeKind.UNION:
                return new ArrayType(td, elemTD)
            default:
                // NOTE(shumilov-petr): need throw exception
                assert(false)
        }

        throw new Error("Invalid object")
    }

    internal static getInstance(td: TypeDesc): ArrayType {
        return ArrayType.getInstance(td, TypeAPIGetArrayElementType(td))
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return false
    }

    /**
     * Returns name of type
     *
     * @throws error in case of absence of name
     *
     * @returns name of type
     */
    public override getName(): string {
        return ""
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        return this.getElementType().toString() + "[]"
    }

    /**
     * Checks for equality this instance with provided object, treated as a ArrayType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has ArrayType and
     * their element types are the same
     */
    public override equals(other: Type): boolean {
        return other instanceof ArrayType && (other as ArrayType).getElementType().equals(this.getElementType())
    }

    /**
     * Returns element type of this array
     *
     * @returns element type
     */
    public getElementType(): Type {
        return Type.resolve(this.elemTD)!
    }

    /**
     * Makes instance of this array with provided length
     * Each element are instantiated using default value
     * If element type is class value then empty constructor are called
     *
     * @param length of array
     *
     * @throws error if element type doesn't have default value
     *
     * @returns new instance of array
     */
    public make(length: long): Object {
        return TypeAPIMakeArrayInstance(this.elemTD, length)
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return obj
    }
}

export final class TupleType extends Type {
    public constructor(td: TypeDesc) {
        this.td = td
    }

    public override isPrimitive(): boolean {
        throw new Error("Not implemented")
    }

    public override isReference(): boolean {
        throw new Error("Not implemented")
    }

    public override hasName(): boolean {
        throw new Error("Not implemented")
    }

    public override getName(): string {
        throw new Error("Not implemented")
    }

    public override getLiteral(): string {
        throw new Error("Not implemented")
    }

    public override equals(other: Type): boolean {
        throw new Error("Not implemented")
    }

    internal override convertObject(obj: NullishType): NullishType {
        throw new Error("todo(kprokopenko): add when tuple becomes available")
    }
}

/**
 * Represents function type
 *
 * @note lambdas, functions and methods have function type
 */
export abstract class FunctionType extends Type {
    private readonly attrs: int

    protected constructor(td: TypeDesc) {
        this.td = td
        this.attrs = TypeAPIGetFunctionAttributes(td)
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return false
    }

    /**
     * Returns name of type
     *
     * @returns name of type
     */
    public override getName(): string {
        return ""
    }

    /**
     * Returns return type of function type
     *
     * @returns result type
     */
    public getResultType(): Type {
        return Type.resolve(TypeAPIGetResultType(this.td))!
    }

    /**
     * Checks whether function type throws some exception
     *
     * @returns true if function type throws some exception
     */
    public isThrowing(): boolean {
        return (this.attrs & Attributes.THROWING) != 0
    }

    /**
     * Checks whether function type has native modifier
     *
     * @returns true if function type has native modifier
     */
    public isNative(): boolean {
        return (this.attrs & Attributes.NATIVE) != 0
    }

    /**
     * Checks whether function type has async modifier
     *
     * @returns true if function type has async modifier
     */
    public isAsync(): boolean {
        return (this.attrs & Attributes.ASYNC) != 0
    }

    /**
     * Checks whether function result type is never
     *
     * @returns true if function result type is never
     */
    public isNeverResult(): boolean {
        return (this.attrs & Attributes.NEVERRESULT) != 0
    }

    /**
     * Checks for equality this instance with provided object, treated as a FunctionType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has FunctionType and
     * they both has same signatures
     */
    public override equals(other: Type): boolean {
        return (other instanceof FunctionType) && (other as FunctionType).td == this.td
    }

    /**
     * Returns number of parameters
     * For static methods reciever type counted as parameter
     * For instance methods reciever type isn't counted as parameter
     *
     * @returns number of parameters
     */
    public getParametersNum(): long {
        return TypeAPIGetParametersNum(this.td)
    }

    /**
     * Returns ith parameter of function type
     *
     * @return Parameter, corresponding ith parameter in signature
     */
    public getParameter(i: long): Parameter {
        return TypeAPIGetParameter(this.td, i)
    }

    /**
     * Returns number of type parameters of this class
     *
     * @returns number of type parameters
     */
    public getTypeParametersNum(): long {
        // NOTE(shumilov-petr): not implemented
        return 0
    }

    /**
     * Returns ith type parameter of this class
     *
     * @param i index
     *
     * @throws error then i greater then number of type parameters
     *
     * @returns NOTE(kirill-mitkin): we cannot return concrete type in this method
     */
    public getTypeParameter(i: long): Type {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }
}


export final class LambdaType extends FunctionType {
    public constructor(td: TypeDesc) {
        super(td)
    }

    public override getLiteral(): string {
        let sb = new StringBuilder("(")
        const paramsNum = this.getParametersNum()
        for (let i = 0; i < paramsNum; ++i) {
            sb.append(this.getParameter(i).toString())
            if (i != paramsNum - 1) {
                sb.append(", ")
            }
        }
        sb.append("): ")
        sb.append(this.getResultType().toString())
        return sb.toString()
    }

    /**
     * Make an instance of LambdaType
     *
     * @returns LambdaType instance
     */
    public make(): Object {
        // NOTE(kprokopenko): not implemented
        throw new Error("Not implemented")
    }

    public override assignableFrom(other: Type): boolean {
        if (super.assignableFrom(other)) {
            return true
        }
        if (!(other instanceof LambdaType)) {
            return false
        }
        let l = (this)
        let r = other as LambdaType
        if (l.getParametersNum() != r.getParametersNum()) {
            return false
        }
        // Parameter types are using contravariance
        for (let i = 0; i < l.getParametersNum(); i++) {
            let lt = l.getParameter(i).getType()
            let rt = r.getParameter(i).getType()
            if (!lt.subTypeOf(rt)) {
                return false
            }
        }
        // Return types are using covariance
        return r.getResultType().subTypeOf(l.getResultType())
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        // NOTE(shumilov-petr): Need to use Create API
        throw new Error("todo(kprokopenko): unequal labmda type conversion")
    }
}


export final class MethodType extends FunctionType {
    public constructor(td: TypeDesc) {
        super(td)
    }

    public override getLiteral(): string {
        let sb = new StringBuilder("(this: ")
        sb.append(this.getReceiverType().toString())
        const paramsNum = this.getParametersNum()
        if (paramsNum > 0) {
            sb.append(", ")
        }
        for (let i = 0; i < paramsNum; ++i) {
            sb.append(this.getParameter(i).toString())
            if (i != paramsNum - 1) {
                sb.append(", ")
            }
        }
        sb.append("): ")
        sb.append(this.getResultType().toString())
        return sb.toString()
    }

    public getReceiverType(): Type {
        return Type.resolve(TypeAPIGetReceiverType(this.td))!
    }

    public override assignableFrom(other: Type): boolean {
        return false
    }

    internal override convertObject(obj: NullishType): NullishType {
        throw new Error("Only LambdaType can be converted")
    }
}

/**
 * Represents string type
 */
export final class StringType extends Type {
    public static readonly REF: StringType = new StringType()

    internal constructor() {
        this.td = TypeAPIGetTypeDescriptor("")
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return true
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return false
    }

    /**
     * Returns name of type
     *
     * @returns type name
     */
    public override getName(): string {
        // NOTE(shumilov-petr): not implemented
        return ""
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        // NOTE(shumilov-petr): not implemented
        return "string"
    }


    /**
     * Checks for equality this instance with provided object, treated as a StringType
     *
     * @param other object to be checked against
     *
     * @returns true if object also has StringType
     */
    public override equals(other: Type): boolean {
        return other instanceof StringType
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (!this.equals(objType)) {
            throw new Error("invalid conversion")
        }
        return obj
    }
}

/**
 * Represents enum type
 */
export final class EnumType extends Type {
    internal constructor(td: TypeDesc) {
        this.td = td
    }

    public override assignableFrom(other: Type): boolean {
        if (super.assignableFrom(other)) {
            return true
        }
        if (!(other instanceof EnumType)) {
            return false
        }
        let rt = other as EnumType
        return this.getName() == rt.getName()
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return false
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return true
    }

    /**
     * Returns name of type
     *
     * @returns type name
     */
    public override getName(): string {
        // NOTE(shumilov-petr): not implemented
        return ""
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        // NOTE(shumilov-petr): not implemented
        return "enum {...}"
    }

    /**
     * Checks for equality this instance with provided object, treated as a EnumType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has EnumType and their names are the same
     */
    public override equals(other: Type): boolean {
        // NOTE(shumilov-petr): not implemented
        return false
    }

    public getConstantsNum(): long {
        // NOTE(shumilov-petr): not implemented
        return 0
    }

    public getConstant(i: long): EnumConstant {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    public getConstantByName(name: string): EnumConstant {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    public create(consts: EnumConstant[]): EnumType {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    public make(constantName: string): Object {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    internal override convertObject(obj: NullishType): NullishType {
        throw new Error("todo(kprokopenko): enum conversion")
    }
}

/**
 * Represents union type
 */
export final class UnionType extends Type {
    internal constructor(td: TypeDesc) {
        this.td = td
    }

    public override assignableFrom(other: Type): boolean {
        if (other instanceof UnionType) {
            const otherUnion = other as UnionType
            // all cases of other are assignable into this
            const otherCasesN = this.getCasesNum()
            for (let i = 0; i < otherCasesN; i++) {
                let cas = otherUnion.getCase(i)
                if (!this.assignableFrom(cas.getType())) {
                    return false
                }
            }
            return true
        }
        // assignable to any case
        const selfCasesN = this.getCasesNum()
        for (let i = 0; i < selfCasesN; i++) {
            let cas = this.getCase(i)
            if (cas.getType().assignableFrom(other)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks whether type is primitive or composite
     *
     * @returns true if type is primitive and false otherwise
     */
    public override isPrimitive(): boolean {
        return false
    }

    /**
     * Checks whether type is reference or composite
     *
     * @returns true if type is reference and false otherwise
     */
    public override isReference(): boolean {
        return true
    }

    /**
     * Checks whether type has name
     *
     * @returns true if type has name
     */
    public override hasName(): boolean {
        return false
    }

    /**
     * Returns name of type
     *
     * @returns type name
     */
    public override getName(): string {
        // NOTE(shumilov-petr): not implemented
        return ""
    }

    /**
     * Returns literal of type if exists
     *
     * @returns type literal
     */
    public override getLiteral(): string {
        // NOTE(shumilov-petr): not implemented
        return "(... | ...)"
    }

    public getCasesNum(): long {
        // NOTE(kirill-mitkin): not implemented
        return 0
    }

    public getCase(i: long): UnionCase {
        // NOTE(kirill-mitkin): not implemented
        throw new Error("Not implemented")
    }

    /**
     * Checks for equality this instance with provided object, treated as a UnionType
     *
     * @param other type to be checked against
     *
     * @returns true if object also has UnionType and their cases are the same
     */
    public override equals(other: Type): boolean {
        // NOTE(shumilov-petr): not implemented
        return false
    }

    public make(defaultType: Type): Object {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    public make(defaultValue: Value): Object {
        // NOTE(shumilov-petr): not implemented
        throw new Error("not implemented")
    }

    internal override convertObject(obj: NullishType): NullishType {
        const objType = Type.of(obj)
        if (this.equals(objType)) {
            return obj
        }
        if (!this.assignableFrom(objType)) {
            throw new Error("invalid conversion")
        }
        return obj
    }
}
