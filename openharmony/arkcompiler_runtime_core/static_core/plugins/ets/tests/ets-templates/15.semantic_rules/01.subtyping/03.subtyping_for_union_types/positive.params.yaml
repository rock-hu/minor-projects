# Copyright (c) 2025 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - doc: |-
          Union type U (U1 | ... | Un) is a subtype of union type V (V1 | ... | Vm) if
          there is at least one type Vj (i in 1..m) for every type Ui (i in 1..n), i.e., Ui
          is a subtype of Vj (see Subtyping).
      decl: |-
          let a: string | number | boolean = "abc"
          let b: string | number = 42
          a = b // OK, u2 is wider
    - doc: |-
          Union type U (U1 | ... | Un) is a subtype of union type V (V1 | ... | Vm) if
          there is at least one type Vj (i in 1..m) for every type Ui (i in 1..n), i.e., Ui
          is a subtype of Vj (see Subtyping).
      decl: |-
          class Base {}
          class Derived extends Base {}
          
          let x: Base | string = new Base
          let y: Derived | string = "just a test"
          x = y // OK, Derived is subtype of Base
    - doc: |-
          Non-union type T is a subtype of union type U (U1 | ... | Un) if T is assignable to a type of Ui
      decl: |-
          let u: number | string = 1 // ok
          u = "aa" // ok
          u = 1 // ok, int is converted to number
    - doc: |-
          Union type U (U1 | ... | Un) is a subtype of non-union type T if each Ui
          is a subtype of T.
      decl: |-
          let a: "1" | "2" = "1"
          let b: string = a // ok, literals fit type 'string'
    - doc: |-
          If union type normalization produces a single type, then this type is used
          instead of the initial set of union types.
      decl: |-
          let u: "abc" | "cde" | string // type of 'u' is string
          u = "xyz"
