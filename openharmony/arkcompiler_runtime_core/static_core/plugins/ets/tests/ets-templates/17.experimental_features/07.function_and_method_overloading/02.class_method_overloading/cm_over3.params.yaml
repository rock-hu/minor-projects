# Copyright (c) 2021-2024 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - decl: |-
          // method overloaded with multiple parameters with different types
          class A {
              m(): int { return 0 }
              m(i: int): int { return 1 }
              m(i: int, j: int): int { return i + j }
              m(i: int, j: int, k: int): int { return 3 }
              m(i: int, j: double): double { return j + i }
              m(i: int, j: int, k: double): int { return 21 }
              m(i: double, j: double, k: int): int { return 31 }
              m(i: string, j: double): string { return i + j }
          }
      use: |-
          let a: A = new A()
          assert a.m() == 0
          assert a.m(42) == 1
          assert a.m(12, 55) == 67
          assert a.m(12, 55, 42) == 3
          assert a.m(61, 2.0) == 63.0
          assert a.m(11, 12, 15e23) == 21
          assert a.m(2.011e12, 1.98, 88) == 31
          assert a.m("abc", 18.0) == "abc18"

    - decl: |-
          // method overloaded with optional parameters
          class A {
              m(a: Object): int { return 1 }
              m(p: int, a: Object): int { return 2 }
              m(p: int, a: Object, b?: Object): int { return 3 }
              m(p: int, a?: Object, b?: Object, c: Object = new Error()): int { return 4 }
          }
      use: |-
          let a: A = new A()
          assert a.m(a) == 1
          assert a.m(1) == 4
          assert a.m(1, a) == 2
          assert a.m(1, a, a) == 3
          assert a.m(1, a, a, a) == 4

    - decl: |-
          // method overloaded with boxing/unboxing parameters
          class A {
              m(a: boolean): number { return 1.0 }
              m(a: Boolean): number { return 2.0 }
              m(a: boolean, b: number): number { return 3.0 }
              m(a: boolean, b: Number): number { return 4.0 }
              m(a: Boolean, b: Number): number { return 5.0 }
          }
      use: |-
          let a = new A()
          assert a.m(true) == 1.0
          assert a.m(new Boolean()) == 2.0
          assert a.m(true, 1.0) == 3.0
          assert a.m(false, new Double()) == 4.0
          assert a.m(new Boolean(), new Double()) == 5.0

    - decl: |-
          // method overloaded with rest parameters
          class A {
              m(a: Error, b: Object[]): int { return 1 }
              m(a: Error, ...b: Object[]): int { return 2 }
              m(a: Error, b: Error, ...c: Object[]): int { return 3 }
              m(a: Error, b: Object, c: Object, d: Object): int { return 4 }
          }
      use: |-
          let a: A = new A()
          assert a.m(new Error(), new Object[1]) == 1
          assert a.m(new Error(), new Long(), new Error()) == 2
          assert a.m(new Error(), new Error()) == 3
          assert a.m(new Error(), new Object(), new Object(), new Object()) == 4

    - decl: |-
          // method overloaded with type variables
          class X {}
          class Y {}
          class A<T, U> {
              m(a: T): int { return 1 }
              m(a: T, b: U): int { return 2 }
              m(a: U, b: T, c: U): int { return 3 }
          }
      use: |-
          let a: A<X, Y> = new A<X, Y>()
          assert a.m(new X()) == 1
          assert a.m(new X(), new Y()) == 2
          assert a.m(new Y(), new X(), new Y()) == 3

    - decl: |-
          // method overloaded with multiple parameters with dependent types
          class X {}
          class Y extends X {}
          class Z extends Y {}
          class A {
              m(a: X, b: Y, c: Z): int { return 1 }
              m(a: Y, b: Y, c: Y): int { return 2 }
              m(a: X, b: Y): int { return 3 }
              m(a: Y, b: Y): int { return 4 }
              m(a: X): int { return 5 }
              m(a: Y): int { return 6 }
          }
      use: |-
          let x: X = new X()
          let y: Y = new Y()
          let z: Z = new Z()
          let a: A = new A()
          assert a.m(x) == 5
          assert a.m(y) == 6
          assert a.m(z) == 6
          assert a.m(x, y) == 3
          assert a.m(y, y) == 4
          assert a.m(z, z) == 4
          assert a.m(x, y, z) == 1
          assert a.m(y, y, y) == 2
          assert a.m(z, z, y) == 2
