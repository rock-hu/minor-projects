/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
    This file was generated by VMB using these parameters:

        Benchmarks Class:     $state_name
        Bench Setup:          $state_setup
        Bench Method:         $method_name -> $method_rettype
        Parameter Set:        #$fix_id $fixture
        Bench Full Name:      $bench_name
        WarmUp Iterations:    $wi
        Measure Iterations:   $mi
        Iteration Time (sec): $it
        Warmup Time (sec):    $wt
        Fast Iterations:      $fi
        GC pause (ms):        $gc
*/

package $bench_name;

$imports

$common

$src

let WI: int = $wi;
let MI: int = $mi;
let IT: int = $it;
let WT: int = $wt;
let FI: int = $fi;
let SYS_GC_PAUSE: int = $gc;

function log(msg: String): void {
    // timestamp is needed by GC parser
    let now: long = Date.now() as long;
    console.info(now + " " + msg);
}

function doGC(): void throws {
    if (SYS_GC_PAUSE >= 0) {
        log("Force GC");
        let gc = GC.startGC(GC.Cause.FULL);
        GC.waitForFinishGC(gc);
        log("Force GC");
        gc = GC.startGC(GC.Cause.FULL);
        GC.waitForFinishGC(gc);
        // No sleep in ETS: sleep(SYS_GC_PAUSE)
    }
}

const MAX_LOOP_COUNT: long = 1_000_000_000;
const MS2NS: long = 1_000_000;
const S2MS: long = 1_000;

let loopCount1: long = 0;

let totalOps: long = 0;
let totalMs: long = 0;
let iter: int = 0;

function runIters(phase: String, count: int, time: int, bench: $state_name): void throws {
    let iterMs: long = time * S2MS;
    totalOps = 0;
    totalMs = 0;

    for (let k: int = 0; k < count; k++) {
        let ops: long = 0;
        let elapsedMs: long = 0;
        doGC();
        let start: long = Date.now() as long;
        while (elapsedMs < iterMs) {
            for (let i: long = 0; i < loopCount1; i++) {
                $method_call
            }
            elapsedMs = (Date.now() as long) - start;
            ops += loopCount1;
        }
        totalOps += ops;
        totalMs += elapsedMs;
        log(phase + " " + iter + ":" + ops + " ops, " + 1.0*elapsedMs*MS2NS/ops + " ns/op");
        iter++
    }
}

function main(): void throws {
    let bench: $state_name = new $state_name();
    log("Startup execution started: " + (Date.now() as long));

    $state_params
    $state_setup

    if (FI > 0) {
        log('Fast starting $bench_name @ ${fixture}...');
        let start: long = Chrono.nanoNow();
        for(let i: int = 0; i < FI; i++) {
            $method_call
        }
        let elapsed: long = Chrono.nanoNow() - start;
        if (elapsed <= 0) {
            elapsed = 1;  // 0 is invalid result
        }
        log("Benchmark result: $bench_name " + 1.0*elapsed/FI);
        Consumer.consume(bench);
        return;
    }

    log('Starting $bench_name @ ${fixture}...');

    let iterMs: long = 1 * S2MS;
    let loopMs: long = 0;
    let loopCount: long = 1;

    while (loopMs < iterMs && loopCount < MAX_LOOP_COUNT) {
        loopCount = loopCount * 2;
        let start: long = Date.now() as long;
        for (let i = 0; i < loopCount; i++) {
            $method_call
        }
        loopMs = (Date.now() as long) - start;
    }

    loopCount1 = loopCount * iterMs / loopMs;
    if (loopCount1 == 0) {
        loopCount1++;
    }

    log("Tuning: " +  loopCount + " ops, " + 1.0*loopMs*MS2NS/loopCount + " ns/op => "
        + loopCount1 + " reps");

    if (WI > 0) {
        iter = 1;
        // Re-entering runIters in warmup loop to allow profiler complete the method.
        // Possible deoptimizations and recompilations is done in warmup instead of measure phase.
        for (let wi: int = 0; wi < WI; ++wi) {
            runIters("Warmup", 1, WT, bench);
        }
    }
    iter = 1;
    runIters("Iter", MI, IT, bench);
    log("Benchmark result: $bench_name " + 1.0*totalMs*MS2NS/totalOps);


    Consumer.consume(bench);

}

class Consumer {
    public static readonly x1: long = 0x41c64e6d;
    public static readonly x2: long = 0xd431;
    private static x3: long = 1;
    public static boola: boolean = false;
    public static boolb: boolean = true;
    public static chara: char = 88;  // 'X'
    public static charb: char = 89;  // 'Y'
    public static stra: string = 'X';
    public static strb: string = 'Y';
    public static bytea: byte = 24;
    public static byteb: byte = 53;
    public static shorta: short = 24;
    public static shortb: short = 53;
    public static inta: int = 24;
    public static intb: int = 53;
    public static longa: long = 24;
    public static longb: long = 53;
    public static floata: float = 24.0;
    public static floatb: float = 53.0;
    public static doublea: double = 24.0;
    public static doubleb: double = 53.0;
    public static localObj = new Object();
    public static localObjs: Object[] = [new Object()];
    public static pseudorand: long = Date.now() as long;

    public static consumeBool(boolc: boolean): void throws {
        if (boolc == Consumer.boola && boolc == Consumer.boolb) {
            throw new NullPointerError();
        }
    }

    public static consumeChar(charc: char): void throws {
        if (charc == Consumer.chara && charc == Consumer.charb) {
            throw new NullPointerError();
        }
    }

    public static consumeByte(bytec: byte): void throws {
        if (bytec == Consumer.bytea && bytec == Consumer.byteb) {
            throw new NullPointerError();
        }
    }

    public static consumeShort(shortc: short): void throws {
        if (shortc == Consumer.shorta && shortc == Consumer.shortb) {
            throw new NullPointerError();
        }
    }

    public static consumeInt(intc: int): void throws {
        if (intc == Consumer.inta && intc == Consumer.intb) {
            throw new NullPointerError();
        }
    }

    public static consumeLong(longc: long): void throws {
        if (longc == Consumer.longa && longc == Consumer.longb) {
            throw new NullPointerError();
        }
    }

    public static consumeFloat(floatc: float): void throws {
        if (floatc == Consumer.floata && floatc == Consumer.floatb) {
            throw new NullPointerError();
        }
    }

    public static consumeDouble(doublec: double): void throws {
        if (doublec == Consumer.doublea && doublec == Consumer.doubleb) {
            throw new NullPointerError();
        }
    }

    public static consumeObj(obj: Object): void throws {
        Consumer.pseudorand = (Consumer.pseudorand * Consumer.x1 + Consumer.x2);
        if ((Consumer.pseudorand & Consumer.x3) == 0) {
            Consumer.x3 = (Consumer.x3 << 1) + (0xad as long);
            Consumer.localObj = obj;
        }
    }

    public static consumeString(strc: string): void throws {
        if (strc === Consumer.stra && strc === Consumer.strb) {
            throw new NullPointerError();
        }
    }

    public static consumeObjs(objs: Object[]): void throws {
        Consumer.pseudorand = (Consumer.pseudorand * Consumer.x1 + Consumer.x2);
        if ((Consumer.pseudorand & Consumer.x3) == 0) {
            Consumer.x3 = (Consumer.x3 << 1) + (0xad as long);
            Consumer.localObjs = objs;
        }
    }

    public static consume(v: boolean): void throws {
        Consumer.consumeBool(v);
    }

    public static consume(v: byte): void throws {
        Consumer.consumeByte(v);
    }

    public static consume(v: char): void throws {
        Consumer.consumeChar(v);
    }

    public static consume(v: short): void throws {
        Consumer.consumeShort(v);
    }

    public static consume(v: int): void throws {
        Consumer.consumeInt(v);
    }

    public static consume(v: long): void throws {
        Consumer.consumeLong(v);
    }

    public static consume(v: float): void throws {
        Consumer.consumeFloat(v);
    }

    public static consume(v: double): void throws {
        Consumer.consumeDouble(v);
    }

    public static consume(v: Object): void throws {
        Consumer.consumeObj(v);
    }

    public static consume(v: Object[]): void throws {
        Consumer.consumeObjs(v);
    }

}
