/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// WARNING! THIS FILE IS AUTO-GENERATED, DO NOT MAKE CHANGES, THEY WILL BE LOST ON NEXT GENERATION!

import { SerializerBase, DeserializerBase, Finalizable, runtimeType, RuntimeType, registerCallback, wrapCallback, toPeerPtr, KPointer, MaterializedBase, NativeBuffer, nullptr, KInt, KBoolean, KStringPtr, CallbackResource, InteropNativeModule, Tags, KSerializerBuffer, KUint8ArrayPtr } from "@koalaui/interop"
import { TypeChecker, ArkUIGeneratedNativeModule } from "#components"
import { unsafeCast, int32, int64, float32 } from "@koalaui/common"
import { CallbackKind } from "./../generated/peers/CallbackKind"
import { CallbackTransformer } from "./../CallbackTransformer"
import { unifiedDataChannel_Summary_serializer, unifiedDataChannel } from "./../generated/ohos.data.unifiedDataChannel"
import { DrawContext, DrawContextInternal, LengthMetrics_serializer, LengthMetrics } from "./../generated/arkui.Graphics"
import { KeyType, KeySource, Color, HitTestMode, ImageSize, Alignment, BorderStyle, ColoringStrategy, HoverEffect, Visibility, ItemAlign, Direction, ObscuredReasons, RenderFit, FocusDrawLevel, ImageRepeat, Axis, ResponseType, FunctionKey, ModifierKey, InteractionHand, GradientDirection, SharedTransitionEffectType, ArrowPointPosition, Placement, LineCapStyle, LineJoinStyle, BarState, CrownSensitivity, EdgeEffect, TransitionType, TextDecorationType, TextDecorationStyle, PlayMode, HorizontalAlign, VerticalAlign, FontWeight, FontStyle, TouchType, CrownAction, ClickEffectLevel, NestedScrollMode, PixelRoundCalcPolicy, ScrollSource, IlluminatedType, AccessibilityHoverType, AxisAction, AxisModel, MouseButton, MouseAction } from "./enums"
import { IntentionCode } from "./../generated/ohos.multimodalInput.intentionCode"
import { Position_serializer, DirectionalEdgesT_serializer, Position, DirectionalEdgesT, ConstraintSizeOptions_serializer, ConstraintSizeOptions, ResourceColor, SizeOptions, SizeOptions_serializer, ChainWeightOptions_serializer, Padding_serializer, LocalizedPadding_serializer, BorderOptions_serializer, EdgeStyles_serializer, EdgeWidths_serializer, LocalizedEdgeWidths_serializer, EdgeColors_serializer, LocalizedEdgeColors_serializer, BorderRadiuses_serializer, LocalizedBorderRadiuses_serializer, OutlineOptions_serializer, EdgeOutlineStyles_serializer, EdgeOutlineWidths_serializer, OutlineRadiuses_serializer, Edges_serializer, LocalizedEdges_serializer, LocalizedPosition_serializer, AccessibilityOptions_serializer, Length, ChainWeightOptions, Padding, LocalizedPadding, BorderOptions, EdgeStyles, EdgeWidths, LocalizedEdgeWidths, EdgeColors, LocalizedEdgeColors, BorderRadiuses, LocalizedBorderRadiuses, OutlineOptions, EdgeOutlineStyles, Dimension, EdgeOutlineWidths, OutlineRadiuses, VoidCallback, Area, Edges, LocalizedEdges, LocalizedPosition, ResourceStr, AccessibilityOptions, Bias, Font, Bias_serializer, Area_serializer, Font_serializer } from "./units"
import { Resource_serializer, Resource } from "./../generated/resource"
import { TextRange_serializer, TextRange } from "./textCommon"
import { ResizableOptions_serializer, ResizableOptions } from "./image"
import { uiEffect_VisualEffect_serializer, uiEffect_Filter_serializer, uiEffect_BrightnessBlender_serializer, uiEffect } from "./../generated/ohos.graphics.uiEffect"
import { FocusBoxStyle_serializer, FocusBoxStyle, FocusPriority } from "./focus"
import { CircleShape_serializer, EllipseShape_serializer, PathShape_serializer, RectShape_serializer, CircleShape, EllipseShape, PathShape, RectShape } from "./../generated/ohos.arkui.shape"
import { image_PixelMap_serializer, image } from "./../generated/ohos.multimedia.image"
import { Gesture_serializer, GestureInfo, BaseGestureEvent, GestureJudgeResult, GestureRecognizer, GestureType, Gesture, GestureMask, FingerInfo, GestureControl, GestureRecognizerState, EventTargetInfo, GestureHandler, GesturePriority } from "./gesture"
import { ComponentContent_serializer, ComponentContent } from "./../generated/arkui.ComponentContent"
import { StyledString_serializer, StyledString, ImageAttachment, CustomSpan, StyleOptions, StyledStringKey, SpanStyle, StyledStringMarshallCallback, UserDataSpan, StyledStringUnmarshallCallback } from "./styledString"
import { ComponentBase } from "./../ComponentBase"
import { PeerNode } from "./../PeerNode"
import { CustomBuilder } from "./builder"
import { uniformTypeDescriptor } from "./../generated/ohos.data.uniformTypeDescriptor"
import { curves, curves_ICurve_serializer } from "./../generated/ohos.curves"
import { SymbolGlyphModifier, SymbolGlyphModifier_serializer } from "./../generated/arkui.SymbolGlyphModifier"
import { UIContext, UIContext_serializer } from "./../generated/ohos.arkui.UIContext"
import { memo, memo_stable } from "@koalaui/runtime/annotations"
import { ComponentBuilder } from "@koalaui/builderLambda"
import { Context } from "./../generated/application.Context"
import { pointer } from "./../generated/ohos.multimodalInput.pointer"
import { ButtonType, ButtonStyleMode, ButtonRole } from "./button"
import { ContentModifier, CustomStyles, UICommonBase, AttributeModifier, AttributeUpdater } from "./../handwritten"
import { promptAction } from "./../generated/ohos.promptAction"
import { ScrollState } from "./list"
import { Want, Want_serializer } from "./../generated/ohos.app.ability.Want"
import { intl } from "./../generated/ohos.intl"
import { NodeAttach, remember } from "@koalaui/runtime"
import { GlobalScope } from "./../generated/GlobalScope"
export interface BaseEvent {
    target: EventTarget
    timestamp: number
    source: SourceType
    axisHorizontal?: number | undefined
    axisVertical?: number | undefined
    pressure: number
    tiltX: number
    tiltY: number
    rollAngle?: number | undefined
    sourceTool: SourceTool
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    deviceId?: number | undefined
    targetDisplayId?: number | undefined
}
export class BaseEventInternal implements MaterializedBase,BaseEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get target(): EventTarget {
        return this.getTarget()
    }
    set target(target: EventTarget) {
        this.setTarget(target)
    }
    get timestamp(): number {
        return this.getTimestamp()
    }
    set timestamp(timestamp: number) {
        this.setTimestamp(timestamp)
    }
    get source(): SourceType {
        return this.getSource()
    }
    set source(source: SourceType) {
        this.setSource(source)
    }
    get axisHorizontal(): number | undefined {
        return this.getAxisHorizontal()
    }
    set axisHorizontal(axisHorizontal: number | undefined) {
        const axisHorizontal_NonNull  = (axisHorizontal as number)
        this.setAxisHorizontal(axisHorizontal_NonNull)
    }
    get axisVertical(): number | undefined {
        return this.getAxisVertical()
    }
    set axisVertical(axisVertical: number | undefined) {
        const axisVertical_NonNull  = (axisVertical as number)
        this.setAxisVertical(axisVertical_NonNull)
    }
    get pressure(): number {
        return this.getPressure()
    }
    set pressure(pressure: number) {
        this.setPressure(pressure)
    }
    get tiltX(): number {
        return this.getTiltX()
    }
    set tiltX(tiltX: number) {
        this.setTiltX(tiltX)
    }
    get tiltY(): number {
        return this.getTiltY()
    }
    set tiltY(tiltY: number) {
        this.setTiltY(tiltY)
    }
    get rollAngle(): number | undefined {
        return this.getRollAngle()
    }
    set rollAngle(rollAngle: number | undefined) {
        const rollAngle_NonNull  = (rollAngle as number)
        this.setRollAngle(rollAngle_NonNull)
    }
    get sourceTool(): SourceTool {
        return this.getSourceTool()
    }
    set sourceTool(sourceTool: SourceTool) {
        this.setSourceTool(sourceTool)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    get deviceId(): number | undefined {
        return this.getDeviceId()
    }
    set deviceId(deviceId: number | undefined) {
        const deviceId_NonNull  = (deviceId as number)
        this.setDeviceId(deviceId_NonNull)
    }
    get targetDisplayId(): number | undefined {
        return this.getTargetDisplayId()
    }
    set targetDisplayId(targetDisplayId: number | undefined) {
        const targetDisplayId_NonNull  = (targetDisplayId as number)
        this.setTargetDisplayId(targetDisplayId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, BaseEventInternal.getFinalizer())
    }
    constructor() {
        this(BaseEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._BaseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): BaseEventInternal {
        return new BaseEventInternal(ptr)
    }
    private getTarget(): EventTarget {
        return this.getTarget_serialize()
    }
    private setTarget(target: EventTarget): void {
        const target_casted = target as (EventTarget)
        this.setTarget_serialize(target_casted)
        return
    }
    private getTimestamp(): number {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: number): void {
        const timestamp_casted = timestamp as (number)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getSource(): SourceType {
        return this.getSource_serialize()
    }
    private setSource(source: SourceType): void {
        const source_casted = source as (SourceType)
        this.setSource_serialize(source_casted)
        return
    }
    private getAxisHorizontal(): number | undefined {
        return this.getAxisHorizontal_serialize()
    }
    private setAxisHorizontal(axisHorizontal: number | undefined): void {
        const axisHorizontal_casted = axisHorizontal as (number | undefined)
        this.setAxisHorizontal_serialize(axisHorizontal_casted)
        return
    }
    private getAxisVertical(): number | undefined {
        return this.getAxisVertical_serialize()
    }
    private setAxisVertical(axisVertical: number | undefined): void {
        const axisVertical_casted = axisVertical as (number | undefined)
        this.setAxisVertical_serialize(axisVertical_casted)
        return
    }
    private getPressure(): number {
        return this.getPressure_serialize()
    }
    private setPressure(pressure: number): void {
        const pressure_casted = pressure as (number)
        this.setPressure_serialize(pressure_casted)
        return
    }
    private getTiltX(): number {
        return this.getTiltX_serialize()
    }
    private setTiltX(tiltX: number): void {
        const tiltX_casted = tiltX as (number)
        this.setTiltX_serialize(tiltX_casted)
        return
    }
    private getTiltY(): number {
        return this.getTiltY_serialize()
    }
    private setTiltY(tiltY: number): void {
        const tiltY_casted = tiltY as (number)
        this.setTiltY_serialize(tiltY_casted)
        return
    }
    private getRollAngle(): number | undefined {
        return this.getRollAngle_serialize()
    }
    private setRollAngle(rollAngle: number | undefined): void {
        const rollAngle_casted = rollAngle as (number | undefined)
        this.setRollAngle_serialize(rollAngle_casted)
        return
    }
    private getSourceTool(): SourceTool {
        return this.getSourceTool_serialize()
    }
    private setSourceTool(sourceTool: SourceTool): void {
        const sourceTool_casted = sourceTool as (SourceTool)
        this.setSourceTool_serialize(sourceTool_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getDeviceId(): number | undefined {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: number | undefined): void {
        const deviceId_casted = deviceId as (number | undefined)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getTargetDisplayId(): number | undefined {
        return this.getTargetDisplayId_serialize()
    }
    private setTargetDisplayId(targetDisplayId: number | undefined): void {
        const targetDisplayId_casted = targetDisplayId as (number | undefined)
        this.setTargetDisplayId_serialize(targetDisplayId_casted)
        return
    }
    private getTarget_serialize(): EventTarget {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTarget(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : EventTarget = EventTarget_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setTarget_serialize(target: EventTarget): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        EventTarget_serializer.write(thisSerializer, target)
        ArkUIGeneratedNativeModule._BaseEvent_setTarget(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTimestamp_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: number): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getSource_serialize(): SourceType {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSource(this.peer!.ptr)
        return TypeChecker.SourceType_FromNumeric(retval)
    }
    private setSource_serialize(source: SourceType): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSource(this.peer!.ptr, TypeChecker.SourceType_ToNumeric(source))
    }
    private getAxisHorizontal_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisHorizontal(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setAxisHorizontal_serialize(axisHorizontal: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let axisHorizontal_type : int32 = RuntimeType.UNDEFINED
        axisHorizontal_type = runtimeType(axisHorizontal)
        thisSerializer.writeInt8((axisHorizontal_type).toChar())
        if ((axisHorizontal_type) != (RuntimeType.UNDEFINED)) {
            const axisHorizontal_value  = axisHorizontal!
            thisSerializer.writeNumber(axisHorizontal_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisHorizontal(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getAxisVertical_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisVertical(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setAxisVertical_serialize(axisVertical: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let axisVertical_type : int32 = RuntimeType.UNDEFINED
        axisVertical_type = runtimeType(axisVertical)
        thisSerializer.writeInt8((axisVertical_type).toChar())
        if ((axisVertical_type) != (RuntimeType.UNDEFINED)) {
            const axisVertical_value  = axisVertical!
            thisSerializer.writeNumber(axisVertical_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisVertical(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressure_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getPressure(this.peer!.ptr)
        return retval
    }
    private setPressure_serialize(pressure: number): void {
        ArkUIGeneratedNativeModule._BaseEvent_setPressure(this.peer!.ptr, pressure)
    }
    private getTiltX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltX(this.peer!.ptr)
        return retval
    }
    private setTiltX_serialize(tiltX: number): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltX(this.peer!.ptr, tiltX)
    }
    private getTiltY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltY(this.peer!.ptr)
        return retval
    }
    private setTiltY_serialize(tiltY: number): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltY(this.peer!.ptr, tiltY)
    }
    private getRollAngle_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getRollAngle(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setRollAngle_serialize(rollAngle: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let rollAngle_type : int32 = RuntimeType.UNDEFINED
        rollAngle_type = runtimeType(rollAngle)
        thisSerializer.writeInt8((rollAngle_type).toChar())
        if ((rollAngle_type) != (RuntimeType.UNDEFINED)) {
            const rollAngle_value  = rollAngle!
            thisSerializer.writeNumber(rollAngle_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setRollAngle(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getSourceTool_serialize(): SourceTool {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSourceTool(this.peer!.ptr)
        return TypeChecker.SourceTool_FromNumeric(retval)
    }
    private setSourceTool_serialize(sourceTool: SourceTool): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSourceTool(this.peer!.ptr, TypeChecker.SourceTool_ToNumeric(sourceTool))
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const buffer__resource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer__call : KPointer = retvalDeserializer.readPointer()
            const buffer__callSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => { 
    const buffer__argsSerializer : SerializerBase = SerializerBase.hold();
    buffer__argsSerializer.writeInt32(buffer__resource.resourceId);
    buffer__argsSerializer.writePointer(buffer__call);
    buffer__argsSerializer.writePointer(buffer__callSync);
    buffer__argsSerializer.writeInt32((keys.length).toInt());
    for (let keys_counter_i = 0; keys_counter_i < keys.length; keys_counter_i++) {
        const keys_element : string = keys[keys_counter_i];
        buffer__argsSerializer.writeString(keys_element);
    }
    let buffer__continuationValue : boolean | undefined;
    const buffer__continuationCallback : ((value0: boolean) => void) = (value: boolean):void => {     buffer__continuationValue = value; }
    buffer__argsSerializer.holdAndWriteCallback(buffer__continuationCallback);
    InteropNativeModule._CallCallback(-1026503952, buffer__argsSerializer.asBuffer(), buffer__argsSerializer.length());
    buffer__argsSerializer.release();
    return (buffer__continuationValue as boolean); }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let getModifierKeyState_type : int32 = RuntimeType.UNDEFINED
        getModifierKeyState_type = runtimeType(getModifierKeyState)
        thisSerializer.writeInt8((getModifierKeyState_type).toChar())
        if ((getModifierKeyState_type) != (RuntimeType.UNDEFINED)) {
            const getModifierKeyState_value  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyState_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDeviceId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getDeviceId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setDeviceId_serialize(deviceId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let deviceId_type : int32 = RuntimeType.UNDEFINED
        deviceId_type = runtimeType(deviceId)
        thisSerializer.writeInt8((deviceId_type).toChar())
        if ((deviceId_type) != (RuntimeType.UNDEFINED)) {
            const deviceId_value  = deviceId!
            thisSerializer.writeNumber(deviceId_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setDeviceId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTargetDisplayId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTargetDisplayId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setTargetDisplayId_serialize(targetDisplayId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let targetDisplayId_type : int32 = RuntimeType.UNDEFINED
        targetDisplayId_type = runtimeType(targetDisplayId)
        thisSerializer.writeInt8((targetDisplayId_type).toChar())
        if ((targetDisplayId_type) != (RuntimeType.UNDEFINED)) {
            const targetDisplayId_value  = targetDisplayId!
            thisSerializer.writeNumber(targetDisplayId_value)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setTargetDisplayId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ChildrenMainSizeInternal {
    public static fromPtr(ptr: KPointer): ChildrenMainSize {
        return new ChildrenMainSize(false, ptr)
    }
}
export class ChildrenMainSize implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get childDefaultSize(): number {
        return this.getChildDefaultSize()
    }
    set childDefaultSize(childDefaultSize: number) {
        this.setChildDefaultSize(childDefaultSize)
    }
    constructor(_0: boolean, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ChildrenMainSize.getFinalizer())
    }
    constructor(childDefaultSize: number) {
        this(false, ChildrenMainSize.construct(childDefaultSize))
    }
    static construct(childDefaultSize: number): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ChildrenMainSize_construct(childDefaultSize)
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ChildrenMainSize_getFinalizer()
    }
    public splice(start: number, deleteCount?: number, childrenSize?: Array<number>): void {
        const start_casted = start as (number)
        const deleteCount_casted = deleteCount as (number | undefined)
        const childrenSize_casted = childrenSize as (Array<number> | undefined)
        this.splice_serialize(start_casted, deleteCount_casted, childrenSize_casted)
        return
    }
    public update(index: number, childSize: number): void {
        const index_casted = index as (number)
        const childSize_casted = childSize as (number)
        this.update_serialize(index_casted, childSize_casted)
        return
    }
    private getChildDefaultSize(): number {
        return this.getChildDefaultSize_serialize()
    }
    private setChildDefaultSize(childDefaultSize: number): void {
        const childDefaultSize_casted = childDefaultSize as (number)
        this.setChildDefaultSize_serialize(childDefaultSize_casted)
        return
    }
    private splice_serialize(start: number, deleteCount?: number, childrenSize?: Array<number>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let deleteCount_type : int32 = RuntimeType.UNDEFINED
        deleteCount_type = runtimeType(deleteCount)
        thisSerializer.writeInt8((deleteCount_type).toChar())
        if ((deleteCount_type) != (RuntimeType.UNDEFINED)) {
            const deleteCount_value  = deleteCount!
            thisSerializer.writeNumber(deleteCount_value)
        }
        let childrenSize_type : int32 = RuntimeType.UNDEFINED
        childrenSize_type = runtimeType(childrenSize)
        thisSerializer.writeInt8((childrenSize_type).toChar())
        if ((childrenSize_type) != (RuntimeType.UNDEFINED)) {
            const childrenSize_value  = childrenSize!
            thisSerializer.writeInt32((childrenSize_value.length).toInt())
            for (let childrenSize_value_counter_i = 0; childrenSize_value_counter_i < childrenSize_value.length; childrenSize_value_counter_i++) {
                const childrenSize_value_element : number = childrenSize_value[childrenSize_value_counter_i]
                thisSerializer.writeNumber(childrenSize_value_element)
            }
        }
        ArkUIGeneratedNativeModule._ChildrenMainSize_splice(this.peer!.ptr, start, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private update_serialize(index: number, childSize: number): void {
        ArkUIGeneratedNativeModule._ChildrenMainSize_update(this.peer!.ptr, index, childSize)
    }
    private getChildDefaultSize_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ChildrenMainSize_getChildDefaultSize(this.peer!.ptr)
        return retval
    }
    private setChildDefaultSize_serialize(childDefaultSize: number): void {
        ArkUIGeneratedNativeModule._ChildrenMainSize_setChildDefaultSize(this.peer!.ptr, childDefaultSize)
    }
}
export interface DismissPopupAction {
    reason: DismissReason
    dismiss(): void
}
export class DismissPopupActionInternal implements MaterializedBase,DismissPopupAction {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get reason(): DismissReason {
        return this.getReason()
    }
    set reason(reason: DismissReason) {
        this.setReason(reason)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DismissPopupActionInternal.getFinalizer())
    }
    constructor() {
        this(DismissPopupActionInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DismissPopupAction_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DismissPopupActionInternal {
        return new DismissPopupActionInternal(ptr)
    }
    public dismiss(): void {
        this.dismiss_serialize()
        return
    }
    private getReason(): DismissReason {
        return this.getReason_serialize()
    }
    private setReason(reason: DismissReason): void {
        const reason_casted = reason as (DismissReason)
        this.setReason_serialize(reason_casted)
        return
    }
    private dismiss_serialize(): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_dismiss(this.peer!.ptr)
    }
    private getReason_serialize(): DismissReason {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_getReason(this.peer!.ptr)
        return TypeChecker.DismissReason_FromNumeric(retval)
    }
    private setReason_serialize(reason: DismissReason): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_setReason(this.peer!.ptr, TypeChecker.DismissReason_ToNumeric(reason))
    }
}
export interface DragEvent {
    dragBehavior: DragBehavior
    useCustomDropAnimation: boolean
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    getDisplayX(): number
    getDisplayY(): number
    getWindowX(): number
    getWindowY(): number
    setData(unifiedData: unifiedDataChannel.UnifiedData): void
    getData(): unifiedDataChannel.UnifiedData
    getSummary(): unifiedDataChannel.Summary
    setResult(dragResult: DragResult): void
    getResult(): DragResult
    getPreviewRect(): Rectangle
    getVelocityX(): number
    getVelocityY(): number
    getVelocity(): number
    executeDropAnimation(customDropAnimation: (() => void)): void
}
export class DragEventInternal implements MaterializedBase,DragEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get dragBehavior(): DragBehavior {
        return this.getDragBehavior()
    }
    set dragBehavior(dragBehavior: DragBehavior) {
        this.setDragBehavior(dragBehavior)
    }
    get useCustomDropAnimation(): boolean {
        return this.getUseCustomDropAnimation()
    }
    set useCustomDropAnimation(useCustomDropAnimation: boolean) {
        this.setUseCustomDropAnimation(useCustomDropAnimation)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DragEventInternal.getFinalizer())
    }
    constructor() {
        this(DragEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DragEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DragEventInternal {
        return new DragEventInternal(ptr)
    }
    public getDisplayX(): number {
        return this.getDisplayX_serialize()
    }
    public getDisplayY(): number {
        return this.getDisplayY_serialize()
    }
    public getWindowX(): number {
        return this.getWindowX_serialize()
    }
    public getWindowY(): number {
        return this.getWindowY_serialize()
    }
    public setData(unifiedData: unifiedDataChannel.UnifiedData): void {
        const unifiedData_casted = unifiedData as (unifiedDataChannel.UnifiedData)
        this.setData_serialize(unifiedData_casted)
        return
    }
    public getData(): unifiedDataChannel.UnifiedData {
        return this.getData_serialize()
    }
    public getSummary(): unifiedDataChannel.Summary {
        return this.getSummary_serialize()
    }
    public setResult(dragResult: DragResult): void {
        const dragResult_casted = dragResult as (DragResult)
        this.setResult_serialize(dragResult_casted)
        return
    }
    public getResult(): DragResult {
        return this.getResult_serialize()
    }
    public getPreviewRect(): Rectangle {
        return this.getPreviewRect_serialize()
    }
    public getVelocityX(): number {
        return this.getVelocityX_serialize()
    }
    public getVelocityY(): number {
        return this.getVelocityY_serialize()
    }
    public getVelocity(): number {
        return this.getVelocity_serialize()
    }
    public executeDropAnimation(customDropAnimation: (() => void)): void {
        const customDropAnimation_casted = customDropAnimation as ((() => void))
        this.executeDropAnimation_serialize(customDropAnimation_casted)
        return
    }
    private getDragBehavior(): DragBehavior {
        return this.getDragBehavior_serialize()
    }
    private setDragBehavior(dragBehavior: DragBehavior): void {
        const dragBehavior_casted = dragBehavior as (DragBehavior)
        this.setDragBehavior_serialize(dragBehavior_casted)
        return
    }
    private getUseCustomDropAnimation(): boolean {
        return this.getUseCustomDropAnimation_serialize()
    }
    private setUseCustomDropAnimation(useCustomDropAnimation: boolean): void {
        const useCustomDropAnimation_casted = useCustomDropAnimation as (boolean)
        this.setUseCustomDropAnimation_serialize(useCustomDropAnimation_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getDisplayX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private getDisplayY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private getWindowX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private getWindowY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setData_serialize(unifiedData: unifiedDataChannel.UnifiedData): void {
        ArkUIGeneratedNativeModule._DragEvent_setData(this.peer!.ptr, toPeerPtr(unifiedData))
    }
    private getData_serialize(): unifiedDataChannel.UnifiedData {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getData(this.peer!.ptr)
        const obj : unifiedDataChannel.UnifiedData = unifiedDataChannel.UnifiedDataInternal.fromPtr(retval)
        return obj
    }
    private getSummary_serialize(): unifiedDataChannel.Summary {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getSummary(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : unifiedDataChannel.Summary = unifiedDataChannel_Summary_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setResult_serialize(dragResult: DragResult): void {
        ArkUIGeneratedNativeModule._DragEvent_setResult(this.peer!.ptr, TypeChecker.DragResult_ToNumeric(dragResult))
    }
    private getResult_serialize(): DragResult {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getResult(this.peer!.ptr)
        return TypeChecker.DragResult_FromNumeric(retval)
    }
    private getPreviewRect_serialize(): Rectangle {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getPreviewRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : Rectangle = Rectangle_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getVelocityX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityX(this.peer!.ptr)
        return retval
    }
    private getVelocityY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityY(this.peer!.ptr)
        return retval
    }
    private getVelocity_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocity(this.peer!.ptr)
        return retval
    }
    private executeDropAnimation_serialize(customDropAnimation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(customDropAnimation)
        ArkUIGeneratedNativeModule._DragEvent_executeDropAnimation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDragBehavior_serialize(): DragBehavior {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDragBehavior(this.peer!.ptr)
        return TypeChecker.DragBehavior_FromNumeric(retval)
    }
    private setDragBehavior_serialize(dragBehavior: DragBehavior): void {
        ArkUIGeneratedNativeModule._DragEvent_setDragBehavior(this.peer!.ptr, TypeChecker.DragBehavior_ToNumeric(dragBehavior))
    }
    private getUseCustomDropAnimation_serialize(): boolean {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getUseCustomDropAnimation(this.peer!.ptr)
        return retval
    }
    private setUseCustomDropAnimation_serialize(useCustomDropAnimation: boolean): void {
        ArkUIGeneratedNativeModule._DragEvent_setUseCustomDropAnimation(this.peer!.ptr, useCustomDropAnimation ? 1 : 0)
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const buffer__resource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer__call : KPointer = retvalDeserializer.readPointer()
            const buffer__callSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => { 
    const buffer__argsSerializer : SerializerBase = SerializerBase.hold();
    buffer__argsSerializer.writeInt32(buffer__resource.resourceId);
    buffer__argsSerializer.writePointer(buffer__call);
    buffer__argsSerializer.writePointer(buffer__callSync);
    buffer__argsSerializer.writeInt32((keys.length).toInt());
    for (let keys_counter_i = 0; keys_counter_i < keys.length; keys_counter_i++) {
        const keys_element : string = keys[keys_counter_i];
        buffer__argsSerializer.writeString(keys_element);
    }
    let buffer__continuationValue : boolean | undefined;
    const buffer__continuationCallback : ((value0: boolean) => void) = (value: boolean):void => {     buffer__continuationValue = value; }
    buffer__argsSerializer.holdAndWriteCallback(buffer__continuationCallback);
    InteropNativeModule._CallCallback(-1026503952, buffer__argsSerializer.asBuffer(), buffer__argsSerializer.length());
    buffer__argsSerializer.release();
    return (buffer__continuationValue as boolean); }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let getModifierKeyState_type : int32 = RuntimeType.UNDEFINED
        getModifierKeyState_type = runtimeType(getModifierKeyState)
        thisSerializer.writeInt8((getModifierKeyState_type).toChar())
        if ((getModifierKeyState_type) != (RuntimeType.UNDEFINED)) {
            const getModifierKeyState_value  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyState_value)
        }
        ArkUIGeneratedNativeModule._DragEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class DrawModifierInternal {
    public static fromPtr(ptr: KPointer): DrawModifier {
        return new DrawModifier(ptr)
    }
}
export class DrawModifier implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    drawBehind(drawContext: DrawContext): void {
    }
    get drawBehind_callback(): ((drawContext: DrawContext) => void) {
        return this.getDrawBehind_callback()
    }
    set drawBehind_callback(drawBehind_callback: ((drawContext: DrawContext) => void)) {
        this.setDrawBehind_callback(drawBehind_callback)
    }
    drawContent(drawContext: DrawContext): void {
    }
    get drawContent_callback(): ((drawContext: DrawContext) => void) {
        return this.getDrawContent_callback()
    }
    set drawContent_callback(drawContent_callback: ((drawContext: DrawContext) => void)) {
        this.setDrawContent_callback(drawContent_callback)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DrawModifier.getFinalizer())
    }
    constructor() {
        this(DrawModifier.construct())
        this.drawBehind_callback = this.drawBehind
        this.drawContent_callback = this.drawContent
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DrawModifier_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DrawModifier_getFinalizer()
    }
    public invalidate(): void {
        this.invalidate_serialize()
        return
    }
    private getDrawBehind_callback(): ((drawContext: DrawContext) => void) {
        return this.getDrawBehind_callback_serialize()
    }
    private setDrawBehind_callback(drawBehind_callback: ((drawContext: DrawContext) => void)): void {
        const drawBehind_callback_casted = drawBehind_callback as (((drawContext: DrawContext) => void))
        this.setDrawBehind_callback_serialize(drawBehind_callback_casted)
        return
    }
    private getDrawContent_callback(): ((drawContext: DrawContext) => void) {
        return this.getDrawContent_callback_serialize()
    }
    private setDrawContent_callback(drawContent_callback: ((drawContext: DrawContext) => void)): void {
        const drawContent_callback_casted = drawContent_callback as (((drawContext: DrawContext) => void))
        this.setDrawContent_callback_serialize(drawContent_callback_casted)
        return
    }
    private invalidate_serialize(): void {
        ArkUIGeneratedNativeModule._DrawModifier_invalidate(this.peer!.ptr)
    }
    private getDrawBehind_callback_serialize(): ((drawContext: DrawContext) => void) {
        const retval  = ArkUIGeneratedNativeModule._DrawModifier_getDrawBehind_callback(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setDrawBehind_callback_serialize(drawBehind_callback: ((drawContext: DrawContext) => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(drawBehind_callback)
        ArkUIGeneratedNativeModule._DrawModifier_setDrawBehind_callback(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDrawContent_callback_serialize(): ((drawContext: DrawContext) => void) {
        const retval  = ArkUIGeneratedNativeModule._DrawModifier_getDrawContent_callback(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setDrawContent_callback_serialize(drawContent_callback: ((drawContext: DrawContext) => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(drawContent_callback)
        ArkUIGeneratedNativeModule._DrawModifier_setDrawContent_callback(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface GestureModifier {
    applyGesture(event: UIGestureEvent): void
}
export class GestureModifierInternal implements MaterializedBase,GestureModifier {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, GestureModifierInternal.getFinalizer())
    }
    constructor() {
        this(GestureModifierInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._GestureModifier_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._GestureModifier_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): GestureModifierInternal {
        return new GestureModifierInternal(ptr)
    }
    public applyGesture(event: UIGestureEvent): void {
        const event_casted = event as (UIGestureEvent)
        this.applyGesture_serialize(event_casted)
        return
    }
    private applyGesture_serialize(event: UIGestureEvent): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        UIGestureEvent_serializer.write(thisSerializer, event)
        ArkUIGeneratedNativeModule._GestureModifier_applyGesture(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface KeyEvent {
    type: KeyType
    keyCode: number
    keyText: string
    keySource: KeySource
    deviceId: number
    metaKey: number
    timestamp: number
    stopPropagation: (() => void)
    intentionCode: IntentionCode
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    unicode?: number | undefined
}
export class KeyEventInternal implements MaterializedBase,KeyEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get type(): KeyType {
        return this.getType()
    }
    set type(type: KeyType) {
        this.setType(type)
    }
    get keyCode(): number {
        return this.getKeyCode()
    }
    set keyCode(keyCode: number) {
        this.setKeyCode(keyCode)
    }
    get keyText(): string {
        return this.getKeyText()
    }
    set keyText(keyText: string) {
        this.setKeyText(keyText)
    }
    get keySource(): KeySource {
        return this.getKeySource()
    }
    set keySource(keySource: KeySource) {
        this.setKeySource(keySource)
    }
    get deviceId(): number {
        return this.getDeviceId()
    }
    set deviceId(deviceId: number) {
        this.setDeviceId(deviceId)
    }
    get metaKey(): number {
        return this.getMetaKey()
    }
    set metaKey(metaKey: number) {
        this.setMetaKey(metaKey)
    }
    get timestamp(): number {
        return this.getTimestamp()
    }
    set timestamp(timestamp: number) {
        this.setTimestamp(timestamp)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    get intentionCode(): IntentionCode {
        return this.getIntentionCode()
    }
    set intentionCode(intentionCode: IntentionCode) {
        this.setIntentionCode(intentionCode)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    get unicode(): number | undefined {
        return this.getUnicode()
    }
    set unicode(unicode: number | undefined) {
        const unicode_NonNull  = (unicode as number)
        this.setUnicode(unicode_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, KeyEventInternal.getFinalizer())
    }
    constructor() {
        this(KeyEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._KeyEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): KeyEventInternal {
        return new KeyEventInternal(ptr)
    }
    private getType(): KeyType {
        return this.getType_serialize()
    }
    private setType(type: KeyType): void {
        const type_casted = type as (KeyType)
        this.setType_serialize(type_casted)
        return
    }
    private getKeyCode(): number {
        return this.getKeyCode_serialize()
    }
    private setKeyCode(keyCode: number): void {
        const keyCode_casted = keyCode as (number)
        this.setKeyCode_serialize(keyCode_casted)
        return
    }
    private getKeyText(): string {
        return this.getKeyText_serialize()
    }
    private setKeyText(keyText: string): void {
        const keyText_casted = keyText as (string)
        this.setKeyText_serialize(keyText_casted)
        return
    }
    private getKeySource(): KeySource {
        return this.getKeySource_serialize()
    }
    private setKeySource(keySource: KeySource): void {
        const keySource_casted = keySource as (KeySource)
        this.setKeySource_serialize(keySource_casted)
        return
    }
    private getDeviceId(): number {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: number): void {
        const deviceId_casted = deviceId as (number)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getMetaKey(): number {
        return this.getMetaKey_serialize()
    }
    private setMetaKey(metaKey: number): void {
        const metaKey_casted = metaKey as (number)
        this.setMetaKey_serialize(metaKey_casted)
        return
    }
    private getTimestamp(): number {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: number): void {
        const timestamp_casted = timestamp as (number)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getIntentionCode(): IntentionCode {
        return this.getIntentionCode_serialize()
    }
    private setIntentionCode(intentionCode: IntentionCode): void {
        const intentionCode_casted = intentionCode as (IntentionCode)
        this.setIntentionCode_serialize(intentionCode_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getUnicode(): number | undefined {
        return this.getUnicode_serialize()
    }
    private setUnicode(unicode: number | undefined): void {
        const unicode_casted = unicode as (number | undefined)
        this.setUnicode_serialize(unicode_casted)
        return
    }
    private getType_serialize(): KeyType {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getType(this.peer!.ptr)
        return TypeChecker.KeyType_FromNumeric(retval)
    }
    private setType_serialize(type: KeyType): void {
        ArkUIGeneratedNativeModule._KeyEvent_setType(this.peer!.ptr, TypeChecker.KeyType_ToNumeric(type))
    }
    private getKeyCode_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyCode(this.peer!.ptr)
        return retval
    }
    private setKeyCode_serialize(keyCode: number): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyCode(this.peer!.ptr, keyCode)
    }
    private getKeyText_serialize(): string {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyText(this.peer!.ptr)
        return retval
    }
    private setKeyText_serialize(keyText: string): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyText(this.peer!.ptr, keyText)
    }
    private getKeySource_serialize(): KeySource {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeySource(this.peer!.ptr)
        return TypeChecker.KeySource_FromNumeric(retval)
    }
    private setKeySource_serialize(keySource: KeySource): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeySource(this.peer!.ptr, TypeChecker.KeySource_ToNumeric(keySource))
    }
    private getDeviceId_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getDeviceId(this.peer!.ptr)
        return retval
    }
    private setDeviceId_serialize(deviceId: number): void {
        ArkUIGeneratedNativeModule._KeyEvent_setDeviceId(this.peer!.ptr, deviceId)
    }
    private getMetaKey_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getMetaKey(this.peer!.ptr)
        return retval
    }
    private setMetaKey_serialize(metaKey: number): void {
        ArkUIGeneratedNativeModule._KeyEvent_setMetaKey(this.peer!.ptr, metaKey)
    }
    private getTimestamp_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: number): void {
        ArkUIGeneratedNativeModule._KeyEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getStopPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._KeyEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getIntentionCode_serialize(): IntentionCode {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getIntentionCode(this.peer!.ptr)
        return TypeChecker.IntentionCode_FromNumeric(retval)
    }
    private setIntentionCode_serialize(intentionCode: IntentionCode): void {
        ArkUIGeneratedNativeModule._KeyEvent_setIntentionCode(this.peer!.ptr, TypeChecker.IntentionCode_ToNumeric(intentionCode))
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const buffer__resource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer__call : KPointer = retvalDeserializer.readPointer()
            const buffer__callSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => { 
    const buffer__argsSerializer : SerializerBase = SerializerBase.hold();
    buffer__argsSerializer.writeInt32(buffer__resource.resourceId);
    buffer__argsSerializer.writePointer(buffer__call);
    buffer__argsSerializer.writePointer(buffer__callSync);
    buffer__argsSerializer.writeInt32((keys.length).toInt());
    for (let keys_counter_i = 0; keys_counter_i < keys.length; keys_counter_i++) {
        const keys_element : string = keys[keys_counter_i];
        buffer__argsSerializer.writeString(keys_element);
    }
    let buffer__continuationValue : boolean | undefined;
    const buffer__continuationCallback : ((value0: boolean) => void) = (value: boolean):void => {     buffer__continuationValue = value; }
    buffer__argsSerializer.holdAndWriteCallback(buffer__continuationCallback);
    InteropNativeModule._CallCallback(-1026503952, buffer__argsSerializer.asBuffer(), buffer__argsSerializer.length());
    buffer__argsSerializer.release();
    return (buffer__continuationValue as boolean); }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let getModifierKeyState_type : int32 = RuntimeType.UNDEFINED
        getModifierKeyState_type = runtimeType(getModifierKeyState)
        thisSerializer.writeInt8((getModifierKeyState_type).toChar())
        if ((getModifierKeyState_type) != (RuntimeType.UNDEFINED)) {
            const getModifierKeyState_value  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyState_value)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUnicode_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getUnicode(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setUnicode_serialize(unicode: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let unicode_type : int32 = RuntimeType.UNDEFINED
        unicode_type = runtimeType(unicode)
        thisSerializer.writeInt8((unicode_type).toChar())
        if ((unicode_type) != (RuntimeType.UNDEFINED)) {
            const unicode_value  = unicode!
            thisSerializer.writeNumber(unicode_value)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setUnicode(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface Layoutable {
    measureResult: MeasureResult
    uniqueId?: number | undefined
    layout(position: Position): void
    getMargin(): DirectionalEdgesT
    getPadding(): DirectionalEdgesT
    getBorderWidth(): DirectionalEdgesT
}
export class LayoutableInternal implements MaterializedBase,Layoutable {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get measureResult(): MeasureResult {
        return this.getMeasureResult()
    }
    set measureResult(measureResult: MeasureResult) {
        this.setMeasureResult(measureResult)
    }
    get uniqueId(): number | undefined {
        return this.getUniqueId()
    }
    set uniqueId(uniqueId: number | undefined) {
        const uniqueId_NonNull  = (uniqueId as number)
        this.setUniqueId(uniqueId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutableInternal.getFinalizer())
    }
    constructor() {
        this(LayoutableInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Layoutable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): LayoutableInternal {
        return new LayoutableInternal(ptr)
    }
    public layout(position: Position): void {
        const position_casted = position as (Position)
        this.layout_serialize(position_casted)
        return
    }
    public getMargin(): DirectionalEdgesT {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT {
        return this.getBorderWidth_serialize()
    }
    private getMeasureResult(): MeasureResult {
        return this.getMeasureResult_serialize()
    }
    private setMeasureResult(measureResult: MeasureResult): void {
        const measureResult_casted = measureResult as (MeasureResult)
        this.setMeasureResult_serialize(measureResult_casted)
        return
    }
    private getUniqueId(): number | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: number | undefined): void {
        const uniqueId_casted = uniqueId as (number | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    private layout_serialize(position: Position): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        Position_serializer.write(thisSerializer, position)
        ArkUIGeneratedNativeModule._Layoutable_layout(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getMargin_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getPadding_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getBorderWidth_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getMeasureResult_serialize(): MeasureResult {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMeasureResult(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : MeasureResult = MeasureResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setMeasureResult_serialize(measureResult: MeasureResult): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        MeasureResult_serializer.write(thisSerializer, measureResult)
        ArkUIGeneratedNativeModule._Layoutable_setMeasureResult(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUniqueId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let uniqueId_type : int32 = RuntimeType.UNDEFINED
        uniqueId_type = runtimeType(uniqueId)
        thisSerializer.writeInt8((uniqueId_type).toChar())
        if ((uniqueId_type) != (RuntimeType.UNDEFINED)) {
            const uniqueId_value  = uniqueId!
            thisSerializer.writeNumber(uniqueId_value)
        }
        ArkUIGeneratedNativeModule._Layoutable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface LayoutChild {
    name: string
    id: string
    position: Position
    measure(childConstraint: ConstraintSizeOptions): void
}
export class LayoutChildInternal implements MaterializedBase,LayoutChild {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get name(): string {
        return this.getName()
    }
    set name(name: string) {
        this.setName(name)
    }
    get id(): string {
        return this.getId()
    }
    set id(id: string) {
        this.setId(id)
    }
    get position(): Position {
        return this.getPosition()
    }
    set position(position: Position) {
        this.setPosition(position)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutChildInternal.getFinalizer())
    }
    constructor() {
        this(LayoutChildInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._LayoutChild_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._LayoutChild_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): LayoutChildInternal {
        return new LayoutChildInternal(ptr)
    }
    public measure(childConstraint: ConstraintSizeOptions): void {
        const childConstraint_casted = childConstraint as (ConstraintSizeOptions)
        this.measure_serialize(childConstraint_casted)
        return
    }
    private getName(): string {
        return this.getName_serialize()
    }
    private setName(name: string): void {
        const name_casted = name as (string)
        this.setName_serialize(name_casted)
        return
    }
    private getId(): string {
        return this.getId_serialize()
    }
    private setId(id: string): void {
        const id_casted = id as (string)
        this.setId_serialize(id_casted)
        return
    }
    private getPosition(): Position {
        return this.getPosition_serialize()
    }
    private setPosition(position: Position): void {
        const position_casted = position as (Position)
        this.setPosition_serialize(position_casted)
        return
    }
    private measure_serialize(childConstraint: ConstraintSizeOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ConstraintSizeOptions_serializer.write(thisSerializer, childConstraint)
        ArkUIGeneratedNativeModule._LayoutChild_measure(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getName_serialize(): string {
        const retval  = ArkUIGeneratedNativeModule._LayoutChild_getName(this.peer!.ptr)
        return retval
    }
    private setName_serialize(name: string): void {
        ArkUIGeneratedNativeModule._LayoutChild_setName(this.peer!.ptr, name)
    }
    private getId_serialize(): string {
        const retval  = ArkUIGeneratedNativeModule._LayoutChild_getId(this.peer!.ptr)
        return retval
    }
    private setId_serialize(id: string): void {
        ArkUIGeneratedNativeModule._LayoutChild_setId(this.peer!.ptr, id)
    }
    private getPosition_serialize(): Position {
        const retval  = ArkUIGeneratedNativeModule._LayoutChild_getPosition(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : Position = Position_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setPosition_serialize(position: Position): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        Position_serializer.write(thisSerializer, position)
        ArkUIGeneratedNativeModule._LayoutChild_setPosition(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class LayoutPolicyInternal {
    public static fromPtr(ptr: KPointer): LayoutPolicy {
        return new LayoutPolicy(ptr)
    }
}
export class LayoutPolicy implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    static readonly matchParent: LayoutPolicy = LayoutPolicy.getMatchParent()
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutPolicy.getFinalizer())
    }
    constructor() {
        this(LayoutPolicy.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._LayoutPolicy_getFinalizer()
    }
    private static getMatchParent_serialize(): LayoutPolicy {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_getMatchParent()
        const obj : LayoutPolicy = LayoutPolicyInternal.fromPtr(retval)
        return obj
    }
    private static getMatchParent(): LayoutPolicy {
        return LayoutPolicy.getMatchParent_serialize()
    }
}
export interface Measurable {
    uniqueId?: number | undefined
    measure(constraint: ConstraintSizeOptions): MeasureResult
    getMargin(): DirectionalEdgesT
    getPadding(): DirectionalEdgesT
    getBorderWidth(): DirectionalEdgesT
}
export class MeasurableInternal implements MaterializedBase,Measurable {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get uniqueId(): number | undefined {
        return this.getUniqueId()
    }
    set uniqueId(uniqueId: number | undefined) {
        const uniqueId_NonNull  = (uniqueId as number)
        this.setUniqueId(uniqueId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, MeasurableInternal.getFinalizer())
    }
    constructor() {
        this(MeasurableInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Measurable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Measurable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MeasurableInternal {
        return new MeasurableInternal(ptr)
    }
    public measure(constraint: ConstraintSizeOptions): MeasureResult {
        const constraint_casted = constraint as (ConstraintSizeOptions)
        return this.measure_serialize(constraint_casted)
    }
    public getMargin(): DirectionalEdgesT {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT {
        return this.getBorderWidth_serialize()
    }
    private getUniqueId(): number | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: number | undefined): void {
        const uniqueId_casted = uniqueId as (number | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    private measure_serialize(constraint: ConstraintSizeOptions): MeasureResult {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ConstraintSizeOptions_serializer.write(thisSerializer, constraint)
        const retval  = ArkUIGeneratedNativeModule._Measurable_measure(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : MeasureResult = MeasureResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getMargin_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getPadding_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getBorderWidth_serialize(): DirectionalEdgesT {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getUniqueId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let uniqueId_type : int32 = RuntimeType.UNDEFINED
        uniqueId_type = runtimeType(uniqueId)
        thisSerializer.writeInt8((uniqueId_type).toChar())
        if ((uniqueId_type) != (RuntimeType.UNDEFINED)) {
            const uniqueId_value  = uniqueId!
            thisSerializer.writeNumber(uniqueId_value)
        }
        ArkUIGeneratedNativeModule._Measurable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface PixelMapMock {
    release(): void
}
export class PixelMapMockInternal implements MaterializedBase,PixelMapMock {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, PixelMapMockInternal.getFinalizer())
    }
    constructor() {
        this(PixelMapMockInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._PixelMapMock_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._PixelMapMock_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): PixelMapMockInternal {
        return new PixelMapMockInternal(ptr)
    }
    public release(): void {
        this.release_serialize()
        return
    }
    private release_serialize(): void {
        ArkUIGeneratedNativeModule._PixelMapMock_release(this.peer!.ptr)
    }
}
export class ProgressMaskInternal {
    public static fromPtr(ptr: KPointer): ProgressMask {
        return new ProgressMask(false, false, false, ptr)
    }
}
export class ProgressMask implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(_0: boolean, _1: boolean, _2: boolean, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ProgressMask.getFinalizer())
    }
    constructor(value: number, total: number, color: ResourceColor) {
        this(false, false, false, ProgressMask.construct(value, total, color))
    }
    static construct(value: number, total: number, color: ResourceColor): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let color_type : int32 = RuntimeType.UNDEFINED
        color_type = runtimeType(color)
        if (TypeChecker.isColor(color)) {
            thisSerializer.writeInt8((0).toChar())
            const color_0  = color as Color
            thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(color_0))
        }
        else if (RuntimeType.NUMBER == color_type) {
            thisSerializer.writeInt8((1).toChar())
            const color_1  = color as number
            thisSerializer.writeNumber(color_1)
        }
        else if (RuntimeType.STRING == color_type) {
            thisSerializer.writeInt8((2).toChar())
            const color_2  = color as string
            thisSerializer.writeString(color_2)
        }
        else if (RuntimeType.OBJECT == color_type) {
            thisSerializer.writeInt8((3).toChar())
            const color_3  = color as Resource
            Resource_serializer.write(thisSerializer, color_3)
        }
        const retval  = ArkUIGeneratedNativeModule._ProgressMask_construct(value, total, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ProgressMask_getFinalizer()
    }
    public updateProgress(value: number): void {
        const value_casted = value as (number)
        this.updateProgress_serialize(value_casted)
        return
    }
    public updateColor(value: ResourceColor): void {
        const value_casted = value as (ResourceColor)
        this.updateColor_serialize(value_casted)
        return
    }
    public enableBreathingAnimation(value: boolean): void {
        const value_casted = value as (boolean)
        this.enableBreathingAnimation_serialize(value_casted)
        return
    }
    private updateProgress_serialize(value: number): void {
        ArkUIGeneratedNativeModule._ProgressMask_updateProgress(this.peer!.ptr, value)
    }
    private updateColor_serialize(value: ResourceColor): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        if (TypeChecker.isColor(value)) {
            thisSerializer.writeInt8((0).toChar())
            const value_0  = value as Color
            thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_0))
        }
        else if (RuntimeType.NUMBER == value_type) {
            thisSerializer.writeInt8((1).toChar())
            const value_1  = value as number
            thisSerializer.writeNumber(value_1)
        }
        else if (RuntimeType.STRING == value_type) {
            thisSerializer.writeInt8((2).toChar())
            const value_2  = value as string
            thisSerializer.writeString(value_2)
        }
        else if (RuntimeType.OBJECT == value_type) {
            thisSerializer.writeInt8((3).toChar())
            const value_3  = value as Resource
            Resource_serializer.write(thisSerializer, value_3)
        }
        ArkUIGeneratedNativeModule._ProgressMask_updateColor(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private enableBreathingAnimation_serialize(value: boolean): void {
        ArkUIGeneratedNativeModule._ProgressMask_enableBreathingAnimation(this.peer!.ptr, value ? 1 : 0)
    }
}
export class ScrollResultInternal {
    public static fromPtr(ptr: KPointer): ScrollResult {
        return new ScrollResult(ptr)
    }
}
export class ScrollResult implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get offsetRemain(): number {
        return this.getOffsetRemain()
    }
    set offsetRemain(offsetRemain: number) {
        this.setOffsetRemain(offsetRemain)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ScrollResult.getFinalizer())
    }
    constructor() {
        this(ScrollResult.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ScrollResult_getFinalizer()
    }
    private getOffsetRemain(): number {
        return this.getOffsetRemain_serialize()
    }
    private setOffsetRemain(offsetRemain: number): void {
        const offsetRemain_casted = offsetRemain as (number)
        this.setOffsetRemain_serialize(offsetRemain_casted)
        return
    }
    private getOffsetRemain_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_getOffsetRemain(this.peer!.ptr)
        return retval
    }
    private setOffsetRemain_serialize(offsetRemain: number): void {
        ArkUIGeneratedNativeModule._ScrollResult_setOffsetRemain(this.peer!.ptr, offsetRemain)
    }
}
export class TextContentControllerBaseInternal {
    public static fromPtr(ptr: KPointer): TextContentControllerBase {
        return new TextContentControllerBase(ptr)
    }
}
export class TextContentControllerBase implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TextContentControllerBase.getFinalizer())
    }
    constructor() {
        this(TextContentControllerBase.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TextContentControllerBase_getFinalizer()
    }
    public getCaretOffset(): CaretOffset {
        return this.getCaretOffset_serialize()
    }
    public getTextContentRect(): RectResult {
        return this.getTextContentRect_serialize()
    }
    public getTextContentLineCount(): number {
        return this.getTextContentLineCount_serialize()
    }
    public addText(text: string, textOperationOptions?: TextContentControllerOptions): number {
        const text_casted = text as (string)
        const textOperationOptions_casted = textOperationOptions as (TextContentControllerOptions | undefined)
        return this.addText_serialize(text_casted, textOperationOptions_casted)
    }
    public deleteText(range?: TextRange): void {
        const range_casted = range as (TextRange | undefined)
        this.deleteText_serialize(range_casted)
        return
    }
    public getSelection(): TextRange {
        return this.getSelection_serialize()
    }
    public clearPreviewText(): void {
        this.clearPreviewText_serialize()
        return
    }
    public getText(range?: TextRange): string {
        const range_casted = range as (TextRange | undefined)
        return this.getText_serialize(range_casted)
    }
    private getCaretOffset_serialize(): CaretOffset {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getCaretOffset(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : CaretOffset = CaretOffset_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getTextContentRect_serialize(): RectResult {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : RectResult = RectResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getTextContentLineCount_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentLineCount(this.peer!.ptr)
        return retval
    }
    private addText_serialize(text: string, textOperationOptions?: TextContentControllerOptions): number {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let textOperationOptions_type : int32 = RuntimeType.UNDEFINED
        textOperationOptions_type = runtimeType(textOperationOptions)
        thisSerializer.writeInt8((textOperationOptions_type).toChar())
        if ((textOperationOptions_type) != (RuntimeType.UNDEFINED)) {
            const textOperationOptions_value  = textOperationOptions!
            TextContentControllerOptions_serializer.write(thisSerializer, textOperationOptions_value)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_addText(this.peer!.ptr, text, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    private deleteText_serialize(range?: TextRange): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let range_type : int32 = RuntimeType.UNDEFINED
        range_type = runtimeType(range)
        thisSerializer.writeInt8((range_type).toChar())
        if ((range_type) != (RuntimeType.UNDEFINED)) {
            const range_value  = range!
            TextRange_serializer.write(thisSerializer, range_value)
        }
        ArkUIGeneratedNativeModule._TextContentControllerBase_deleteText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getSelection_serialize(): TextRange {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getSelection(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : TextRange = TextRange_serializer.read(retvalDeserializer)
        return returnResult
    }
    private clearPreviewText_serialize(): void {
        ArkUIGeneratedNativeModule._TextContentControllerBase_clearPreviewText(this.peer!.ptr)
    }
    private getText_serialize(range?: TextRange): string {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let range_type : int32 = RuntimeType.UNDEFINED
        range_type = runtimeType(range)
        thisSerializer.writeInt8((range_type).toChar())
        if ((range_type) != (RuntimeType.UNDEFINED)) {
            const range_value  = range!
            TextRange_serializer.write(thisSerializer, range_value)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
}
export class TransitionEffectInternal {
    public static fromPtr(ptr: KPointer): TransitionEffect {
        return new TransitionEffect(false, ptr)
    }
}
export class TransitionEffect implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get IDENTITY(): TransitionEffect {
        return this.getIDENTITY()
    }
    set IDENTITY(IDENTITY: TransitionEffect) {
        this.setIDENTITY(IDENTITY)
    }
    get OPACITY(): TransitionEffect {
        return this.getOPACITY()
    }
    set OPACITY(OPACITY: TransitionEffect) {
        this.setOPACITY(OPACITY)
    }
    get SLIDE(): TransitionEffect {
        return this.getSLIDE()
    }
    set SLIDE(SLIDE: TransitionEffect) {
        this.setSLIDE(SLIDE)
    }
    get SLIDE_SWITCH(): TransitionEffect {
        return this.getSLIDE_SWITCH()
    }
    set SLIDE_SWITCH(SLIDE_SWITCH: TransitionEffect) {
        this.setSLIDE_SWITCH(SLIDE_SWITCH)
    }
    constructor(_0: boolean, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TransitionEffect.getFinalizer())
    }
    constructor(type: string) {
        this(false, TransitionEffect.construct0(type))
    }
    constructor(effect: number) {
        this(false, TransitionEffect.construct1(effect))
    }
    constructor(effect: TransitionEdge) {
        this(false, TransitionEffect.construct2(effect))
    }
    constructor(effect: TranslateOptions) {
        this(false, TransitionEffect.construct3(effect))
    }
    constructor(effect: RotateOptions) {
        this(false, TransitionEffect.construct4(effect))
    }
    constructor(effect: ScaleOptions) {
        this(false, TransitionEffect.construct5(effect))
    }
    constructor(effect: AsymmetricTransitionOption) {
        this(false, TransitionEffect.construct6(effect))
    }
    static construct0(type: string): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct0(type)
        return retval
    }
    static construct1(effect: number): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct1(effect)
        return retval
    }
    static construct2(effect: TransitionEdge): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct2(TypeChecker.TransitionEdge_ToNumeric(effect))
        return retval
    }
    static construct3(effect: TranslateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct3(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct4(effect: RotateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct4(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct5(effect: ScaleOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct5(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct6(effect: AsymmetricTransitionOption): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AsymmetricTransitionOption_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct6(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TransitionEffect_getFinalizer()
    }
    private static translate_serialize(options: TranslateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_translate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static rotate_serialize(options: RotateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_rotate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static scale_serialize(options: ScaleOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_scale(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static opacity_serialize(alpha: number): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_opacity(alpha)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static move_serialize(edge: TransitionEdge): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_move(TypeChecker.TransitionEdge_ToNumeric(edge))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static asymmetric_serialize(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_asymmetric(toPeerPtr(appear), toPeerPtr(disappear))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    public static translate(options: TranslateOptions): TransitionEffect {
        const options_casted = options as (TranslateOptions)
        return TransitionEffect.translate_serialize(options_casted)
    }
    public static rotate(options: RotateOptions): TransitionEffect {
        const options_casted = options as (RotateOptions)
        return TransitionEffect.rotate_serialize(options_casted)
    }
    public static scale(options: ScaleOptions): TransitionEffect {
        const options_casted = options as (ScaleOptions)
        return TransitionEffect.scale_serialize(options_casted)
    }
    public static opacity(alpha: number): TransitionEffect {
        const alpha_casted = alpha as (number)
        return TransitionEffect.opacity_serialize(alpha_casted)
    }
    public static move(edge: TransitionEdge): TransitionEffect {
        const edge_casted = edge as (TransitionEdge)
        return TransitionEffect.move_serialize(edge_casted)
    }
    public static asymmetric(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const appear_casted = appear as (TransitionEffect)
        const disappear_casted = disappear as (TransitionEffect)
        return TransitionEffect.asymmetric_serialize(appear_casted, disappear_casted)
    }
    public animation(value: AnimateParam): TransitionEffect {
        const value_casted = value as (AnimateParam)
        return this.animation_serialize(value_casted)
    }
    public combine(transitionEffect: TransitionEffect): TransitionEffect {
        const transitionEffect_casted = transitionEffect as (TransitionEffect)
        return this.combine_serialize(transitionEffect_casted)
    }
    private getIDENTITY(): TransitionEffect {
        return this.getIDENTITY_serialize()
    }
    private setIDENTITY(IDENTITY: TransitionEffect): void {
        const IDENTITY_casted = IDENTITY as (TransitionEffect)
        this.setIDENTITY_serialize(IDENTITY_casted)
        return
    }
    private getOPACITY(): TransitionEffect {
        return this.getOPACITY_serialize()
    }
    private setOPACITY(OPACITY: TransitionEffect): void {
        const OPACITY_casted = OPACITY as (TransitionEffect)
        this.setOPACITY_serialize(OPACITY_casted)
        return
    }
    private getSLIDE(): TransitionEffect {
        return this.getSLIDE_serialize()
    }
    private setSLIDE(SLIDE: TransitionEffect): void {
        const SLIDE_casted = SLIDE as (TransitionEffect)
        this.setSLIDE_serialize(SLIDE_casted)
        return
    }
    private getSLIDE_SWITCH(): TransitionEffect {
        return this.getSLIDE_SWITCH_serialize()
    }
    private setSLIDE_SWITCH(SLIDE_SWITCH: TransitionEffect): void {
        const SLIDE_SWITCH_casted = SLIDE_SWITCH as (TransitionEffect)
        this.setSLIDE_SWITCH_serialize(SLIDE_SWITCH_casted)
        return
    }
    private animation_serialize(value: AnimateParam): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AnimateParam_serializer.write(thisSerializer, value)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_animation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private combine_serialize(transitionEffect: TransitionEffect): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_combine(this.peer!.ptr, toPeerPtr(transitionEffect))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private getIDENTITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getIDENTITY(this.peer!.ptr)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private setIDENTITY_serialize(IDENTITY: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setIDENTITY(this.peer!.ptr, toPeerPtr(IDENTITY))
    }
    private getOPACITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getOPACITY(this.peer!.ptr)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private setOPACITY_serialize(OPACITY: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setOPACITY(this.peer!.ptr, toPeerPtr(OPACITY))
    }
    private getSLIDE_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE(this.peer!.ptr)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private setSLIDE_serialize(SLIDE: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setSLIDE(this.peer!.ptr, toPeerPtr(SLIDE))
    }
    private getSLIDE_SWITCH_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE_SWITCH(this.peer!.ptr)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private setSLIDE_SWITCH_serialize(SLIDE_SWITCH: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setSLIDE_SWITCH(this.peer!.ptr, toPeerPtr(SLIDE_SWITCH))
    }
}
export interface UICommonEvent {
    setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void
    setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void
    setOnAppear(callback_: (() => void) | undefined): void
    setOnDisappear(callback_: (() => void) | undefined): void
    setOnKeyEvent(callback_: ((event: KeyEvent) => void) | undefined): void
    setOnFocus(callback_: (() => void) | undefined): void
    setOnBlur(callback_: (() => void) | undefined): void
    setOnHover(callback_: HoverCallback | undefined): void
    setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void
    setOnSizeChange(callback_: SizeChangeCallback | undefined): void
    setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void
}
export class UICommonEventInternal implements MaterializedBase,UICommonEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, UICommonEventInternal.getFinalizer())
    }
    constructor() {
        this(UICommonEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._UICommonEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._UICommonEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): UICommonEventInternal {
        return new UICommonEventInternal(ptr)
    }
    public setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: ClickEvent) => void) | undefined)
        this.setOnClick_serialize(callback__casted)
        return
    }
    public setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: TouchEvent) => void) | undefined)
        this.setOnTouch_serialize(callback__casted)
        return
    }
    public setOnAppear(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnAppear_serialize(callback__casted)
        return
    }
    public setOnDisappear(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnDisappear_serialize(callback__casted)
        return
    }
    public setOnKeyEvent(callback_: ((event: KeyEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: KeyEvent) => void) | undefined)
        this.setOnKeyEvent_serialize(callback__casted)
        return
    }
    public setOnFocus(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnFocus_serialize(callback__casted)
        return
    }
    public setOnBlur(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnBlur_serialize(callback__casted)
        return
    }
    public setOnHover(callback_: HoverCallback | undefined): void {
        const callback__casted = callback_ as (HoverCallback | undefined)
        this.setOnHover_serialize(callback__casted)
        return
    }
    public setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: MouseEvent) => void) | undefined)
        this.setOnMouse_serialize(callback__casted)
        return
    }
    public setOnSizeChange(callback_: SizeChangeCallback | undefined): void {
        const callback__casted = callback_ as (SizeChangeCallback | undefined)
        this.setOnSizeChange_serialize(callback__casted)
        return
    }
    public setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const options_casted = options as (VisibleAreaEventOptions)
        const event_casted = event as (VisibleAreaChangeCallback | undefined)
        this.setOnVisibleAreaApproximateChange_serialize(options_casted, event_casted)
        return
    }
    private setOnClick_serialize(callback_: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnClick(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnTouch_serialize(callback_: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnTouch(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnAppear_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnAppear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnDisappear_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnDisappear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnKeyEvent_serialize(callback_: ((event: KeyEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnKeyEvent(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnFocus_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnFocus(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnBlur_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnBlur(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnHover_serialize(callback_: HoverCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnHover(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnMouse_serialize(callback_: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnMouse(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnSizeChange_serialize(callback_: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnSizeChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnVisibleAreaApproximateChange_serialize(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        VisibleAreaEventOptions_serializer.write(thisSerializer, options)
        let event_type : int32 = RuntimeType.UNDEFINED
        event_type = runtimeType(event)
        thisSerializer.writeInt8((event_type).toChar())
        if ((event_type) != (RuntimeType.UNDEFINED)) {
            const event_value  = event!
            thisSerializer.holdAndWriteCallback(event_value)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnVisibleAreaApproximateChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonMethodPeer extends PeerNode {
    protected constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonMethod_construct(peerId, flags)
        const _peer  = new ArkCommonMethodPeer(_peerPtr, peerId, "CommonMethod", flags)
        component?.setPeer(_peer)
        return _peer
    }
    setWidthAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Length
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isLayoutPolicy(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHeightAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Length
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isLayoutPolicy(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDrawModifierAttribute(value: DrawModifier | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            DrawModifier_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDrawModifier(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (((RuntimeType.OBJECT) == (value_value_type)) && (TypeChecker.isArray_Rectangle(value_value))) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Array<Rectangle>
                thisSerializer.writeInt32((value_value_0.length).toInt())
                for (let value_value_0_counter_i = 0; value_value_0_counter_i < value_value_0.length; value_value_0_counter_i++) {
                    const value_value_0_element : Rectangle = value_value_0[value_value_0_counter_i]
                    Rectangle_serializer.write(thisSerializer, value_value_0_element)
                }
            }
            else if (TypeChecker.isRectangle(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Rectangle
                Rectangle_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMouseResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (((RuntimeType.OBJECT) == (value_value_type)) && (TypeChecker.isArray_Rectangle(value_value))) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Array<Rectangle>
                thisSerializer.writeInt32((value_value_0.length).toInt())
                for (let value_value_0_counter_i = 0; value_value_0_counter_i < value_value_0.length; value_value_0_counter_i++) {
                    const value_value_0_element : Rectangle = value_value_0[value_value_0_counter_i]
                    Rectangle_serializer.write(thisSerializer, value_value_0_element)
                }
            }
            else if (TypeChecker.isRectangle(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Rectangle
                Rectangle_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMouseResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSizeAttribute(value: SizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            SizeOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setConstraintSizeAttribute(value: ConstraintSizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ConstraintSizeOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setConstraintSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHitTestBehaviorAttribute(value: HitTestMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as HitTestMode)
            thisSerializer.writeInt32(TypeChecker.HitTestMode_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHitTestBehavior(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnChildTouchTestAttribute(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnChildTouchTest(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLayoutWeightAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLayoutWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainWeightAttribute(value: ChainWeightOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ChainWeightOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPaddingAttribute(value: Padding | Length | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Padding
                Padding_serializer.write(thisSerializer, value_value_0)
            }
            else if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Length
                let value_value_1_type : int32 = RuntimeType.UNDEFINED
                value_value_1_type = runtimeType(value_value_1)
                if (RuntimeType.STRING == value_value_1_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_1_0  = value_value_1 as string
                    thisSerializer.writeString(value_value_1_0)
                }
                else if (RuntimeType.NUMBER == value_value_1_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_1_1  = value_value_1 as number
                    thisSerializer.writeNumber(value_value_1_1)
                }
                else if (RuntimeType.OBJECT == value_value_1_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_1_2  = value_value_1 as Resource
                    Resource_serializer.write(thisSerializer, value_value_1_2)
                }
            }
            else if (TypeChecker.isLocalizedPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSafeAreaPaddingAttribute(value: Padding | LengthMetrics | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Padding
                Padding_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isLengthMetrics(value_value, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as LengthMetrics
                LengthMetrics_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSafeAreaPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarginAttribute(value: Padding | Length | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Padding
                Padding_serializer.write(thisSerializer, value_value_0)
            }
            else if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Length
                let value_value_1_type : int32 = RuntimeType.UNDEFINED
                value_value_1_type = runtimeType(value_value_1)
                if (RuntimeType.STRING == value_value_1_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_1_0  = value_value_1 as string
                    thisSerializer.writeString(value_value_1_0)
                }
                else if (RuntimeType.NUMBER == value_value_1_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_1_1  = value_value_1 as number
                    thisSerializer.writeNumber(value_value_1_1)
                }
                else if (RuntimeType.OBJECT == value_value_1_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_1_2  = value_value_1 as Resource
                    Resource_serializer.write(thisSerializer, value_value_1_2)
                }
            }
            else if (TypeChecker.isLocalizedPadding(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMargin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundColorAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isColor(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Color
                thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0))
            }
            else if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as number
                thisSerializer.writeNumber(value_value_1)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as string
                thisSerializer.writeString(value_value_2)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((3).toChar())
                const value_value_3  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_3)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelRoundAttribute(value: PixelRoundPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            PixelRoundPolicy_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelRound(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageSizeAttribute(value: SizeOptions | ImageSize | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as SizeOptions
                SizeOptions_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isImageSize(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as ImageSize
                thisSerializer.writeInt32(TypeChecker.ImageSize_ToNumeric(value_value_1))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImagePositionAttribute(value: Position | Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Position
                Position_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isAlignment(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Alignment
                thisSerializer.writeInt32(TypeChecker.Alignment_ToNumeric(value_value_1))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImagePosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundEffect0Attribute(value: BackgroundEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            BackgroundEffectOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundEffect0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageResizableAttribute(value: ResizableOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ResizableOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageResizable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundEffectAttribute(value: ForegroundEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ForegroundEffectOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisualEffectAttribute(value: uiEffect.VisualEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            uiEffect_VisualEffect_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisualEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            uiEffect_Filter_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            uiEffect_Filter_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setCompositingFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            uiEffect_Filter_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setCompositingFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOpacityAttribute(value: number | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderAttribute(value: BorderOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            BorderOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorder(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderStyleAttribute(value: BorderStyle | EdgeStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isBorderStyle(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as BorderStyle
                thisSerializer.writeInt32(TypeChecker.BorderStyle_ToNumeric(value_value_0))
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeStyles
                EdgeStyles_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderWidthAttribute(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Length
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeWidths(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeWidths
                EdgeWidths_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeWidths(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((TypeChecker.isColor(value_value)) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.STRING == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as ResourceColor
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (TypeChecker.isColor(value_value_0)) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as Color
                    thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((3).toChar())
                    const value_value_0_3  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_3)
                }
            }
            else if (TypeChecker.isEdgeColors(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeColors
                EdgeColors_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeColors(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderRadiusAttribute(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Length
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as BorderRadiuses
                BorderRadiuses_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderImageAttribute(value: BorderImageOption | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            BorderImageOption_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderImage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineAttribute(value: OutlineOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            OutlineOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutline(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineStyleAttribute(value: OutlineStyle | EdgeOutlineStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isOutlineStyle(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as OutlineStyle
                thisSerializer.writeInt32(TypeChecker.OutlineStyle_ToNumeric(value_value_0))
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeOutlineStyles
                EdgeOutlineStyles_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineWidthAttribute(value: Dimension | EdgeOutlineWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Dimension
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeOutlineWidths(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((TypeChecker.isColor(value_value)) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.STRING == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as ResourceColor
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (TypeChecker.isColor(value_value_0)) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as Color
                    thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((3).toChar())
                    const value_value_0_3  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_3)
                }
            }
            else if (TypeChecker.isEdgeColors(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EdgeColors
                EdgeColors_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeColors(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineRadiusAttribute(value: Dimension | OutlineRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((RuntimeType.STRING == value_value_type) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Dimension
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_2)
                }
            }
            else if (TypeChecker.isOutlineRadiuses(value_value, false, false, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as OutlineRadiuses
                OutlineRadiuses_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundColorAttribute(value: ResourceColor | ColoringStrategy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if ((TypeChecker.isColor(value_value)) || (RuntimeType.NUMBER == value_value_type) || (RuntimeType.STRING == value_value_type) || (RuntimeType.OBJECT == value_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as ResourceColor
                let value_value_0_type : int32 = RuntimeType.UNDEFINED
                value_value_0_type = runtimeType(value_value_0)
                if (TypeChecker.isColor(value_value_0)) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_0_0  = value_value_0 as Color
                    thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_0_1  = value_value_0 as number
                    thisSerializer.writeNumber(value_value_0_1)
                }
                else if (RuntimeType.STRING == value_value_0_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_0_2  = value_value_0 as string
                    thisSerializer.writeString(value_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_value_0_type) {
                    thisSerializer.writeInt8((3).toChar())
                    const value_value_0_3  = value_value_0 as Resource
                    Resource_serializer.write(thisSerializer, value_value_0_3)
                }
            }
            else if (TypeChecker.isColoringStrategy(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as ColoringStrategy
                thisSerializer.writeInt32(TypeChecker.ColoringStrategy_ToNumeric(value_value_1))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick0Attribute(value: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverAttribute(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverMoveAttribute(value: ((value0: HoverEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHoverMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityHoverAttribute(value: AccessibilityCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHoverEffectAttribute(value: HoverEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as HoverEffect)
            thisSerializer.writeInt32(TypeChecker.HoverEffect_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHoverEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnMouseAttribute(value: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnMouse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchAttribute(value: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventAttribute(value: ((event: KeyEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDigitalCrownAttribute(value: ((value0: CrownEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDigitalCrown(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyPreImeAttribute(value: ((value0: KeyEvent) => boolean) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyPreIme(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventDispatchAttribute(value: ((value0: KeyEvent) => boolean) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEventDispatch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAxisEventAttribute(value: ((value0: FocusAxisEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocusAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAxisEventAttribute(value: ((value0: AxisEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNextFocusAttribute(value: FocusMovement | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            FocusMovement_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setNextFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabStopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnBlurAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabIndexAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGroupDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGroupDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusOnTouchAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusBoxAttribute(value: FocusBoxStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            FocusBoxStyle_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusBox(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAnimationAttribute(value: AnimateParam | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            AnimateParam_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAnimation(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition0Attribute(value: TransitionEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            TransitionEffect_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionBlurAttribute(value: MotionBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            MotionBlurOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBrightnessAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setContrastAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setContrast(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGrayscaleAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGrayscale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setColorBlendAttribute(value: Color | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isColor(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Color
                thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0))
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setColorBlend(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSaturateAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSaturate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSepiaAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSepia(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setInvertAttribute(value: number | InvertOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as InvertOptions
                InvertOptions_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setInvert(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHueRotateAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHueRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseShadowBatchingAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseShadowBatching(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseEffect0Attribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderGroupAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderGroup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFreezeAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFreeze(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTranslateAttribute(value: TranslateOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            TranslateOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTranslate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScaleAttribute(value: ScaleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ScaleOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setScale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRotateAttribute(value: RotateOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            RotateOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransformAttribute(value: Object | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteObject(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransform(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDisAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDisAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAttachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAttach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDetachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDetach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAreaChangeAttribute(value: ((oldValue: Area,newValue: Area) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisibilityAttribute(value: Visibility | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as Visibility)
            thisSerializer.writeInt32(TypeChecker.Visibility_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisibility(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexGrowAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexGrow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexShrinkAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexShrink(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexBasisAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexBasis(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignSelfAttribute(value: ItemAlign | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as ItemAlign)
            thisSerializer.writeInt32(TypeChecker.ItemAlign_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignSelf(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDisplayPriorityAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDisplayPriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setZIndexAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setZIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDirectionAttribute(value: Direction | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as Direction)
            thisSerializer.writeInt32(TypeChecker.Direction_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDirection(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignAttribute(value: Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as Alignment)
            thisSerializer.writeInt32(TypeChecker.Alignment_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlign(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPositionAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPosition(value_value, false, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Position
                Position_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isEdges(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Edges
                Edges_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedEdges(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarkAnchorAttribute(value: Position | LocalizedPosition | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPosition(value_value, false, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Position
                Position_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isLocalizedPosition(value_value, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as LocalizedPosition
                LocalizedPosition_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMarkAnchor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOffsetAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isPosition(value_value, false, false)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Position
                Position_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isEdges(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Edges
                Edges_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isLocalizedEdges(value_value, true, false, true, false)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnabledAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setEnabled(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignRules0Attribute(value: AlignRuleOption | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            AlignRuleOption_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignRules0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignRules1Attribute(value: LocalizedAlignRuleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            LocalizedAlignRuleOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignRules1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAspectRatioAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAspectRatio(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClickEffectAttribute(value: ClickEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ClickEffect_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClickEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragStartAttribute(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEnterAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragMoveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragLeaveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragLeave(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop0Attribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEndAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAllowDropAttribute(value: Array<uniformTypeDescriptor.UniformDataType> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeInt32((value_value.length).toInt())
            for (let value_value_counter_i = 0; value_value_counter_i < value_value.length; value_value_counter_i++) {
                const value_value_element : uniformTypeDescriptor.UniformDataType = value_value[value_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.uniformTypeDescriptor_UniformDataType_ToNumeric(value_value_element))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAllowDrop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDraggableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDraggable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreview0Attribute(value: CustomBuilder | DragItemInfo | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.FUNCTION == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_value_0))
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as DragItemInfo
                DragItemInfo_serializer.write(thisSerializer, value_value_1)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as string
                thisSerializer.writeString(value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreview0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnPreDragAttribute(value: ((value0: PreDragStatus) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnPreDrag(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientAttribute(value: LinearGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            LinearGradientOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSweepGradientAttribute(value: SweepGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            SweepGradientOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSweepGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRadialGradientAttribute(value: RadialGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            RadialGradientOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRadialGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionPathAttribute(value: MotionPathOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            MotionPathOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionPath(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShadowAttribute(value: ShadowOptions | ShadowStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as ShadowOptions
                ShadowOptions_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isShadowStyle(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as ShadowStyle
                thisSerializer.writeInt32(TypeChecker.ShadowStyle_ToNumeric(value_value_1))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShadow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClip(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isCircleShape(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as CircleShape
                CircleShape_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isEllipseShape(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EllipseShape
                EllipseShape_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isPathShape(value_value)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as PathShape
                PathShape_serializer.write(thisSerializer, value_value_2)
            }
            else if (TypeChecker.isRectShape(value_value)) {
                thisSerializer.writeInt8((3).toChar())
                const value_value_3  = value_value as RectShape
                RectShape_serializer.write(thisSerializer, value_value_3)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClipShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskAttribute(value: ProgressMask | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ProgressMask_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMask(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isCircleShape(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as CircleShape
                CircleShape_serializer.write(thisSerializer, value_value_0)
            }
            else if (TypeChecker.isEllipseShape(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as EllipseShape
                EllipseShape_serializer.write(thisSerializer, value_value_1)
            }
            else if (TypeChecker.isPathShape(value_value)) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as PathShape
                PathShape_serializer.write(thisSerializer, value_value_2)
            }
            else if (TypeChecker.isRectShape(value_value)) {
                thisSerializer.writeInt8((3).toChar())
                const value_value_3  = value_value as RectShape
                RectShape_serializer.write(thisSerializer, value_value_3)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMaskShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKey(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGeometryTransition0Attribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGeometryTransition0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStateStylesAttribute(value: StateStyles | undefined): void {
        throw new Error("Not implemented")
    }
    setRestoreIdAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRestoreId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSphericalEffectAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSphericalEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLightUpEffectAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLightUpEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelStretchEffectAttribute(value: PixelStretchEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            PixelStretchEffectOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelStretchEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityGroup0Attribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityGroup0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityText0Attribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityText0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityNextFocusIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityNextFocusId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityUseSamePageAttribute(value: AccessibilitySamePageMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as AccessibilitySamePageMode)
            thisSerializer.writeInt32(TypeChecker.AccessibilitySamePageMode_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityUseSamePage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityScrollTriggerableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityScrollTriggerable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityText1Attribute(value: Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            Resource_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityText1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityRoleAttribute(value: AccessibilityRoleType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as AccessibilityRoleType)
            thisSerializer.writeInt32(TypeChecker.AccessibilityRoleType_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityRole(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityFocusAttribute(value: AccessibilityFocusCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextHintAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityTextHint(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDescription0Attribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDescription0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDescription1Attribute(value: Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            Resource_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDescription1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityLevelAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityVirtualNodeAttribute(value: CustomBuilder | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityVirtualNode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityCheckedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityChecked(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilitySelectedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilitySelected(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setObscuredAttribute(value: Array<ObscuredReasons> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeInt32((value_value.length).toInt())
            for (let value_value_counter_i = 0; value_value_counter_i < value_value.length; value_value_counter_i++) {
                const value_value_element : ObscuredReasons = value_value[value_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.ObscuredReasons_ToNumeric(value_value_element))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setObscured(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeString(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuseId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseAttribute(value: ReuseOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            ReuseOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderFitAttribute(value: RenderFit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as RenderFit)
            thisSerializer.writeInt32(TypeChecker.RenderFit_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderFit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGestureModifierAttribute(value: GestureModifier | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            GestureModifier_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGestureModifier(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundBrightnessAttribute(value: BackgroundBrightnessOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            BackgroundBrightnessOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureJudgeBeginAttribute(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureJudgeBegin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin0Attribute(value: GestureRecognizerJudgeBeginCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShouldBuiltInRecognizerParallelWithAttribute(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShouldBuiltInRecognizerParallelWith(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMonopolizeEventsAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMonopolizeEvents(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchInterceptAttribute(value: ((value0: TouchEvent) => HitTestMode) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouchIntercept(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnSizeChangeAttribute(value: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnSizeChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityFocusDrawLevelAttribute(value: FocusDrawLevel | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as FocusDrawLevel)
            thisSerializer.writeInt32(TypeChecker.FocusDrawLevel_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityFocusDrawLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setCustomPropertyAttribute(name: string | undefined, value: Object | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let name_type : int32 = RuntimeType.UNDEFINED
        name_type = runtimeType(name)
        thisSerializer.writeInt8((name_type).toChar())
        if ((name_type) != (RuntimeType.UNDEFINED)) {
            const name_value  = name!
            thisSerializer.writeString(name_value)
        }
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteObject(value_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setCustomProperty(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setExpandSafeAreaAttribute(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let types_type : int32 = RuntimeType.UNDEFINED
        types_type = runtimeType(types)
        thisSerializer.writeInt8((types_type).toChar())
        if ((types_type) != (RuntimeType.UNDEFINED)) {
            const types_value  = types!
            thisSerializer.writeInt32((types_value.length).toInt())
            for (let types_value_counter_i = 0; types_value_counter_i < types_value.length; types_value_counter_i++) {
                const types_value_element : SafeAreaType = types_value[types_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.SafeAreaType_ToNumeric(types_value_element))
            }
        }
        let edges_type : int32 = RuntimeType.UNDEFINED
        edges_type = runtimeType(edges)
        thisSerializer.writeInt8((edges_type).toChar())
        if ((edges_type) != (RuntimeType.UNDEFINED)) {
            const edges_value  = edges!
            thisSerializer.writeInt32((edges_value.length).toInt())
            for (let edges_value_counter_i = 0; edges_value_counter_i < edges_value.length; edges_value_counter_i++) {
                const edges_value_element : SafeAreaEdge = edges_value[edges_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.SafeAreaEdge_ToNumeric(edges_value_element))
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setExpandSafeArea(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundAttribute(builder: CustomBuilder | undefined, options?: BackgroundOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let builder_type : int32 = RuntimeType.UNDEFINED
        builder_type = runtimeType(builder)
        thisSerializer.writeInt8((builder_type).toChar())
        if ((builder_type) != (RuntimeType.UNDEFINED)) {
            const builder_value  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builder_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BackgroundOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackground(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage0Attribute(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let src_type : int32 = RuntimeType.UNDEFINED
        src_type = runtimeType(src)
        thisSerializer.writeInt8((src_type).toChar())
        if ((src_type) != (RuntimeType.UNDEFINED)) {
            const src_value  = src!
            let src_value_type : int32 = RuntimeType.UNDEFINED
            src_value_type = runtimeType(src_value)
            if ((RuntimeType.STRING == src_value_type) || (RuntimeType.OBJECT == src_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const src_value_0  = src_value as ResourceStr
                let src_value_0_type : int32 = RuntimeType.UNDEFINED
                src_value_0_type = runtimeType(src_value_0)
                if (RuntimeType.STRING == src_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const src_value_0_0  = src_value_0 as string
                    thisSerializer.writeString(src_value_0_0)
                }
                else if (RuntimeType.OBJECT == src_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const src_value_0_1  = src_value_0 as Resource
                    Resource_serializer.write(thisSerializer, src_value_0_1)
                }
            }
            else if (TypeChecker.isimage_PixelMap(src_value, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const src_value_1  = src_value as image.PixelMap
                image_PixelMap_serializer.write(thisSerializer, src_value_1)
            }
        }
        let repeat_type : int32 = RuntimeType.UNDEFINED
        repeat_type = runtimeType(repeat)
        thisSerializer.writeInt8((repeat_type).toChar())
        if ((repeat_type) != (RuntimeType.UNDEFINED)) {
            const repeat_value  = (repeat as ImageRepeat)
            thisSerializer.writeInt32(TypeChecker.ImageRepeat_ToNumeric(repeat_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage1Attribute(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let src_type : int32 = RuntimeType.UNDEFINED
        src_type = runtimeType(src)
        thisSerializer.writeInt8((src_type).toChar())
        if ((src_type) != (RuntimeType.UNDEFINED)) {
            const src_value  = src!
            let src_value_type : int32 = RuntimeType.UNDEFINED
            src_value_type = runtimeType(src_value)
            if ((RuntimeType.STRING == src_value_type) || (RuntimeType.OBJECT == src_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const src_value_0  = src_value as ResourceStr
                let src_value_0_type : int32 = RuntimeType.UNDEFINED
                src_value_0_type = runtimeType(src_value_0)
                if (RuntimeType.STRING == src_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const src_value_0_0  = src_value_0 as string
                    thisSerializer.writeString(src_value_0_0)
                }
                else if (RuntimeType.OBJECT == src_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const src_value_0_1  = src_value_0 as Resource
                    Resource_serializer.write(thisSerializer, src_value_0_1)
                }
            }
            else if (TypeChecker.isimage_PixelMap(src_value, false, false)) {
                thisSerializer.writeInt8((1).toChar())
                const src_value_1  = src_value as image.PixelMap
                image_PixelMap_serializer.write(thisSerializer, src_value_1)
            }
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BackgroundImageOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundBlurStyleAttribute(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let style_type : int32 = RuntimeType.UNDEFINED
        style_type = runtimeType(style)
        thisSerializer.writeInt8((style_type).toChar())
        if ((style_type) != (RuntimeType.UNDEFINED)) {
            const style_value  = (style as BlurStyle)
            thisSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(style_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BackgroundBlurStyleOptions_serializer.write(thisSerializer, options_value)
        }
        let sysOptions_type : int32 = RuntimeType.UNDEFINED
        sysOptions_type = runtimeType(sysOptions)
        thisSerializer.writeInt8((sysOptions_type).toChar())
        if ((sysOptions_type) != (RuntimeType.UNDEFINED)) {
            const sysOptions_value  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundEffect1Attribute(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BackgroundEffectOptions_serializer.write(thisSerializer, options_value)
        }
        let sysOptions_type : int32 = RuntimeType.UNDEFINED
        sysOptions_type = runtimeType(sysOptions)
        thisSerializer.writeInt8((sysOptions_type).toChar())
        if ((sysOptions_type) != (RuntimeType.UNDEFINED)) {
            const sysOptions_value  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundEffect1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundBlurStyleAttribute(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let style_type : int32 = RuntimeType.UNDEFINED
        style_type = runtimeType(style)
        thisSerializer.writeInt8((style_type).toChar())
        if ((style_type) != (RuntimeType.UNDEFINED)) {
            const style_value  = (style as BlurStyle)
            thisSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(style_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            ForegroundBlurStyleOptions_serializer.write(thisSerializer, options_value)
        }
        let sysOptions_type : int32 = RuntimeType.UNDEFINED
        sysOptions_type = runtimeType(sysOptions)
        thisSerializer.writeInt8((sysOptions_type).toChar())
        if ((sysOptions_type) != (RuntimeType.UNDEFINED)) {
            const sysOptions_value  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick1Attribute(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let event_type : int32 = RuntimeType.UNDEFINED
        event_type = runtimeType(event)
        thisSerializer.writeInt8((event_type).toChar())
        if ((event_type) != (RuntimeType.UNDEFINED)) {
            const event_value  = event!
            thisSerializer.holdAndWriteCallback(event_value)
        }
        let distanceThreshold_type : int32 = RuntimeType.UNDEFINED
        distanceThreshold_type = runtimeType(distanceThreshold)
        thisSerializer.writeInt8((distanceThreshold_type).toChar())
        if ((distanceThreshold_type) != (RuntimeType.UNDEFINED)) {
            const distanceThreshold_value  = distanceThreshold!
            thisSerializer.writeNumber(distanceThreshold_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopeIdAttribute(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let id_type : int32 = RuntimeType.UNDEFINED
        id_type = runtimeType(id)
        thisSerializer.writeInt8((id_type).toChar())
        if ((id_type) != (RuntimeType.UNDEFINED)) {
            const id_value  = id!
            thisSerializer.writeString(id_value)
        }
        let isGroup_type : int32 = RuntimeType.UNDEFINED
        isGroup_type = runtimeType(isGroup)
        thisSerializer.writeInt8((isGroup_type).toChar())
        if ((isGroup_type) != (RuntimeType.UNDEFINED)) {
            const isGroup_value  = isGroup!
            thisSerializer.writeBoolean(isGroup_value)
        }
        let arrowStepOut_type : int32 = RuntimeType.UNDEFINED
        arrowStepOut_type = runtimeType(arrowStepOut)
        thisSerializer.writeInt8((arrowStepOut_type).toChar())
        if ((arrowStepOut_type) != (RuntimeType.UNDEFINED)) {
            const arrowStepOut_value  = arrowStepOut!
            thisSerializer.writeBoolean(arrowStepOut_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopeId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopePriorityAttribute(scopeId: string | undefined, priority?: FocusPriority): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let scopeId_type : int32 = RuntimeType.UNDEFINED
        scopeId_type = runtimeType(scopeId)
        thisSerializer.writeInt8((scopeId_type).toChar())
        if ((scopeId_type) != (RuntimeType.UNDEFINED)) {
            const scopeId_value  = scopeId!
            thisSerializer.writeString(scopeId_value)
        }
        let priority_type : int32 = RuntimeType.UNDEFINED
        priority_type = runtimeType(priority)
        thisSerializer.writeInt8((priority_type).toChar())
        if ((priority_type) != (RuntimeType.UNDEFINED)) {
            const priority_value  = (priority as FocusPriority)
            thisSerializer.writeInt32(TypeChecker.FocusPriority_ToNumeric(priority_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopePriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition1Attribute(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let effect_type : int32 = RuntimeType.UNDEFINED
        effect_type = runtimeType(effect)
        thisSerializer.writeInt8((effect_type).toChar())
        if ((effect_type) != (RuntimeType.UNDEFINED)) {
            const effect_value  = effect!
            TransitionEffect_serializer.write(thisSerializer, effect_value)
        }
        let onFinish_type : int32 = RuntimeType.UNDEFINED
        onFinish_type = runtimeType(onFinish)
        thisSerializer.writeInt8((onFinish_type).toChar())
        if ((onFinish_type) != (RuntimeType.UNDEFINED)) {
            const onFinish_value  = onFinish!
            thisSerializer.holdAndWriteCallback(onFinish_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGestureAttribute(gesture: GestureType | undefined, mask?: GestureMask): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let gesture_type : int32 = RuntimeType.UNDEFINED
        gesture_type = runtimeType(gesture)
        thisSerializer.writeInt8((gesture_type).toChar())
        if ((gesture_type) != (RuntimeType.UNDEFINED)) {
            const gesture_value  = gesture!
            let gesture_value_type : int32 = RuntimeType.UNDEFINED
            gesture_value_type = runtimeType(gesture_value)
            if (TypeChecker.isGesture(gesture_value)) {
                thisSerializer.writeInt8((0).toChar())
                const gesture_value_0  = gesture_value as Gesture
                Gesture_serializer.write(thisSerializer, gesture_value_0)
            }
            else if (RuntimeType.OBJECT == gesture_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const gesture_value_1  = gesture_value as object
                thisSerializer.writeCustomObject("object", gesture_value_1)
            }
        }
        let mask_type : int32 = RuntimeType.UNDEFINED
        mask_type = runtimeType(mask)
        thisSerializer.writeInt8((mask_type).toChar())
        if ((mask_type) != (RuntimeType.UNDEFINED)) {
            const mask_value  = (mask as GestureMask)
            thisSerializer.writeInt32(TypeChecker.GestureMask_ToNumeric(mask_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGesture(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPriorityGestureAttribute(gesture: GestureType | undefined, mask?: GestureMask): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let gesture_type : int32 = RuntimeType.UNDEFINED
        gesture_type = runtimeType(gesture)
        thisSerializer.writeInt8((gesture_type).toChar())
        if ((gesture_type) != (RuntimeType.UNDEFINED)) {
            const gesture_value  = gesture!
            let gesture_value_type : int32 = RuntimeType.UNDEFINED
            gesture_value_type = runtimeType(gesture_value)
            if (TypeChecker.isGesture(gesture_value)) {
                thisSerializer.writeInt8((0).toChar())
                const gesture_value_0  = gesture_value as Gesture
                Gesture_serializer.write(thisSerializer, gesture_value_0)
            }
            else if (RuntimeType.OBJECT == gesture_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const gesture_value_1  = gesture_value as object
                thisSerializer.writeCustomObject("object", gesture_value_1)
            }
        }
        let mask_type : int32 = RuntimeType.UNDEFINED
        mask_type = runtimeType(mask)
        thisSerializer.writeInt8((mask_type).toChar())
        if ((mask_type) != (RuntimeType.UNDEFINED)) {
            const mask_value  = (mask as GestureMask)
            thisSerializer.writeInt32(TypeChecker.GestureMask_ToNumeric(mask_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPriorityGesture(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setParallelGestureAttribute(gesture: GestureType | undefined, mask?: GestureMask): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let gesture_type : int32 = RuntimeType.UNDEFINED
        gesture_type = runtimeType(gesture)
        thisSerializer.writeInt8((gesture_type).toChar())
        if ((gesture_type) != (RuntimeType.UNDEFINED)) {
            const gesture_value  = gesture!
            let gesture_value_type : int32 = RuntimeType.UNDEFINED
            gesture_value_type = runtimeType(gesture_value)
            if (TypeChecker.isGesture(gesture_value)) {
                thisSerializer.writeInt8((0).toChar())
                const gesture_value_0  = gesture_value as Gesture
                Gesture_serializer.write(thisSerializer, gesture_value_0)
            }
            else if (RuntimeType.OBJECT == gesture_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const gesture_value_1  = gesture_value as object
                thisSerializer.writeCustomObject("object", gesture_value_1)
            }
        }
        let mask_type : int32 = RuntimeType.UNDEFINED
        mask_type = runtimeType(mask)
        thisSerializer.writeInt8((mask_type).toChar())
        if ((mask_type) != (RuntimeType.UNDEFINED)) {
            const mask_value  = (mask as GestureMask)
            thisSerializer.writeInt32(TypeChecker.GestureMask_ToNumeric(mask_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setParallelGesture(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlurAttribute(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let blurRadius_type : int32 = RuntimeType.UNDEFINED
        blurRadius_type = runtimeType(blurRadius)
        thisSerializer.writeInt8((blurRadius_type).toChar())
        if ((blurRadius_type) != (RuntimeType.UNDEFINED)) {
            const blurRadius_value  = blurRadius!
            thisSerializer.writeNumber(blurRadius_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BlurOptions_serializer.write(thisSerializer, options_value)
        }
        let sysOptions_type : int32 = RuntimeType.UNDEFINED
        sysOptions_type = runtimeType(sysOptions)
        thisSerializer.writeInt8((sysOptions_type).toChar())
        if ((sysOptions_type) != (RuntimeType.UNDEFINED)) {
            const sysOptions_value  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientBlurAttribute(value: number | undefined, options: LinearGradientBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            LinearGradientBlurOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradientBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSystemBarEffectAttribute(): void {
        ArkUIGeneratedNativeModule._CommonMethod_setSystemBarEffect(this.peer.ptr)
    }
    setUseEffect1Attribute(useEffect: boolean | undefined, effectType: EffectType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let useEffect_type : int32 = RuntimeType.UNDEFINED
        useEffect_type = runtimeType(useEffect)
        thisSerializer.writeInt8((useEffect_type).toChar())
        if ((useEffect_type) != (RuntimeType.UNDEFINED)) {
            const useEffect_value  = useEffect!
            thisSerializer.writeBoolean(useEffect_value)
        }
        let effectType_type : int32 = RuntimeType.UNDEFINED
        effectType_type = runtimeType(effectType)
        thisSerializer.writeInt8((effectType_type).toChar())
        if ((effectType_type) != (RuntimeType.UNDEFINED)) {
            const effectType_value  = (effectType as EffectType)
            thisSerializer.writeInt32(TypeChecker.EffectType_ToNumeric(effectType_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackdropBlurAttribute(radius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let radius_type : int32 = RuntimeType.UNDEFINED
        radius_type = runtimeType(radius)
        thisSerializer.writeInt8((radius_type).toChar())
        if ((radius_type) != (RuntimeType.UNDEFINED)) {
            const radius_value  = radius!
            thisSerializer.writeNumber(radius_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            BlurOptions_serializer.write(thisSerializer, options_value)
        }
        let sysOptions_type : int32 = RuntimeType.UNDEFINED
        sysOptions_type = runtimeType(sysOptions)
        thisSerializer.writeInt8((sysOptions_type).toChar())
        if ((sysOptions_type) != (RuntimeType.UNDEFINED)) {
            const sysOptions_value  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackdropBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSharedTransitionAttribute(id: string | undefined, options?: sharedTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let id_type : int32 = RuntimeType.UNDEFINED
        id_type = runtimeType(id)
        thisSerializer.writeInt8((id_type).toChar())
        if ((id_type) != (RuntimeType.UNDEFINED)) {
            const id_value  = id!
            thisSerializer.writeString(id_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            sharedTransitionOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSharedTransition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainModeAttribute(direction: Axis | undefined, style: ChainStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let direction_type : int32 = RuntimeType.UNDEFINED
        direction_type = runtimeType(direction)
        thisSerializer.writeInt8((direction_type).toChar())
        if ((direction_type) != (RuntimeType.UNDEFINED)) {
            const direction_value  = (direction as Axis)
            thisSerializer.writeInt32(TypeChecker.Axis_ToNumeric(direction_value))
        }
        let style_type : int32 = RuntimeType.UNDEFINED
        style_type = runtimeType(style)
        thisSerializer.writeInt8((style_type).toChar())
        if ((style_type) != (RuntimeType.UNDEFINED)) {
            const style_value  = (style as ChainStyle)
            thisSerializer.writeInt32(TypeChecker.ChainStyle_ToNumeric(style_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop1Attribute(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let eventCallback_type : int32 = RuntimeType.UNDEFINED
        eventCallback_type = runtimeType(eventCallback)
        thisSerializer.writeInt8((eventCallback_type).toChar())
        if ((eventCallback_type) != (RuntimeType.UNDEFINED)) {
            const eventCallback_value  = eventCallback!
            thisSerializer.holdAndWriteCallback(eventCallback_value)
        }
        let dropOptions_type : int32 = RuntimeType.UNDEFINED
        dropOptions_type = runtimeType(dropOptions)
        thisSerializer.writeInt8((dropOptions_type).toChar())
        if ((dropOptions_type) != (RuntimeType.UNDEFINED)) {
            const dropOptions_value  = dropOptions!
            DropOptions_serializer.write(thisSerializer, dropOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreview1Attribute(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let preview_type : int32 = RuntimeType.UNDEFINED
        preview_type = runtimeType(preview)
        thisSerializer.writeInt8((preview_type).toChar())
        if ((preview_type) != (RuntimeType.UNDEFINED)) {
            const preview_value  = preview!
            let preview_value_type : int32 = RuntimeType.UNDEFINED
            preview_value_type = runtimeType(preview_value)
            if (RuntimeType.FUNCTION == preview_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const preview_value_0  = preview_value as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(preview_value_0))
            }
            else if (RuntimeType.OBJECT == preview_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const preview_value_1  = preview_value as DragItemInfo
                DragItemInfo_serializer.write(thisSerializer, preview_value_1)
            }
            else if (RuntimeType.STRING == preview_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const preview_value_2  = preview_value as string
                thisSerializer.writeString(preview_value_2)
            }
        }
        let config_type : int32 = RuntimeType.UNDEFINED
        config_type = runtimeType(config)
        thisSerializer.writeInt8((config_type).toChar())
        if ((config_type) != (RuntimeType.UNDEFINED)) {
            const config_value  = config!
            PreviewConfiguration_serializer.write(thisSerializer, config_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreview1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreviewOptionsAttribute(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            DragPreviewOptions_serializer.write(thisSerializer, value_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            DragInteractionOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreviewOptions(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOverlayAttribute(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as string
                thisSerializer.writeString(value_value_0)
            }
            else if (RuntimeType.FUNCTION == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_value_1))
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as ComponentContent
                ComponentContent_serializer.write(thisSerializer, value_value_2)
            }
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            OverlayOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOverlay(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlendModeAttribute(value: BlendMode | undefined, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as BlendMode)
            thisSerializer.writeInt32(TypeChecker.BlendMode_ToNumeric(value_value))
        }
        let type_type : int32 = RuntimeType.UNDEFINED
        type_type = runtimeType(type)
        thisSerializer.writeInt8((type_type).toChar())
        if ((type_type) != (RuntimeType.UNDEFINED)) {
            const type_value  = (type as BlendApplyType)
            thisSerializer.writeInt32(TypeChecker.BlendApplyType_ToNumeric(type_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAdvancedBlendModeAttribute(effect: BlendMode | uiEffect.Blender | undefined, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let effect_type : int32 = RuntimeType.UNDEFINED
        effect_type = runtimeType(effect)
        thisSerializer.writeInt8((effect_type).toChar())
        if ((effect_type) != (RuntimeType.UNDEFINED)) {
            const effect_value  = effect!
            let effect_value_type : int32 = RuntimeType.UNDEFINED
            effect_value_type = runtimeType(effect_value)
            if (TypeChecker.isBlendMode(effect_value)) {
                thisSerializer.writeInt8((0).toChar())
                const effect_value_0  = effect_value as BlendMode
                thisSerializer.writeInt32(TypeChecker.BlendMode_ToNumeric(effect_value_0))
            }
            else if (RuntimeType.OBJECT == effect_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const effect_value_1  = effect_value as uiEffect.Blender
                uiEffect_BrightnessBlender_serializer.write(thisSerializer, effect_value_1)
            }
        }
        let type_type : int32 = RuntimeType.UNDEFINED
        type_type = runtimeType(type)
        thisSerializer.writeInt8((type_type).toChar())
        if ((type_type) != (RuntimeType.UNDEFINED)) {
            const type_value  = (type as BlendApplyType)
            thisSerializer.writeInt32(TypeChecker.BlendApplyType_ToNumeric(type_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAdvancedBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGeometryTransition1Attribute(id: string | undefined, options?: GeometryTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let id_type : int32 = RuntimeType.UNDEFINED
        id_type = runtimeType(id)
        thisSerializer.writeInt8((id_type).toChar())
        if ((id_type) != (RuntimeType.UNDEFINED)) {
            const id_value  = id!
            thisSerializer.writeString(id_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            GeometryTransitionOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGeometryTransition1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindTipsAttribute(message: TipsMessageType | undefined, options?: TipsOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let message_type : int32 = RuntimeType.UNDEFINED
        message_type = runtimeType(message)
        thisSerializer.writeInt8((message_type).toChar())
        if ((message_type) != (RuntimeType.UNDEFINED)) {
            const message_value  = message!
            let message_value_type : int32 = RuntimeType.UNDEFINED
            message_value_type = runtimeType(message_value)
            if ((RuntimeType.STRING == message_value_type) || (RuntimeType.OBJECT == message_value_type)) {
                thisSerializer.writeInt8((0).toChar())
                const message_value_0  = message_value as ResourceStr
                let message_value_0_type : int32 = RuntimeType.UNDEFINED
                message_value_0_type = runtimeType(message_value_0)
                if (RuntimeType.STRING == message_value_0_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const message_value_0_0  = message_value_0 as string
                    thisSerializer.writeString(message_value_0_0)
                }
                else if (RuntimeType.OBJECT == message_value_0_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const message_value_0_1  = message_value_0 as Resource
                    Resource_serializer.write(thisSerializer, message_value_0_1)
                }
            }
            else if (TypeChecker.isStyledString(message_value, false)) {
                thisSerializer.writeInt8((1).toChar())
                const message_value_1  = message_value as StyledString
                StyledString_serializer.write(thisSerializer, message_value_1)
            }
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            TipsOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindTips(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindPopupAttribute(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let show_type : int32 = RuntimeType.UNDEFINED
        show_type = runtimeType(show)
        thisSerializer.writeInt8((show_type).toChar())
        if ((show_type) != (RuntimeType.UNDEFINED)) {
            const show_value  = show!
            thisSerializer.writeBoolean(show_value)
        }
        let popup_type : int32 = RuntimeType.UNDEFINED
        popup_type = runtimeType(popup)
        thisSerializer.writeInt8((popup_type).toChar())
        if ((popup_type) != (RuntimeType.UNDEFINED)) {
            const popup_value  = popup!
            let popup_value_type : int32 = RuntimeType.UNDEFINED
            popup_value_type = runtimeType(popup_value)
            if (TypeChecker.isPopupOptions(popup_value, false, true, false, false, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true)) {
                thisSerializer.writeInt8((0).toChar())
                const popup_value_0  = popup_value as PopupOptions
                PopupOptions_serializer.write(thisSerializer, popup_value_0)
            }
            else if (TypeChecker.isCustomPopupOptions(popup_value, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true)) {
                thisSerializer.writeInt8((1).toChar())
                const popup_value_1  = popup_value as CustomPopupOptions
                CustomPopupOptions_serializer.write(thisSerializer, popup_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindPopup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu0Attribute(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let content_type : int32 = RuntimeType.UNDEFINED
        content_type = runtimeType(content)
        thisSerializer.writeInt8((content_type).toChar())
        if ((content_type) != (RuntimeType.UNDEFINED)) {
            const content_value  = content!
            let content_value_type : int32 = RuntimeType.UNDEFINED
            content_value_type = runtimeType(content_value)
            if (RuntimeType.OBJECT == content_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const content_value_0  = content_value as Array<MenuElement>
                thisSerializer.writeInt32((content_value_0.length).toInt())
                for (let content_value_0_counter_i = 0; content_value_0_counter_i < content_value_0.length; content_value_0_counter_i++) {
                    const content_value_0_element : MenuElement = content_value_0[content_value_0_counter_i]
                    MenuElement_serializer.write(thisSerializer, content_value_0_element)
                }
            }
            else if (RuntimeType.FUNCTION == content_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const content_value_1  = content_value as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(content_value_1))
            }
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            MenuOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu1Attribute(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isShow_type : int32 = RuntimeType.UNDEFINED
        isShow_type = runtimeType(isShow)
        thisSerializer.writeInt8((isShow_type).toChar())
        if ((isShow_type) != (RuntimeType.UNDEFINED)) {
            const isShow_value  = isShow!
            thisSerializer.writeBoolean(isShow_value)
        }
        let content_type : int32 = RuntimeType.UNDEFINED
        content_type = runtimeType(content)
        thisSerializer.writeInt8((content_type).toChar())
        if ((content_type) != (RuntimeType.UNDEFINED)) {
            const content_value  = content!
            let content_value_type : int32 = RuntimeType.UNDEFINED
            content_value_type = runtimeType(content_value)
            if (RuntimeType.OBJECT == content_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const content_value_0  = content_value as Array<MenuElement>
                thisSerializer.writeInt32((content_value_0.length).toInt())
                for (let content_value_0_counter_i = 0; content_value_0_counter_i < content_value_0.length; content_value_0_counter_i++) {
                    const content_value_0_element : MenuElement = content_value_0[content_value_0_counter_i]
                    MenuElement_serializer.write(thisSerializer, content_value_0_element)
                }
            }
            else if (RuntimeType.FUNCTION == content_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const content_value_1  = content_value as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(content_value_1))
            }
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            MenuOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu0Attribute(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let content_type : int32 = RuntimeType.UNDEFINED
        content_type = runtimeType(content)
        thisSerializer.writeInt8((content_type).toChar())
        if ((content_type) != (RuntimeType.UNDEFINED)) {
            const content_value  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(content_value))
        }
        let responseType_type : int32 = RuntimeType.UNDEFINED
        responseType_type = runtimeType(responseType)
        thisSerializer.writeInt8((responseType_type).toChar())
        if ((responseType_type) != (RuntimeType.UNDEFINED)) {
            const responseType_value  = (responseType as ResponseType)
            thisSerializer.writeInt32(TypeChecker.ResponseType_ToNumeric(responseType_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            ContextMenuOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu1Attribute(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isShown_type : int32 = RuntimeType.UNDEFINED
        isShown_type = runtimeType(isShown)
        thisSerializer.writeInt8((isShown_type).toChar())
        if ((isShown_type) != (RuntimeType.UNDEFINED)) {
            const isShown_value  = isShown!
            thisSerializer.writeBoolean(isShown_value)
        }
        let content_type : int32 = RuntimeType.UNDEFINED
        content_type = runtimeType(content)
        thisSerializer.writeInt8((content_type).toChar())
        if ((content_type) != (RuntimeType.UNDEFINED)) {
            const content_value  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(content_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            ContextMenuOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover0Attribute(isShow: boolean | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isShow_type : int32 = RuntimeType.UNDEFINED
        isShow_type = runtimeType(isShow)
        thisSerializer.writeInt8((isShow_type).toChar())
        if ((isShow_type) != (RuntimeType.UNDEFINED)) {
            const isShow_value  = isShow!
            thisSerializer.writeBoolean(isShow_value)
        }
        let builder_type : int32 = RuntimeType.UNDEFINED
        builder_type = runtimeType(builder)
        thisSerializer.writeInt8((builder_type).toChar())
        if ((builder_type) != (RuntimeType.UNDEFINED)) {
            const builder_value  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builder_value))
        }
        let type_type : int32 = RuntimeType.UNDEFINED
        type_type = runtimeType(type)
        thisSerializer.writeInt8((type_type).toChar())
        if ((type_type) != (RuntimeType.UNDEFINED)) {
            const type_value  = (type as ModalTransition)
            thisSerializer.writeInt32(TypeChecker.ModalTransition_ToNumeric(type_value))
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover1Attribute(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isShow_type : int32 = RuntimeType.UNDEFINED
        isShow_type = runtimeType(isShow)
        thisSerializer.writeInt8((isShow_type).toChar())
        if ((isShow_type) != (RuntimeType.UNDEFINED)) {
            const isShow_value  = isShow!
            thisSerializer.writeBoolean(isShow_value)
        }
        let builder_type : int32 = RuntimeType.UNDEFINED
        builder_type = runtimeType(builder)
        thisSerializer.writeInt8((builder_type).toChar())
        if ((builder_type) != (RuntimeType.UNDEFINED)) {
            const builder_value  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builder_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            ContentCoverOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindSheetAttribute(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isShow_type : int32 = RuntimeType.UNDEFINED
        isShow_type = runtimeType(isShow)
        thisSerializer.writeInt8((isShow_type).toChar())
        if ((isShow_type) != (RuntimeType.UNDEFINED)) {
            const isShow_value  = isShow!
            thisSerializer.writeBoolean(isShow_value)
        }
        let builder_type : int32 = RuntimeType.UNDEFINED
        builder_type = runtimeType(builder)
        thisSerializer.writeInt8((builder_type).toChar())
        if ((builder_type) != (RuntimeType.UNDEFINED)) {
            const builder_value  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builder_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            SheetOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindSheet(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaChangeAttribute(ratios: Array<number> | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let ratios_type : int32 = RuntimeType.UNDEFINED
        ratios_type = runtimeType(ratios)
        thisSerializer.writeInt8((ratios_type).toChar())
        if ((ratios_type) != (RuntimeType.UNDEFINED)) {
            const ratios_value  = ratios!
            thisSerializer.writeInt32((ratios_value.length).toInt())
            for (let ratios_value_counter_i = 0; ratios_value_counter_i < ratios_value.length; ratios_value_counter_i++) {
                const ratios_value_element : number = ratios_value[ratios_value_counter_i]
                thisSerializer.writeNumber(ratios_value_element)
            }
        }
        let event_type : int32 = RuntimeType.UNDEFINED
        event_type = runtimeType(event)
        thisSerializer.writeInt8((event_type).toChar())
        if ((event_type) != (RuntimeType.UNDEFINED)) {
            const event_value  = event!
            thisSerializer.holdAndWriteCallback(event_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaApproximateChangeAttribute(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            VisibleAreaEventOptions_serializer.write(thisSerializer, options_value)
        }
        let event_type : int32 = RuntimeType.UNDEFINED
        event_type = runtimeType(event)
        thisSerializer.writeInt8((event_type).toChar())
        if ((event_type) != (RuntimeType.UNDEFINED)) {
            const event_value  = event!
            thisSerializer.holdAndWriteCallback(event_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaApproximateChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyboardShortcutAttribute(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as string
                thisSerializer.writeString(value_value_0)
            }
            else if (TypeChecker.isFunctionKey(value_value)) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as FunctionKey
                thisSerializer.writeInt32(TypeChecker.FunctionKey_ToNumeric(value_value_1))
            }
        }
        let keys_type : int32 = RuntimeType.UNDEFINED
        keys_type = runtimeType(keys)
        thisSerializer.writeInt8((keys_type).toChar())
        if ((keys_type) != (RuntimeType.UNDEFINED)) {
            const keys_value  = keys!
            thisSerializer.writeInt32((keys_value.length).toInt())
            for (let keys_value_counter_i = 0; keys_value_counter_i < keys_value.length; keys_value_counter_i++) {
                const keys_value_element : ModifierKey = keys_value[keys_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.ModifierKey_ToNumeric(keys_value_element))
            }
        }
        let action_type : int32 = RuntimeType.UNDEFINED
        action_type = runtimeType(action)
        thisSerializer.writeInt8((action_type).toChar())
        if ((action_type) != (RuntimeType.UNDEFINED)) {
            const action_value  = action!
            thisSerializer.holdAndWriteCallback(action_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKeyboardShortcut(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityGroup1Attribute(isGroup: boolean | undefined, accessibilityOptions: AccessibilityOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let isGroup_type : int32 = RuntimeType.UNDEFINED
        isGroup_type = runtimeType(isGroup)
        thisSerializer.writeInt8((isGroup_type).toChar())
        if ((isGroup_type) != (RuntimeType.UNDEFINED)) {
            const isGroup_value  = isGroup!
            thisSerializer.writeBoolean(isGroup_value)
        }
        let accessibilityOptions_type : int32 = RuntimeType.UNDEFINED
        accessibilityOptions_type = runtimeType(accessibilityOptions)
        thisSerializer.writeInt8((accessibilityOptions_type).toChar())
        if ((accessibilityOptions_type) != (RuntimeType.UNDEFINED)) {
            const accessibilityOptions_value  = accessibilityOptions!
            AccessibilityOptions_serializer.write(thisSerializer, accessibilityOptions_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityGroup1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin1Attribute(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let callback__type : int32 = RuntimeType.UNDEFINED
        callback__type = runtimeType(callback_)
        thisSerializer.writeInt8((callback__type).toChar())
        if ((callback__type) != (RuntimeType.UNDEFINED)) {
            const callback__value  = callback_!
            thisSerializer.holdAndWriteCallback(callback__value)
        }
        let exposeInnerGesture_type : int32 = RuntimeType.UNDEFINED
        exposeInnerGesture_type = runtimeType(exposeInnerGesture)
        thisSerializer.writeInt8((exposeInnerGesture_type).toChar())
        if ((exposeInnerGesture_type) != (RuntimeType.UNDEFINED)) {
            const exposeInnerGesture_value  = exposeInnerGesture!
            thisSerializer.writeBoolean(exposeInnerGesture_value)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonShapeMethodPeer extends ArkCommonMethodPeer {
    protected constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonShapeMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonShapeMethod_construct(peerId, flags)
        const _peer  = new ArkCommonShapeMethodPeer(_peerPtr, peerId, "CommonShapeMethod", flags)
        component?.setPeer(_peer)
        return _peer
    }
    setStrokeAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isColor(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Color
                thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0))
            }
            else if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as number
                thisSerializer.writeNumber(value_value_1)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as string
                thisSerializer.writeString(value_value_2)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((3).toChar())
                const value_value_3  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_3)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStroke(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isColor(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Color
                thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0))
            }
            else if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as number
                thisSerializer.writeNumber(value_value_1)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as string
                thisSerializer.writeString(value_value_2)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((3).toChar())
                const value_value_3  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_3)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFill(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashOffsetAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineCapAttribute(value: LineCapStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as LineCapStyle)
            thisSerializer.writeInt32(TypeChecker.LineCapStyle_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineCap(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineJoinAttribute(value: LineJoinStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as LineJoinStyle)
            thisSerializer.writeInt32(TypeChecker.LineJoinStyle_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineJoin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeMiterLimitAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeMiterLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeOpacityAttribute(value: number | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillOpacityAttribute(value: number | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFillOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeWidthAttribute(value: Length | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as string
                thisSerializer.writeString(value_value_0)
            }
            else if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as number
                thisSerializer.writeNumber(value_value_1)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAntiAliasAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setAntiAlias(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashArrayAttribute(value: Array<Length> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeInt32((value_value.length).toInt())
            for (let value_value_counter_i = 0; value_value_counter_i < value_value.length; value_value_counter_i++) {
                const value_value_element : Length = value_value[value_value_counter_i]
                let value_value_element_type : int32 = RuntimeType.UNDEFINED
                value_value_element_type = runtimeType(value_value_element)
                if (RuntimeType.STRING == value_value_element_type) {
                    thisSerializer.writeInt8((0).toChar())
                    const value_value_element_0  = value_value_element as string
                    thisSerializer.writeString(value_value_element_0)
                }
                else if (RuntimeType.NUMBER == value_value_element_type) {
                    thisSerializer.writeInt8((1).toChar())
                    const value_value_element_1  = value_value_element as number
                    thisSerializer.writeNumber(value_value_element_1)
                }
                else if (RuntimeType.OBJECT == value_value_element_type) {
                    thisSerializer.writeInt8((2).toChar())
                    const value_value_element_2  = value_value_element as Resource
                    Resource_serializer.write(thisSerializer, value_value_element_2)
                }
            }
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashArray(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkScrollableCommonMethodPeer extends ArkCommonMethodPeer {
    protected constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkScrollableCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._ScrollableCommonMethod_construct(peerId, flags)
        const _peer  = new ArkScrollableCommonMethodPeer(_peerPtr, peerId, "ScrollableCommonMethod", flags)
        component?.setPeer(_peer)
        return _peer
    }
    setScrollBarAttribute(value: BarState | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as BarState)
            thisSerializer.writeInt32(TypeChecker.BarState_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBar(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarColorAttribute(value: Color | number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isColor(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as Color
                thisSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_value_0))
            }
            else if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as number
                thisSerializer.writeNumber(value_value_1)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((2).toChar())
                const value_value_2  = value_value as string
                thisSerializer.writeString(value_value_2)
            }
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarWidthAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.STRING == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as string
                thisSerializer.writeString(value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNestedScrollAttribute(value: NestedScrollOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            NestedScrollOptions_serializer.write(thisSerializer, value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setNestedScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnableScrollInteractionAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEnableScrollInteraction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFrictionAttribute(value: number | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (RuntimeType.NUMBER == value_value_type) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as number
                thisSerializer.writeNumber(value_value_0)
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as Resource
                Resource_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFriction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachEndAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStopAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.holdAndWriteCallback(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlingSpeedLimitAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeNumber(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFlingSpeedLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipContentAttribute(value: ContentClipMode | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            let value_value_type : int32 = RuntimeType.UNDEFINED
            value_value_type = runtimeType(value_value)
            if (TypeChecker.isContentClipMode(value_value)) {
                thisSerializer.writeInt8((0).toChar())
                const value_value_0  = value_value as ContentClipMode
                thisSerializer.writeInt32(TypeChecker.ContentClipMode_ToNumeric(value_value_0))
            }
            else if (RuntimeType.OBJECT == value_value_type) {
                thisSerializer.writeInt8((1).toChar())
                const value_value_1  = value_value as RectShape
                RectShape_serializer.write(thisSerializer, value_value_1)
            }
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setClipContent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDigitalCrownSensitivityAttribute(value: CrownSensitivity | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = (value as CrownSensitivity)
            thisSerializer.writeInt32(TypeChecker.CrownSensitivity_ToNumeric(value_value))
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setDigitalCrownSensitivity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackToTopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let value_type : int32 = RuntimeType.UNDEFINED
        value_type = runtimeType(value)
        thisSerializer.writeInt8((value_type).toChar())
        if ((value_type) != (RuntimeType.UNDEFINED)) {
            const value_value  = value!
            thisSerializer.writeBoolean(value_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setBackToTop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEdgeEffectAttribute(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let edgeEffect_type : int32 = RuntimeType.UNDEFINED
        edgeEffect_type = runtimeType(edgeEffect)
        thisSerializer.writeInt8((edgeEffect_type).toChar())
        if ((edgeEffect_type) != (RuntimeType.UNDEFINED)) {
            const edgeEffect_value  = (edgeEffect as EdgeEffect)
            thisSerializer.writeInt32(TypeChecker.EdgeEffect_ToNumeric(edgeEffect_value))
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            EdgeEffectOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEdgeEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFadingEdgeAttribute(enabled: boolean | undefined, options?: FadingEdgeOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let enabled_type : int32 = RuntimeType.UNDEFINED
        enabled_type = runtimeType(enabled)
        thisSerializer.writeInt8((enabled_type).toChar())
        if ((enabled_type) != (RuntimeType.UNDEFINED)) {
            const enabled_value  = enabled!
            thisSerializer.writeBoolean(enabled_value)
        }
        let options_type : int32 = RuntimeType.UNDEFINED
        options_type = runtimeType(options)
        thisSerializer.writeInt8((options_type).toChar())
        if ((options_type) != (RuntimeType.UNDEFINED)) {
            const options_value  = options!
            FadingEdgeOptions_serializer.write(thisSerializer, options_value)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFadingEdge(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface TransitionOptions {
    type?: TransitionType;
    opacity?: number;
    translate?: TranslateOptions;
    scale?: ScaleOptions;
    rotate?: RotateOptions;
}
export interface InputCounterOptions {
    thresholdPercentage?: number;
    highlightBorder?: boolean;
}
export interface TextDecorationOptions {
    type: TextDecorationType;
    color?: ResourceColor;
    style?: TextDecorationStyle;
}
export interface DividerStyle {
    strokeWidth: Length;
    color?: ResourceColor;
    startMargin?: Length;
    endMargin?: Length;
}
export type ReuseIdCallback = () => string;
export interface ReuseOptions {
    reuseId?: ReuseIdCallback;
}
export { Context } from "./../generated/application.Context"
export interface Configuration {
    readonly colorMode: string;
    readonly fontScale: number;
}
export interface Rectangle {
    x?: Length;
    y?: Length;
    width?: Length;
    height?: Length;
}
export interface ExpectedFrameRateRange {
    min: number;
    max: number;
    expected: number;
}
export enum AccessibilitySamePageMode {
    SEMI_SILENT = 0,
    FULL_SILENT = 1
}
export enum AccessibilityRoleType {
    ACTION_SHEET = 0,
    ALERT_DIALOG = 1,
    INDEXER_COMPONENT = 2,
    BADGE_COMPONENT = 3,
    BLANK = 4,
    BUTTON = 5,
    BACK_BUTTON = 6,
    SHEET_DRAG_BAR = 7,
    CALENDAR_PICKER = 8,
    CALENDAR = 9,
    CANVAS = 10,
    CANVAS_GRADIENT = 11,
    CANVAS_PATTERN = 12,
    CHECKBOX = 13,
    CHECKBOX_GROUP = 14,
    CIRCLE = 15,
    COLUMN_SPLIT = 16,
    COLUMN = 17,
    CANVAS_RENDERING_CONTEXT_2D = 18,
    CHART = 19,
    COUNTER = 20,
    CONTAINER_MODAL = 21,
    DATA_PANEL = 22,
    DATE_PICKER = 23,
    DIALOG = 24,
    DIVIDER = 25,
    DRAG_BAR = 26,
    EFFECT_COMPONENT = 27,
    ELLIPSE = 28,
    FLEX = 29,
    FLOW_ITEM = 30,
    FORM_COMPONENT = 31,
    FORM_LINK = 32,
    GAUGE = 33,
    GRID = 34,
    GRID_COL = 35,
    GRID_CONTAINER = 36,
    GRID_ITEM = 37,
    GRID_ROW = 38,
    HYPERLINK = 39,
    IMAGE = 40,
    IMAGE_ANIMATOR = 41,
    IMAGE_BITMAP = 42,
    IMAGE_DATA = 43,
    IMAGE_SPAN = 44,
    LABEL = 45,
    LINE = 46,
    LIST = 47,
    LIST_ITEM = 48,
    LIST_ITEM_GROUP = 49,
    LOADING_PROGRESS = 50,
    MARQUEE = 51,
    MATRIX2D = 52,
    MENU = 53,
    MENU_ITEM = 54,
    MENU_ITEM_GROUP = 55,
    NAV_DESTINATION = 56,
    NAV_ROUTER = 57,
    NAVIGATION = 58,
    NAVIGATION_BAR = 59,
    NAVIGATION_MENU = 60,
    NAVIGATOR = 61,
    OFFSCREEN_CANVAS = 62,
    OFFSCREEN_CANVAS_RENDERING_CONTEXT2D = 63,
    OPTION = 64,
    PANEL = 65,
    PAPER_PAGE = 66,
    PATH = 67,
    PATH2D = 68,
    PATTERN_LOCK = 69,
    PICKER = 70,
    PICKER_VIEW = 71,
    PLUGIN_COMPONENT = 72,
    POLYGON = 73,
    POLYLINE = 74,
    POPUP = 75,
    PROGRESS = 76,
    QRCODE = 77,
    RADIO = 78,
    RATING = 79,
    RECT = 80,
    REFRESH = 81,
    RELATIVE_CONTAINER = 82,
    REMOTE_WINDOW = 83,
    RICH_EDITOR = 84,
    RICH_TEXT = 85,
    ROLE_PAGER = 86,
    ROW = 87,
    ROW_SPLIT = 88,
    SCROLL = 89,
    SCROLL_BAR = 90,
    SEARCH = 91,
    SEARCH_FIELD = 92,
    SELECT = 93,
    SHAPE = 94,
    SIDEBAR_CONTAINER = 95,
    SLIDER = 96,
    SPAN = 97,
    STACK = 98,
    STEPPER = 99,
    STEPPER_ITEM = 100,
    SWIPER = 101,
    SWIPER_INDICATOR = 102,
    SWITCH = 103,
    SYMBOL_GLYPH = 104,
    TAB_CONTENT = 105,
    TAB_BAR = 106,
    TABS = 107,
    TEXT = 108,
    TEXT_CLOCK = 109,
    TEXT_ENTRY = 110,
    TEXT_INPUT = 111,
    TEXT_PICKER = 112,
    TEXT_TIMER = 113,
    TEXT_AREA = 114,
    TEXT_FIELD = 115,
    TIME_PICKER = 116,
    TITLE_BAR = 117,
    TOGGLER = 118,
    UI_EXTENSION_COMPONENT = 119,
    VIDEO = 120,
    WATER_FLOW = 121,
    WEB = 122,
    XCOMPONENT = 123,
    ROLE_NONE = 124
}
export type AccessibilityFocusCallback = (isFocus: boolean) => void;
export enum FinishCallbackType {
    REMOVED = 0,
    LOGICALLY = 1
}
export enum TouchTestStrategy {
    DEFAULT = 0,
    FORWARD_COMPETITION = 1,
    FORWARD = 2
}
export interface AnimateParam {
    duration?: number;
    tempo?: number;
    curve?: curves.Curve | string | curves.ICurve;
    delay?: number;
    iterations?: number;
    playMode?: PlayMode;
    onFinish?: (() => void);
    finishCallbackType?: FinishCallbackType;
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export type ICurve = curves.ICurve;
export interface MotionPathOptions {
    path: string;
    from?: number;
    to?: number;
    rotatable?: boolean;
}
export interface sharedTransitionOptions {
    duration?: number;
    curve?: curves.Curve | string | curves.ICurve;
    delay?: number;
    motionPath?: MotionPathOptions;
    zIndex?: number;
    type?: SharedTransitionEffectType;
}
export interface GeometryTransitionOptions {
    follow?: boolean;
    hierarchyStrategy?: TransitionHierarchyStrategy;
}
export interface LinearGradientOptions {
    angle?: number | string;
    direction?: GradientDirection;
    colors: Array<[ ResourceColor, number ]>;
    repeating?: boolean;
}
export interface SweepGradientOptions {
    center: [ Length, Length ];
    start?: number | string;
    end?: number | string;
    rotation?: number | string;
    colors: Array<[ ResourceColor, number ]>;
    repeating?: boolean;
}
export interface RadialGradientOptions {
    center: [ Length, Length ];
    radius: Length;
    colors: Array<[ ResourceColor, number ]>;
    repeating?: boolean;
}
export enum TransitionHierarchyStrategy {
    NONE = 0,
    ADAPTIVE = 1
}
export interface TranslateOptions {
    x?: number | string;
    y?: number | string;
    z?: number | string;
}
export interface ScaleOptions {
    x?: number;
    y?: number;
    z?: number;
    centerX?: number | string;
    centerY?: number | string;
}
export interface AlignRuleParam<T = void> {
    anchor: string;
    align: T;
}
export interface AlignRuleOption {
    _stub: int32;
}
export interface LocalizedHorizontalAlignParam {
    anchor: string;
    align: HorizontalAlign;
}
export interface LocalizedVerticalAlignParam {
    anchor: string;
    align: VerticalAlign;
}
export interface LocalizedAlignRuleOptions {
    start?: LocalizedHorizontalAlignParam;
    end?: LocalizedHorizontalAlignParam;
    middle?: LocalizedHorizontalAlignParam;
    top?: LocalizedVerticalAlignParam;
    bottom?: LocalizedVerticalAlignParam;
    center?: LocalizedVerticalAlignParam;
    bias?: Bias;
}
export enum ChainStyle {
    SPREAD = 0,
    SPREAD_INSIDE = 1,
    PACKED = 2
}
export interface RotateOptions {
    x?: number;
    y?: number;
    z?: number;
    centerX?: number | string;
    centerY?: number | string;
    centerZ?: number;
    perspective?: number;
    angle: number | string;
}
export enum TransitionEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export interface AsymmetricTransitionOption {
    appear: TransitionEffect;
    disappear: TransitionEffect;
}
export interface ItemDragInfo {
    x: number;
    y: number;
}
export enum EffectType {
    DEFAULT = 0,
    WINDOW_EFFECT = 1
}
export enum PreDragStatus {
    ACTION_DETECTING_STATUS = 0,
    READY_TO_TRIGGER_DRAG_ACTION = 1,
    PREVIEW_LIFT_STARTED = 2,
    PREVIEW_LIFT_FINISHED = 3,
    PREVIEW_LANDING_STARTED = 4,
    PREVIEW_LANDING_FINISHED = 5,
    ACTION_CANCELED_BEFORE_DRAG = 6,
    PREPARING_FOR_DRAG_DETECTION = 7
}
export interface DragItemInfo {
    pixelMap?: image.PixelMap;
    builder?: CustomBuilder;
    extraInfo?: string;
}
export type PointerStyle = pointer.PointerStyle;
export interface EventTarget {
    area: Area;
    id?: string;
}
export enum SourceType {
    UNKNOWN = 0,
    Unknown = 0,
    MOUSE = 1,
    Mouse = 1,
    TOUCH_SCREEN = 2,
    TouchScreen = 2
}
export enum SourceTool {
    UNKNOWN = 0,
    Unknown = 0,
    FINGER = 1,
    Finger = 1,
    PEN = 2,
    Pen = 2,
    MOUSE = 3,
    TOUCHPAD = 4,
    JOYSTICK = 5
}
export enum RepeatMode {
    REPEAT = 0,
    Repeat = 0,
    STRETCH = 1,
    Stretch = 1,
    ROUND = 2,
    Round = 2,
    SPACE = 3,
    Space = 3
}
export enum BlurStyle {
    THIN = 0,
    Thin = 0,
    REGULAR = 1,
    Regular = 1,
    THICK = 2,
    Thick = 2,
    BACKGROUND_THIN = 3,
    BACKGROUND_REGULAR = 4,
    BACKGROUND_THICK = 5,
    BACKGROUND_ULTRA_THICK = 6,
    NONE = 7,
    COMPONENT_ULTRA_THIN = 8,
    COMPONENT_THIN = 9,
    COMPONENT_REGULAR = 10,
    COMPONENT_THICK = 11,
    COMPONENT_ULTRA_THICK = 12
}
export enum BlurStyleActivePolicy {
    FOLLOWS_WINDOW_ACTIVE_STATE = 0,
    ALWAYS_ACTIVE = 1,
    ALWAYS_INACTIVE = 2
}
export enum ThemeColorMode {
    SYSTEM = 0,
    LIGHT = 1,
    DARK = 2
}
export enum AdaptiveColor {
    DEFAULT = 0,
    AVERAGE = 1
}
export enum ModalTransition {
    DEFAULT = 0,
    NONE = 1,
    ALPHA = 2
}
export interface BackgroundBlurStyleOptions extends BlurStyleOptions {
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundBlurStyleOptions extends BlurStyleOptions {
}
export interface BlurOptions {
    grayscale: [ number, number ];
}
export interface SystemAdaptiveOptions {
    disableSystemAdaptation?: boolean;
}
export interface BlurStyleOptions {
    colorMode?: ThemeColorMode;
    adaptiveColor?: AdaptiveColor;
    scale?: number;
    blurOptions?: BlurOptions;
}
export interface BackgroundEffectOptions {
    radius: number;
    saturation?: number;
    brightness?: number;
    color?: ResourceColor;
    adaptiveColor?: AdaptiveColor;
    blurOptions?: BlurOptions;
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundEffectOptions {
    radius: number;
}
export interface PickerTextStyle {
    color?: ResourceColor;
    font?: Font;
}
export interface PickerDialogButtonStyle {
    type?: ButtonType;
    style?: ButtonStyleMode;
    role?: ButtonRole;
    fontSize?: Length;
    fontColor?: ResourceColor;
    fontWeight?: FontWeight | number | string;
    fontStyle?: FontStyle;
    fontFamily?: Resource | string;
    backgroundColor?: ResourceColor;
    borderRadius?: Length | BorderRadiuses;
    primary?: boolean;
}
export enum ShadowType {
    COLOR = 0,
    BLUR = 1
}
export interface ShadowOptions {
    radius: number | Resource;
    type?: ShadowType;
    color?: Color | string | Resource | ColoringStrategy;
    offsetX?: number | Resource;
    offsetY?: number | Resource;
    fill?: boolean;
}
export enum ShadowStyle {
    OUTER_DEFAULT_XS = 0,
    OUTER_DEFAULT_SM = 1,
    OUTER_DEFAULT_MD = 2,
    OUTER_DEFAULT_LG = 3,
    OUTER_FLOATING_SM = 4,
    OUTER_FLOATING_MD = 5
}
export interface MultiShadowOptions {
    radius?: number | Resource;
    offsetX?: number | Resource;
    offsetY?: number | Resource;
}
export enum SafeAreaType {
    SYSTEM = 0,
    CUTOUT = 1,
    KEYBOARD = 2
}
export enum SafeAreaEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export enum LayoutSafeAreaType {
    SYSTEM = 0
}
export enum LayoutSafeAreaEdge {
    TOP = 0,
    BOTTOM = 1
}
export enum SheetSize {
    MEDIUM = 0,
    LARGE = 1,
    FIT_CONTENT = 2
}
export type ModifierKeyStateGetter = (keys: Array<string>) => boolean;
export interface BorderImageOption {
    slice?: Length | EdgeWidths | LocalizedEdgeWidths;
    repeat?: RepeatMode;
    source?: string | Resource | LinearGradientOptions;
    width?: Length | EdgeWidths | LocalizedEdgeWidths;
    outset?: Length | EdgeWidths | LocalizedEdgeWidths;
    fill?: boolean;
}
export interface TouchObject {
    type: TouchType;
    id: number;
    displayX: number;
    displayY: number;
    windowX: number;
    windowY: number;
    x: number;
    y: number;
    hand?: InteractionHand;
    pressedTime?: number;
    pressure?: number;
    width?: number;
    height?: number;
}
export interface HistoricalPoint {
    touchObject: TouchObject;
    size: number;
    force: number;
    timestamp: number;
}
export type SizeChangeCallback = (oldValue: SizeOptions, newValue: SizeOptions) => void;
export type GestureRecognizerJudgeBeginCallback = (event: BaseGestureEvent, current: GestureRecognizer, recognizers: Array<GestureRecognizer>) => GestureJudgeResult;
export type ShouldBuiltInRecognizerParallelWithCallback = (current: GestureRecognizer, others: Array<GestureRecognizer>) => GestureRecognizer;
export type TransitionFinishCallback = (transitionIn: boolean) => void;
export type PixelMap = image.PixelMap;
export enum DragBehavior {
    COPY = 0,
    MOVE = 1
}
export type UnifiedData = unifiedDataChannel.UnifiedData;
export type Summary = unifiedDataChannel.Summary;
export type UniformDataType = uniformTypeDescriptor.UniformDataType;
export enum DragResult {
    DRAG_SUCCESSFUL = 0,
    DRAG_FAILED = 1,
    DRAG_CANCELED = 2,
    DROP_ENABLED = 3,
    DROP_DISABLED = 4
}
export enum BlendMode {
    NONE = 0,
    CLEAR = 1,
    SRC = 2,
    DST = 3,
    SRC_OVER = 4,
    DST_OVER = 5,
    SRC_IN = 6,
    DST_IN = 7,
    SRC_OUT = 8,
    DST_OUT = 9,
    SRC_ATOP = 10,
    DST_ATOP = 11,
    XOR = 12,
    PLUS = 13,
    MODULATE = 14,
    SCREEN = 15,
    OVERLAY = 16,
    DARKEN = 17,
    LIGHTEN = 18,
    COLOR_DODGE = 19,
    COLOR_BURN = 20,
    HARD_LIGHT = 21,
    SOFT_LIGHT = 22,
    DIFFERENCE = 23,
    EXCLUSION = 24,
    MULTIPLY = 25,
    HUE = 26,
    SATURATION = 27,
    COLOR = 28,
    LUMINOSITY = 29
}
export enum BlendApplyType {
    FAST = 0,
    OFFSCREEN = 1
}
export type OnDragEventCallback = (event: DragEvent, extraParams?: string) => void;
export interface DropOptions {
    disableDataPrefetch?: boolean;
}
export interface CrownEvent {
    timestamp: int64;
    angularVelocity: number;
    degree: number;
    action: CrownAction;
    stopPropagation: (() => void);
}
export interface BindOptions {
    backgroundColor?: ResourceColor;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    onWillAppear?: (() => void);
    onWillDisappear?: (() => void);
}
export interface DismissContentCoverAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export interface ContentCoverOptions extends BindOptions {
    modalTransition?: ModalTransition;
    onWillDismiss?: ((value0: DismissContentCoverAction) => void);
    transition?: TransitionEffect;
}
export interface SheetTitleOptions {
    title: ResourceStr;
    subtitle?: ResourceStr;
}
export enum SheetType {
    BOTTOM = 0,
    CENTER = 1,
    POPUP = 2
}
export enum SheetMode {
    OVERLAY = 0,
    EMBEDDED = 1
}
export enum ScrollSizeMode {
    FOLLOW_DETENT = 0,
    CONTINUOUS = 1
}
export enum SheetKeyboardAvoidMode {
    NONE = 0,
    TRANSLATE_AND_RESIZE = 1,
    RESIZE_ONLY = 2,
    TRANSLATE_AND_SCROLL = 3
}
export interface SheetDismiss {
    dismiss: VoidCallback;
}
export interface DismissSheetAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export interface SpringBackAction {
    springBack: VoidCallback;
}
export type SingleLengthDetent = [
    SheetSize | Length
]
export type DoubleLengthDetents = [
    SheetSize | Length,
    SheetSize | Length | undefined
]
export type TripleLengthDetents = [
    SheetSize | Length,
    SheetSize | Length | undefined,
    SheetSize | Length | undefined
]
export interface SheetOptions extends BindOptions {
    height?: SheetSize | Length;
    dragBar?: boolean;
    maskColor?: ResourceColor;
    detents?: TripleLengthDetents;
    blurStyle?: BlurStyle;
    showClose?: boolean | Resource;
    preferType?: SheetType;
    title?: SheetTitleOptions | CustomBuilder;
    shouldDismiss?: ((sheetDismiss: SheetDismiss) => void);
    onWillDismiss?: ((value0: DismissSheetAction) => void);
    onWillSpringBackWhenDismiss?: ((value0: SpringBackAction) => void);
    enableOutsideInteractive?: boolean;
    width?: Dimension;
    borderWidth?: Dimension | EdgeWidths | LocalizedEdgeWidths;
    borderColor?: ResourceColor | EdgeColors | LocalizedEdgeColors;
    borderStyle?: BorderStyle | EdgeStyles;
    shadow?: ShadowOptions | ShadowStyle;
    onHeightDidChange?: ((value0: number) => void);
    mode?: SheetMode;
    scrollSizeMode?: ScrollSizeMode;
    onDetentsDidChange?: ((value0: number) => void);
    onWidthDidChange?: ((value0: number) => void);
    onTypeDidChange?: ((value0: SheetType) => void);
    uiContext?: UIContext;
    keyboardAvoidMode?: SheetKeyboardAvoidMode;
    enableHoverMode?: boolean;
    hoverModeArea?: HoverModeAreaType;
    offset?: Position;
    effectEdge?: number;
    radius?: LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses;
    detentSelection?: SheetSize | Length;
    showInSubWindow?: boolean;
    placement?: Placement;
    placementOnTarget?: boolean;
}
export interface StateStyles {
    normal?: CustomStyles;
    pressed?: CustomStyles;
    disabled?: CustomStyles;
    focused?: CustomStyles;
    clicked?: CustomStyles;
    selected?: CustomStyles;
}
export interface PopupMessageOptions {
    textColor?: ResourceColor;
    font?: Font;
}
export enum DismissReason {
    PRESS_BACK = 0,
    TOUCH_OUTSIDE = 1,
    CLOSE_BUTTON = 2,
    SLIDE_DOWN = 3
}
export interface PopupStateChangeParam {
    isVisible: boolean;
}
export type PopupStateChangeCallback = (event: PopupStateChangeParam) => void;
export interface PopupMaskType {
    color: ResourceColor;
}
export interface PopupCommonOptions {
    placement?: Placement;
    popupColor?: ResourceColor;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
}
export interface TipsOptions {
    appearingTime?: number;
    disappearingTime?: number;
    appearingTimeWithContinuousOperation?: number;
    disappearingTimeWithContinuousOperation?: number;
    enableArrow?: boolean;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
}
export interface PopupButton {
    value: string;
    action: VoidCallback;
}
export interface PopupOptions {
    message: string;
    placement?: Placement;
    primaryButton?: PopupButton;
    secondaryButton?: PopupButton;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    messageOptions?: PopupMessageOptions;
    targetSpace?: Length;
    enableArrow?: boolean;
    offset?: Position;
    popupColor?: Color | string | Resource | number;
    autoCancel?: boolean;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export interface CustomPopupOptions {
    builder: CustomBuilder;
    placement?: Placement;
    popupColor?: Color | string | Resource | number;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export enum MenuPreviewMode {
    NONE = 0,
    IMAGE = 1
}
export type AnimationNumberRange = [
    number,
    number
]
export interface ContextMenuAnimationOptions {
    scale?: AnimationNumberRange;
    transition?: TransitionEffect;
    hoverScale?: AnimationNumberRange;
}
export type BorderRadiusType = Length | BorderRadiuses | LocalizedBorderRadiuses;
export enum HapticFeedbackMode {
    DISABLED = 0,
    ENABLED = 1,
    AUTO = 2
}
export interface ContextMenuOptions {
    offset?: Position;
    placement?: Placement;
    enableArrow?: boolean;
    arrowOffset?: Length;
    preview?: MenuPreviewMode | CustomBuilder;
    previewBorderRadius?: BorderRadiusType;
    borderRadius?: Length | BorderRadiuses | LocalizedBorderRadiuses;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    aboutToAppear?: (() => void);
    aboutToDisappear?: (() => void);
    layoutRegionMargin?: Padding;
    previewAnimationOptions?: ContextMenuAnimationOptions;
    backgroundColor?: ResourceColor;
    backgroundBlurStyle?: BlurStyle;
    backgroundBlurStyleOptions?: BackgroundBlurStyleOptions;
    backgroundEffect?: BackgroundEffectOptions;
    transition?: TransitionEffect;
    enableHoverMode?: boolean;
    outlineColor?: ResourceColor | EdgeColors;
    outlineWidth?: Dimension | EdgeOutlineWidths;
    hapticFeedbackMode?: HapticFeedbackMode;
}
export interface MenuOptions extends ContextMenuOptions {
    title?: ResourceStr;
    showInSubWindow?: boolean;
}
export interface TouchTestInfo {
    windowX: number;
    windowY: number;
    parentX: number;
    parentY: number;
    x: number;
    y: number;
    rect: RectResult;
    id: string;
}
export interface TouchResult {
    strategy: TouchTestStrategy;
    id?: string | undefined;
}
export interface PixelStretchEffectOptions {
    top?: Length;
    bottom?: Length;
    left?: Length;
    right?: Length;
}
export interface ClickEffect {
    level: ClickEffectLevel;
    scale?: number;
}
export interface FadingEdgeOptions {
    fadingEdgeLength?: LengthMetrics;
}
export interface NestedScrollOptions {
    scrollForward: NestedScrollMode;
    scrollBackward: NestedScrollMode;
}
export interface MenuElement {
    value: ResourceStr;
    icon?: ResourceStr;
    symbolIcon?: SymbolGlyphModifier;
    enabled?: boolean;
    action: (() => void);
}
export interface CommonConfiguration<T = void> {
    enabled: boolean;
    contentModifier: ContentModifier<T>;
}
export enum OutlineStyle {
    SOLID = 0,
    DASHED = 1,
    DOTTED = 2
}
export enum DragPreviewMode {
    AUTO = 1,
    DISABLE_SCALE = 2,
    ENABLE_DEFAULT_SHADOW = 3,
    ENABLE_DEFAULT_RADIUS = 4,
    ENABLE_DRAG_ITEM_GRAY_EFFECT = 5,
    ENABLE_MULTI_TILE_EFFECT = 6,
    ENABLE_TOUCH_POINT_CALCULATION_BASED_ON_FINAL_PREVIEW = 7
}
export enum DraggingSizeChangeEffect {
    DEFAULT = 0,
    SIZE_TRANSITION = 1,
    SIZE_CONTENT_TRANSITION = 2
}
export enum MenuPolicy {
    DEFAULT = 0,
    HIDE = 1,
    SHOW = 2
}
export interface DragPreviewOptions {
    mode?: DragPreviewMode | Array<DragPreviewMode>;
    numberBadge?: boolean | number;
    sizeChangeEffect?: DraggingSizeChangeEffect;
}
export interface DragInteractionOptions {
    isMultiSelectionEnabled?: boolean;
    defaultAnimationBeforeLifting?: boolean;
    enableEdgeAutoScroll?: boolean;
    enableHapticFeedback?: boolean;
    isLiftingDisabled?: boolean;
}
export interface PreviewConfiguration {
    onlyForLifting?: boolean;
    delayCreating?: boolean;
}
export interface InvertOptions {
    low: number;
    high: number;
    threshold: number;
    thresholdRange: number;
}
export type TipsMessageType = ResourceStr | StyledString;
export interface BackgroundImageOptions {
    syncLoad?: boolean;
    repeat?: ImageRepeat;
}
export interface BackgroundOptions {
    align?: Alignment;
}
export interface CommonMethod {
    width(value: Length | LayoutPolicy | undefined): this {
        throw new Error("Unimplemented method width")
    }
    height(value: Length | LayoutPolicy | undefined): this {
        throw new Error("Unimplemented method height")
    }
    drawModifier(value: DrawModifier | undefined): this {
        throw new Error("Unimplemented method drawModifier")
    }
    responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error("Unimplemented method responseRegion")
    }
    mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error("Unimplemented method mouseResponseRegion")
    }
    size(value: SizeOptions | undefined): this {
        throw new Error("Unimplemented method size")
    }
    constraintSize(value: ConstraintSizeOptions | undefined): this {
        throw new Error("Unimplemented method constraintSize")
    }
    hitTestBehavior(value: HitTestMode | undefined): this {
        throw new Error("Unimplemented method hitTestBehavior")
    }
    onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        throw new Error("Unimplemented method onChildTouchTest")
    }
    layoutWeight(value: number | string | undefined): this {
        throw new Error("Unimplemented method layoutWeight")
    }
    chainWeight(value: ChainWeightOptions | undefined): this {
        throw new Error("Unimplemented method chainWeight")
    }
    padding(value: Padding | Length | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method padding")
    }
    safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method safeAreaPadding")
    }
    margin(value: Padding | Length | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method margin")
    }
    backgroundColor(value: ResourceColor | undefined): this {
        throw new Error("Unimplemented method backgroundColor")
    }
    pixelRound(value: PixelRoundPolicy | undefined): this {
        throw new Error("Unimplemented method pixelRound")
    }
    backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        throw new Error("Unimplemented method backgroundImageSize")
    }
    backgroundImagePosition(value: Position | Alignment | undefined): this {
        throw new Error("Unimplemented method backgroundImagePosition")
    }
    backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        throw new Error("Unimplemented method backgroundEffect")
    }
    backgroundImageResizable(value: ResizableOptions | undefined): this {
        throw new Error("Unimplemented method backgroundImageResizable")
    }
    foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        throw new Error("Unimplemented method foregroundEffect")
    }
    visualEffect(value: uiEffect.VisualEffect | undefined): this {
        throw new Error("Unimplemented method visualEffect")
    }
    backgroundFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method backgroundFilter")
    }
    foregroundFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method foregroundFilter")
    }
    compositingFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method compositingFilter")
    }
    opacity(value: number | Resource | undefined): this {
        throw new Error("Unimplemented method opacity")
    }
    border(value: BorderOptions | undefined): this {
        throw new Error("Unimplemented method border")
    }
    borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        throw new Error("Unimplemented method borderStyle")
    }
    borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        throw new Error("Unimplemented method borderWidth")
    }
    borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error("Unimplemented method borderColor")
    }
    borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        throw new Error("Unimplemented method borderRadius")
    }
    borderImage(value: BorderImageOption | undefined): this {
        throw new Error("Unimplemented method borderImage")
    }
    outline(value: OutlineOptions | undefined): this {
        throw new Error("Unimplemented method outline")
    }
    outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        throw new Error("Unimplemented method outlineStyle")
    }
    outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        throw new Error("Unimplemented method outlineWidth")
    }
    outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error("Unimplemented method outlineColor")
    }
    outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        throw new Error("Unimplemented method outlineRadius")
    }
    foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        throw new Error("Unimplemented method foregroundColor")
    }
    onClick(value: ((event: ClickEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onClick")
    }
    onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onHover")
    }
    onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onHoverMove")
    }
    onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityHover")
    }
    hoverEffect(value: HoverEffect | undefined): this {
        throw new Error("Unimplemented method hoverEffect")
    }
    onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onMouse")
    }
    onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onTouch")
    }
    onKeyEvent(value: ((event: KeyEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onKeyEvent")
    }
    onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onDigitalCrown")
    }
    onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        throw new Error("Unimplemented method onKeyPreIme")
    }
    onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        throw new Error("Unimplemented method onKeyEventDispatch")
    }
    onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onFocusAxisEvent")
    }
    onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onAxisEvent")
    }
    focusable(value: boolean | undefined): this {
        throw new Error("Unimplemented method focusable")
    }
    nextFocus(value: FocusMovement | undefined): this {
        throw new Error("Unimplemented method nextFocus")
    }
    tabStop(value: boolean | undefined): this {
        throw new Error("Unimplemented method tabStop")
    }
    onFocus(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onFocus")
    }
    onBlur(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onBlur")
    }
    tabIndex(value: number | undefined): this {
        throw new Error("Unimplemented method tabIndex")
    }
    defaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method defaultFocus")
    }
    groupDefaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method groupDefaultFocus")
    }
    focusOnTouch(value: boolean | undefined): this {
        throw new Error("Unimplemented method focusOnTouch")
    }
    focusBox(value: FocusBoxStyle | undefined): this {
        throw new Error("Unimplemented method focusBox")
    }
    animation(value: AnimateParam | undefined): this {
        throw new Error("Unimplemented method animation")
    }
    transition(value: TransitionEffect | undefined): this {
        throw new Error("Unimplemented method transition")
    }
    motionBlur(value: MotionBlurOptions | undefined): this {
        throw new Error("Unimplemented method motionBlur")
    }
    brightness(value: number | undefined): this {
        throw new Error("Unimplemented method brightness")
    }
    contrast(value: number | undefined): this {
        throw new Error("Unimplemented method contrast")
    }
    grayscale(value: number | undefined): this {
        throw new Error("Unimplemented method grayscale")
    }
    colorBlend(value: Color | string | Resource | undefined): this {
        throw new Error("Unimplemented method colorBlend")
    }
    saturate(value: number | undefined): this {
        throw new Error("Unimplemented method saturate")
    }
    sepia(value: number | undefined): this {
        throw new Error("Unimplemented method sepia")
    }
    invert(value: number | InvertOptions | undefined): this {
        throw new Error("Unimplemented method invert")
    }
    hueRotate(value: number | string | undefined): this {
        throw new Error("Unimplemented method hueRotate")
    }
    useShadowBatching(value: boolean | undefined): this {
        throw new Error("Unimplemented method useShadowBatching")
    }
    useEffect(value: boolean | undefined): this {
        throw new Error("Unimplemented method useEffect")
    }
    renderGroup(value: boolean | undefined): this {
        throw new Error("Unimplemented method renderGroup")
    }
    freeze(value: boolean | undefined): this {
        throw new Error("Unimplemented method freeze")
    }
    translate(value: TranslateOptions | undefined): this {
        throw new Error("Unimplemented method translate")
    }
    scale(value: ScaleOptions | undefined): this {
        throw new Error("Unimplemented method scale")
    }
    rotate(value: RotateOptions | undefined): this {
        throw new Error("Unimplemented method rotate")
    }
    transform(value: Object | undefined): this {
        throw new Error("Unimplemented method transform")
    }
    onAppear(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onAppear")
    }
    onDisAppear(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onDisAppear")
    }
    onAttach(value: VoidCallback | undefined): this {
        throw new Error("Unimplemented method onAttach")
    }
    onDetach(value: VoidCallback | undefined): this {
        throw new Error("Unimplemented method onDetach")
    }
    onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        throw new Error("Unimplemented method onAreaChange")
    }
    visibility(value: Visibility | undefined): this {
        throw new Error("Unimplemented method visibility")
    }
    flexGrow(value: number | undefined): this {
        throw new Error("Unimplemented method flexGrow")
    }
    flexShrink(value: number | undefined): this {
        throw new Error("Unimplemented method flexShrink")
    }
    flexBasis(value: number | string | undefined): this {
        throw new Error("Unimplemented method flexBasis")
    }
    alignSelf(value: ItemAlign | undefined): this {
        throw new Error("Unimplemented method alignSelf")
    }
    displayPriority(value: number | undefined): this {
        throw new Error("Unimplemented method displayPriority")
    }
    zIndex(value: number | undefined): this {
        throw new Error("Unimplemented method zIndex")
    }
    direction(value: Direction | undefined): this {
        throw new Error("Unimplemented method direction")
    }
    align(value: Alignment | undefined): this {
        throw new Error("Unimplemented method align")
    }
    position(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error("Unimplemented method position")
    }
    markAnchor(value: Position | LocalizedPosition | undefined): this {
        throw new Error("Unimplemented method markAnchor")
    }
    offset(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error("Unimplemented method offset")
    }
    enabled(value: boolean | undefined): this {
        throw new Error("Unimplemented method enabled")
    }
    alignRules(value: AlignRuleOption | undefined): this {
        throw new Error("Unimplemented method alignRules")
    }
    alignRules(value: LocalizedAlignRuleOptions | undefined): this {
        throw new Error("Unimplemented method alignRules")
    }
    aspectRatio(value: number | undefined): this {
        throw new Error("Unimplemented method aspectRatio")
    }
    clickEffect(value: ClickEffect | undefined): this {
        throw new Error("Unimplemented method clickEffect")
    }
    onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        throw new Error("Unimplemented method onDragStart")
    }
    onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragEnter")
    }
    onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragMove")
    }
    onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragLeave")
    }
    onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDrop")
    }
    onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragEnd")
    }
    allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | undefined): this {
        throw new Error("Unimplemented method allowDrop")
    }
    draggable(value: boolean | undefined): this {
        throw new Error("Unimplemented method draggable")
    }
    dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        throw new Error("Unimplemented method dragPreview")
    }
    onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        throw new Error("Unimplemented method onPreDrag")
    }
    linearGradient(value: LinearGradientOptions | undefined): this {
        throw new Error("Unimplemented method linearGradient")
    }
    sweepGradient(value: SweepGradientOptions | undefined): this {
        throw new Error("Unimplemented method sweepGradient")
    }
    radialGradient(value: RadialGradientOptions | undefined): this {
        throw new Error("Unimplemented method radialGradient")
    }
    motionPath(value: MotionPathOptions | undefined): this {
        throw new Error("Unimplemented method motionPath")
    }
    shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        throw new Error("Unimplemented method shadow")
    }
    clip(value: boolean | undefined): this {
        throw new Error("Unimplemented method clip")
    }
    clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error("Unimplemented method clipShape")
    }
    mask(value: ProgressMask | undefined): this {
        throw new Error("Unimplemented method mask")
    }
    maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error("Unimplemented method maskShape")
    }
    key(value: string | undefined): this {
        throw new Error("Unimplemented method key")
    }
    id(value: string | undefined): this {
        throw new Error("Unimplemented method id")
    }
    geometryTransition(value: string | undefined): this {
        throw new Error("Unimplemented method geometryTransition")
    }
    stateStyles(value: StateStyles | undefined): this {
        throw new Error("Unimplemented method stateStyles")
    }
    restoreId(value: number | undefined): this {
        throw new Error("Unimplemented method restoreId")
    }
    sphericalEffect(value: number | undefined): this {
        throw new Error("Unimplemented method sphericalEffect")
    }
    lightUpEffect(value: number | undefined): this {
        throw new Error("Unimplemented method lightUpEffect")
    }
    pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        throw new Error("Unimplemented method pixelStretchEffect")
    }
    accessibilityGroup(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityGroup")
    }
    accessibilityText(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityText")
    }
    accessibilityNextFocusId(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityNextFocusId")
    }
    accessibilityDefaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityDefaultFocus")
    }
    accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        throw new Error("Unimplemented method accessibilityUseSamePage")
    }
    accessibilityScrollTriggerable(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityScrollTriggerable")
    }
    accessibilityText(value: Resource | undefined): this {
        throw new Error("Unimplemented method accessibilityText")
    }
    accessibilityRole(value: AccessibilityRoleType | undefined): this {
        throw new Error("Unimplemented method accessibilityRole")
    }
    onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityFocus")
    }
    accessibilityTextHint(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityTextHint")
    }
    accessibilityDescription(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityDescription")
    }
    accessibilityDescription(value: Resource | undefined): this {
        throw new Error("Unimplemented method accessibilityDescription")
    }
    accessibilityLevel(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityLevel")
    }
    accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        throw new Error("Unimplemented method accessibilityVirtualNode")
    }
    accessibilityChecked(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityChecked")
    }
    accessibilitySelected(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilitySelected")
    }
    obscured(value: Array<ObscuredReasons> | undefined): this {
        throw new Error("Unimplemented method obscured")
    }
    reuseId(value: string | undefined): this {
        throw new Error("Unimplemented method reuseId")
    }
    reuse(value: ReuseOptions | undefined): this {
        throw new Error("Unimplemented method reuse")
    }
    renderFit(value: RenderFit | undefined): this {
        throw new Error("Unimplemented method renderFit")
    }
    gestureModifier(value: GestureModifier | undefined): this {
        throw new Error("Unimplemented method gestureModifier")
    }
    backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        throw new Error("Unimplemented method backgroundBrightness")
    }
    onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        throw new Error("Unimplemented method onGestureJudgeBegin")
    }
    onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        throw new Error("Unimplemented method onGestureRecognizerJudgeBegin")
    }
    shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        throw new Error("Unimplemented method shouldBuiltInRecognizerParallelWith")
    }
    monopolizeEvents(value: boolean | undefined): this {
        throw new Error("Unimplemented method monopolizeEvents")
    }
    onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        throw new Error("Unimplemented method onTouchIntercept")
    }
    onSizeChange(value: SizeChangeCallback | undefined): this {
        throw new Error("Unimplemented method onSizeChange")
    }
    accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        throw new Error("Unimplemented method accessibilityFocusDrawLevel")
    }
    customProperty(name: string | undefined, value: Object | undefined): this {
        throw new Error("Unimplemented method customProperty")
    }
    expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        throw new Error("Unimplemented method expandSafeArea")
    }
    background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        throw new Error("Unimplemented method background")
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): this {
        throw new Error("Unimplemented method backgroundImage")
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): this {
        throw new Error("Unimplemented method backgroundImage")
    }
    backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backgroundBlurStyle")
    }
    backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backgroundEffect")
    }
    foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method foregroundBlurStyle")
    }
    onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: number | undefined): this {
        throw new Error("Unimplemented method onClick")
    }
    focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        throw new Error("Unimplemented method focusScopeId")
    }
    focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        throw new Error("Unimplemented method focusScopePriority")
    }
    transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        throw new Error("Unimplemented method transition")
    }
    gesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        throw new Error("Unimplemented method gesture")
    }
    priorityGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        throw new Error("Unimplemented method priorityGesture")
    }
    parallelGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        throw new Error("Unimplemented method parallelGesture")
    }
    blur(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method blur")
    }
    linearGradientBlur(value: number | undefined, options: LinearGradientBlurOptions | undefined): this {
        throw new Error("Unimplemented method linearGradientBlur")
    }
    systemBarEffect(): this {
        throw new Error("Unimplemented method systemBarEffect")
    }
    useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        throw new Error("Unimplemented method useEffect")
    }
    backdropBlur(radius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backdropBlur")
    }
    sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        throw new Error("Unimplemented method sharedTransition")
    }
    chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        throw new Error("Unimplemented method chainMode")
    }
    onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        throw new Error("Unimplemented method onDrop")
    }
    dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        throw new Error("Unimplemented method dragPreview")
    }
    dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        throw new Error("Unimplemented method dragPreviewOptions")
    }
    overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        throw new Error("Unimplemented method overlay")
    }
    blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        throw new Error("Unimplemented method blendMode")
    }
    advancedBlendMode(effect: BlendMode | uiEffect.Blender | undefined, type?: BlendApplyType): this {
        throw new Error("Unimplemented method advancedBlendMode")
    }
    geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        throw new Error("Unimplemented method geometryTransition")
    }
    bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        throw new Error("Unimplemented method bindTips")
    }
    bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        throw new Error("Unimplemented method bindPopup")
    }
    bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error("Unimplemented method bindMenu")
    }
    bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error("Unimplemented method bindMenu")
    }
    bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        throw new Error("Unimplemented method bindContextMenu")
    }
    bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        throw new Error("Unimplemented method bindContextMenu")
    }
    bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        throw new Error("Unimplemented method bindContentCover")
    }
    bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        throw new Error("Unimplemented method bindContentCover")
    }
    bindSheet(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        throw new Error("Unimplemented method bindSheet")
    }
    onVisibleAreaChange(ratios: Array<number> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error("Unimplemented method onVisibleAreaChange")
    }
    onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error("Unimplemented method onVisibleAreaApproximateChange")
    }
    keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        throw new Error("Unimplemented method keyboardShortcut")
    }
    accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions: AccessibilityOptions | undefined): this {
        throw new Error("Unimplemented method accessibilityGroup")
    }
    onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        throw new Error("Unimplemented method onGestureRecognizerJudgeBegin")
    }
    attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkCommonMethodStyle implements CommonMethod {
    width_value?: Length | LayoutPolicy | undefined
    height_value?: Length | LayoutPolicy | undefined
    drawModifier_value?: DrawModifier | undefined
    responseRegion_value?: Array<Rectangle> | Rectangle | undefined
    mouseResponseRegion_value?: Array<Rectangle> | Rectangle | undefined
    size_value?: SizeOptions | undefined
    constraintSize_value?: ConstraintSizeOptions | undefined
    hitTestBehavior_value?: HitTestMode | undefined
    onChildTouchTest_value?: ((value: Array<TouchTestInfo>) => TouchResult) | undefined
    layoutWeight_value?: number | string | undefined
    chainWeight_value?: ChainWeightOptions | undefined
    padding_value?: Padding | Length | LocalizedPadding | undefined
    safeAreaPadding_value?: Padding | LengthMetrics | LocalizedPadding | undefined
    margin_value?: Padding | Length | LocalizedPadding | undefined
    backgroundColor_value?: ResourceColor | undefined
    pixelRound_value?: PixelRoundPolicy | undefined
    backgroundImageSize_value?: SizeOptions | ImageSize | undefined
    backgroundImagePosition_value?: Position | Alignment | undefined
    backgroundEffect_value?: BackgroundEffectOptions | undefined
    backgroundImageResizable_value?: ResizableOptions | undefined
    foregroundEffect_value?: ForegroundEffectOptions | undefined
    visualEffect_value?: uiEffect.VisualEffect | undefined
    backgroundFilter_value?: uiEffect.Filter | undefined
    foregroundFilter_value?: uiEffect.Filter | undefined
    compositingFilter_value?: uiEffect.Filter | undefined
    opacity_value?: number | Resource | undefined
    border_value?: BorderOptions | undefined
    borderStyle_value?: BorderStyle | EdgeStyles | undefined
    borderWidth_value?: Length | EdgeWidths | LocalizedEdgeWidths | undefined
    borderColor_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    borderRadius_value?: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
    borderImage_value?: BorderImageOption | undefined
    outline_value?: OutlineOptions | undefined
    outlineStyle_value?: OutlineStyle | EdgeOutlineStyles | undefined
    outlineWidth_value?: Dimension | EdgeOutlineWidths | undefined
    outlineColor_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    outlineRadius_value?: Dimension | OutlineRadiuses | undefined
    foregroundColor_value?: ResourceColor | ColoringStrategy | undefined
    onClick_value?: ((event: ClickEvent) => void) | undefined
    onHover_value?: ((isHover: boolean,event: HoverEvent) => void) | undefined
    onHoverMove_value?: ((value0: HoverEvent) => void) | undefined
    onAccessibilityHover_value?: AccessibilityCallback | undefined
    hoverEffect_value?: HoverEffect | undefined
    onMouse_value?: ((event: MouseEvent) => void) | undefined
    onTouch_value?: ((event: TouchEvent) => void) | undefined
    onKeyEvent_value?: ((event: KeyEvent) => void) | undefined
    onDigitalCrown_value?: ((value0: CrownEvent) => void) | undefined
    onKeyPreIme_value?: ((value0: KeyEvent) => boolean) | undefined
    onKeyEventDispatch_value?: ((value0: KeyEvent) => boolean) | undefined
    onFocusAxisEvent_value?: ((value0: FocusAxisEvent) => void) | undefined
    onAxisEvent_value?: ((value0: AxisEvent) => void) | undefined
    focusable_value?: boolean | undefined
    nextFocus_value?: FocusMovement | undefined
    tabStop_value?: boolean | undefined
    onFocus_value?: (() => void) | undefined
    onBlur_value?: (() => void) | undefined
    tabIndex_value?: number | undefined
    defaultFocus_value?: boolean | undefined
    groupDefaultFocus_value?: boolean | undefined
    focusOnTouch_value?: boolean | undefined
    focusBox_value?: FocusBoxStyle | undefined
    animation_value?: AnimateParam | undefined
    transition_value?: TransitionEffect | undefined
    motionBlur_value?: MotionBlurOptions | undefined
    brightness_value?: number | undefined
    contrast_value?: number | undefined
    grayscale_value?: number | undefined
    colorBlend_value?: Color | string | Resource | undefined
    saturate_value?: number | undefined
    sepia_value?: number | undefined
    invert_value?: number | InvertOptions | undefined
    hueRotate_value?: number | string | undefined
    useShadowBatching_value?: boolean | undefined
    useEffect_value?: boolean | undefined
    renderGroup_value?: boolean | undefined
    freeze_value?: boolean | undefined
    translate_value?: TranslateOptions | undefined
    scale_value?: ScaleOptions | undefined
    rotate_value?: RotateOptions | undefined
    transform_value?: Object | undefined
    onAppear_value?: (() => void) | undefined
    onDisAppear_value?: (() => void) | undefined
    onAttach_value?: VoidCallback | undefined
    onDetach_value?: VoidCallback | undefined
    onAreaChange_value?: ((oldValue: Area,newValue: Area) => void) | undefined
    visibility_value?: Visibility | undefined
    flexGrow_value?: number | undefined
    flexShrink_value?: number | undefined
    flexBasis_value?: number | string | undefined
    alignSelf_value?: ItemAlign | undefined
    displayPriority_value?: number | undefined
    zIndex_value?: number | undefined
    direction_value?: Direction | undefined
    align_value?: Alignment | undefined
    position_value?: Position | Edges | LocalizedEdges | undefined
    markAnchor_value?: Position | LocalizedPosition | undefined
    offset_value?: Position | Edges | LocalizedEdges | undefined
    enabled_value?: boolean | undefined
    alignRules_value?: AlignRuleOption | undefined
    aspectRatio_value?: number | undefined
    clickEffect_value?: ClickEffect | undefined
    onDragStart_value?: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined
    onDragEnter_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragMove_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragLeave_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDrop_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragEnd_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    allowDrop_value?: Array<uniformTypeDescriptor.UniformDataType> | undefined
    draggable_value?: boolean | undefined
    dragPreview_value?: CustomBuilder | DragItemInfo | string | undefined
    onPreDrag_value?: ((value0: PreDragStatus) => void) | undefined
    linearGradient_value?: LinearGradientOptions | undefined
    sweepGradient_value?: SweepGradientOptions | undefined
    radialGradient_value?: RadialGradientOptions | undefined
    motionPath_value?: MotionPathOptions | undefined
    shadow_value?: ShadowOptions | ShadowStyle | undefined
    clip_value?: boolean | undefined
    clipShape_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    mask_value?: ProgressMask | undefined
    maskShape_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    key_value?: string | undefined
    id_value?: string | undefined
    geometryTransition_value?: string | undefined
    stateStyles_value?: StateStyles | undefined
    restoreId_value?: number | undefined
    sphericalEffect_value?: number | undefined
    lightUpEffect_value?: number | undefined
    pixelStretchEffect_value?: PixelStretchEffectOptions | undefined
    accessibilityGroup_value?: boolean | undefined
    accessibilityText_value?: string | undefined
    accessibilityNextFocusId_value?: string | undefined
    accessibilityDefaultFocus_value?: boolean | undefined
    accessibilityUseSamePage_value?: AccessibilitySamePageMode | undefined
    accessibilityScrollTriggerable_value?: boolean | undefined
    accessibilityRole_value?: AccessibilityRoleType | undefined
    onAccessibilityFocus_value?: AccessibilityFocusCallback | undefined
    accessibilityTextHint_value?: string | undefined
    accessibilityDescription_value?: string | undefined
    accessibilityLevel_value?: string | undefined
    accessibilityVirtualNode_value?: CustomBuilder | undefined
    accessibilityChecked_value?: boolean | undefined
    accessibilitySelected_value?: boolean | undefined
    obscured_value?: Array<ObscuredReasons> | undefined
    reuseId_value?: string | undefined
    reuse_value?: ReuseOptions | undefined
    renderFit_value?: RenderFit | undefined
    gestureModifier_value?: GestureModifier | undefined
    backgroundBrightness_value?: BackgroundBrightnessOptions | undefined
    onGestureJudgeBegin_value?: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined
    onGestureRecognizerJudgeBegin_value?: GestureRecognizerJudgeBeginCallback | undefined
    shouldBuiltInRecognizerParallelWith_value?: ShouldBuiltInRecognizerParallelWithCallback | undefined
    monopolizeEvents_value?: boolean | undefined
    onTouchIntercept_value?: ((value0: TouchEvent) => HitTestMode) | undefined
    onSizeChange_value?: SizeChangeCallback | undefined
    accessibilityFocusDrawLevel_value?: FocusDrawLevel | undefined
    public width(value: Length | LayoutPolicy | undefined): this {
        return this
    }
    public height(value: Length | LayoutPolicy | undefined): this {
        return this
    }
    public drawModifier(value: DrawModifier | undefined): this {
        return this
    }
    public responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        return this
    }
    public mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        return this
    }
    public size(value: SizeOptions | undefined): this {
        return this
    }
    public constraintSize(value: ConstraintSizeOptions | undefined): this {
        return this
    }
    public hitTestBehavior(value: HitTestMode | undefined): this {
        return this
    }
    public onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        return this
    }
    public layoutWeight(value: number | string | undefined): this {
        return this
    }
    public chainWeight(value: ChainWeightOptions | undefined): this {
        return this
    }
    public padding(value: Padding | Length | LocalizedPadding | undefined): this {
        return this
    }
    public safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        return this
    }
    public margin(value: Padding | Length | LocalizedPadding | undefined): this {
        return this
    }
    public backgroundColor(value: ResourceColor | undefined): this {
        return this
    }
    public pixelRound(value: PixelRoundPolicy | undefined): this {
        return this
    }
    public backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        return this
    }
    public backgroundImagePosition(value: Position | Alignment | undefined): this {
        return this
    }
    public backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        return this
    }
    public backgroundImageResizable(value: ResizableOptions | undefined): this {
        return this
    }
    public foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        return this
    }
    public visualEffect(value: uiEffect.VisualEffect | undefined): this {
        return this
    }
    public backgroundFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    public foregroundFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    public compositingFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    public opacity(value: number | Resource | undefined): this {
        return this
    }
    public border(value: BorderOptions | undefined): this {
        return this
    }
    public borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        return this
    }
    public borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        return this
    }
    public borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        return this
    }
    public borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        return this
    }
    public borderImage(value: BorderImageOption | undefined): this {
        return this
    }
    public outline(value: OutlineOptions | undefined): this {
        return this
    }
    public outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        return this
    }
    public outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        return this
    }
    public outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        return this
    }
    public outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        return this
    }
    public foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        return this
    }
    public onClick(value: ((event: ClickEvent) => void) | undefined): this {
        return this
    }
    public onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        return this
    }
    public onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        return this
    }
    public onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        return this
    }
    public hoverEffect(value: HoverEffect | undefined): this {
        return this
    }
    public onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        return this
    }
    public onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        return this
    }
    public onKeyEvent(value: ((event: KeyEvent) => void) | undefined): this {
        return this
    }
    public onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        return this
    }
    public onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        return this
    }
    public onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        return this
    }
    public onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        return this
    }
    public onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        return this
    }
    public focusable(value: boolean | undefined): this {
        return this
    }
    public nextFocus(value: FocusMovement | undefined): this {
        return this
    }
    public tabStop(value: boolean | undefined): this {
        return this
    }
    public onFocus(value: (() => void) | undefined): this {
        return this
    }
    public onBlur(value: (() => void) | undefined): this {
        return this
    }
    public tabIndex(value: number | undefined): this {
        return this
    }
    public defaultFocus(value: boolean | undefined): this {
        return this
    }
    public groupDefaultFocus(value: boolean | undefined): this {
        return this
    }
    public focusOnTouch(value: boolean | undefined): this {
        return this
    }
    public focusBox(value: FocusBoxStyle | undefined): this {
        return this
    }
    public animation(value: AnimateParam | undefined): this {
        return this
    }
    public transition(value: TransitionEffect | undefined): this {
        return this
    }
    public motionBlur(value: MotionBlurOptions | undefined): this {
        return this
    }
    public brightness(value: number | undefined): this {
        return this
    }
    public contrast(value: number | undefined): this {
        return this
    }
    public grayscale(value: number | undefined): this {
        return this
    }
    public colorBlend(value: Color | string | Resource | undefined): this {
        return this
    }
    public saturate(value: number | undefined): this {
        return this
    }
    public sepia(value: number | undefined): this {
        return this
    }
    public invert(value: number | InvertOptions | undefined): this {
        return this
    }
    public hueRotate(value: number | string | undefined): this {
        return this
    }
    public useShadowBatching(value: boolean | undefined): this {
        return this
    }
    public useEffect(value: boolean | undefined): this {
        return this
    }
    public renderGroup(value: boolean | undefined): this {
        return this
    }
    public freeze(value: boolean | undefined): this {
        return this
    }
    public translate(value: TranslateOptions | undefined): this {
        return this
    }
    public scale(value: ScaleOptions | undefined): this {
        return this
    }
    public rotate(value: RotateOptions | undefined): this {
        return this
    }
    public transform(value: Object | undefined): this {
        return this
    }
    public onAppear(value: (() => void) | undefined): this {
        return this
    }
    public onDisAppear(value: (() => void) | undefined): this {
        return this
    }
    public onAttach(value: VoidCallback | undefined): this {
        return this
    }
    public onDetach(value: VoidCallback | undefined): this {
        return this
    }
    public onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        return this
    }
    public visibility(value: Visibility | undefined): this {
        return this
    }
    public flexGrow(value: number | undefined): this {
        return this
    }
    public flexShrink(value: number | undefined): this {
        return this
    }
    public flexBasis(value: number | string | undefined): this {
        return this
    }
    public alignSelf(value: ItemAlign | undefined): this {
        return this
    }
    public displayPriority(value: number | undefined): this {
        return this
    }
    public zIndex(value: number | undefined): this {
        return this
    }
    public direction(value: Direction | undefined): this {
        return this
    }
    public align(value: Alignment | undefined): this {
        return this
    }
    public position(value: Position | Edges | LocalizedEdges | undefined): this {
        return this
    }
    public markAnchor(value: Position | LocalizedPosition | undefined): this {
        return this
    }
    public offset(value: Position | Edges | LocalizedEdges | undefined): this {
        return this
    }
    public enabled(value: boolean | undefined): this {
        return this
    }
    public alignRules(value: AlignRuleOption | undefined): this {
        return this
    }
    public alignRules(value: LocalizedAlignRuleOptions | undefined): this {
        return this
    }
    public aspectRatio(value: number | undefined): this {
        return this
    }
    public clickEffect(value: ClickEffect | undefined): this {
        return this
    }
    public onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        return this
    }
    public onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    public onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    public onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    public onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    public onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    public allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | undefined): this {
        return this
    }
    public draggable(value: boolean | undefined): this {
        return this
    }
    public dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        return this
    }
    public onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        return this
    }
    public linearGradient(value: LinearGradientOptions | undefined): this {
        return this
    }
    public sweepGradient(value: SweepGradientOptions | undefined): this {
        return this
    }
    public radialGradient(value: RadialGradientOptions | undefined): this {
        return this
    }
    public motionPath(value: MotionPathOptions | undefined): this {
        return this
    }
    public shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        return this
    }
    public clip(value: boolean | undefined): this {
        return this
    }
    public clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        return this
    }
    public mask(value: ProgressMask | undefined): this {
        return this
    }
    public maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        return this
    }
    public key(value: string | undefined): this {
        return this
    }
    public id(value: string | undefined): this {
        return this
    }
    public geometryTransition(value: string | undefined): this {
        return this
    }
    public stateStyles(value: StateStyles | undefined): this {
        return this
    }
    public restoreId(value: number | undefined): this {
        return this
    }
    public sphericalEffect(value: number | undefined): this {
        return this
    }
    public lightUpEffect(value: number | undefined): this {
        return this
    }
    public pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        return this
    }
    public accessibilityGroup(value: boolean | undefined): this {
        return this
    }
    public accessibilityText(value: string | undefined): this {
        return this
    }
    public accessibilityNextFocusId(value: string | undefined): this {
        return this
    }
    public accessibilityDefaultFocus(value: boolean | undefined): this {
        return this
    }
    public accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        return this
    }
    public accessibilityScrollTriggerable(value: boolean | undefined): this {
        return this
    }
    public accessibilityText(value: Resource | undefined): this {
        return this
    }
    public accessibilityRole(value: AccessibilityRoleType | undefined): this {
        return this
    }
    public onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        return this
    }
    public accessibilityTextHint(value: string | undefined): this {
        return this
    }
    public accessibilityDescription(value: string | undefined): this {
        return this
    }
    public accessibilityDescription(value: Resource | undefined): this {
        return this
    }
    public accessibilityLevel(value: string | undefined): this {
        return this
    }
    public accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        return this
    }
    public accessibilityChecked(value: boolean | undefined): this {
        return this
    }
    public accessibilitySelected(value: boolean | undefined): this {
        return this
    }
    public obscured(value: Array<ObscuredReasons> | undefined): this {
        return this
    }
    public reuseId(value: string | undefined): this {
        return this
    }
    public reuse(value: ReuseOptions | undefined): this {
        return this
    }
    public renderFit(value: RenderFit | undefined): this {
        return this
    }
    public gestureModifier(value: GestureModifier | undefined): this {
        return this
    }
    public backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        return this
    }
    public onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        return this
    }
    public onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        return this
    }
    public shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        return this
    }
    public monopolizeEvents(value: boolean | undefined): this {
        return this
    }
    public onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        return this
    }
    public onSizeChange(value: SizeChangeCallback | undefined): this {
        return this
    }
    public accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        return this
    }
    public customProperty(name: string | undefined, value: Object | undefined): this {
        return this
    }
    public expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        return this
    }
    public background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): this {
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): this {
        return this
    }
    public backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    public backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    public foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    public onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: number | undefined): this {
        return this
    }
    public focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        return this
    }
    public focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        return this
    }
    public transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        return this
    }
    public gesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        return this
    }
    public priorityGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        return this
    }
    public parallelGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        return this
    }
    public blur(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    public linearGradientBlur(value: number | undefined, options: LinearGradientBlurOptions | undefined): this {
        return this
    }
    public systemBarEffect(): this {
        return this
    }
    public useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        return this
    }
    public backdropBlur(radius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    public sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        return this
    }
    public chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        return this
    }
    public onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        return this
    }
    public dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        return this
    }
    public dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        return this
    }
    public overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        return this
    }
    public blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        return this
    }
    public advancedBlendMode(effect: BlendMode | uiEffect.Blender | undefined, type?: BlendApplyType): this {
        return this
    }
    public geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        return this
    }
    public bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        return this
    }
    public bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        return this
    }
    public bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        return this
    }
    public bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        return this
    }
    public bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        return this
    }
    public bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        return this
    }
    public bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        return this
    }
    public bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        return this
    }
    public bindSheet(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        return this
    }
    public onVisibleAreaChange(ratios: Array<number> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        return this
    }
    public onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        return this
    }
    public keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        return this
    }
    public accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions: AccessibilityOptions | undefined): this {
        return this
    }
    public onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
    public apply(target: CommonMethod): void {
        if (this.width_value !== undefined)
            target.width(this.width_value!)
        if (this.height_value !== undefined)
            target.height(this.height_value!)
        if (this.drawModifier_value !== undefined)
            target.drawModifier(this.drawModifier_value!)
        if (this.responseRegion_value !== undefined)
            target.responseRegion(this.responseRegion_value!)
        if (this.mouseResponseRegion_value !== undefined)
            target.mouseResponseRegion(this.mouseResponseRegion_value!)
        if (this.size_value !== undefined)
            target.size(this.size_value!)
        if (this.constraintSize_value !== undefined)
            target.constraintSize(this.constraintSize_value!)
        if (this.hitTestBehavior_value !== undefined)
            target.hitTestBehavior(this.hitTestBehavior_value!)
        if (this.onChildTouchTest_value !== undefined)
            target.onChildTouchTest(this.onChildTouchTest_value!)
        if (this.layoutWeight_value !== undefined)
            target.layoutWeight(this.layoutWeight_value!)
        if (this.chainWeight_value !== undefined)
            target.chainWeight(this.chainWeight_value!)
        if (this.padding_value !== undefined)
            target.padding(this.padding_value!)
        if (this.safeAreaPadding_value !== undefined)
            target.safeAreaPadding(this.safeAreaPadding_value!)
        if (this.margin_value !== undefined)
            target.margin(this.margin_value!)
        if (this.backgroundColor_value !== undefined)
            target.backgroundColor(this.backgroundColor_value!)
        if (this.pixelRound_value !== undefined)
            target.pixelRound(this.pixelRound_value!)
        if (this.backgroundImageSize_value !== undefined)
            target.backgroundImageSize(this.backgroundImageSize_value!)
        if (this.backgroundImagePosition_value !== undefined)
            target.backgroundImagePosition(this.backgroundImagePosition_value!)
        if (this.backgroundEffect_value !== undefined)
            target.backgroundEffect(this.backgroundEffect_value!)
        if (this.backgroundImageResizable_value !== undefined)
            target.backgroundImageResizable(this.backgroundImageResizable_value!)
        if (this.foregroundEffect_value !== undefined)
            target.foregroundEffect(this.foregroundEffect_value!)
        if (this.visualEffect_value !== undefined)
            target.visualEffect(this.visualEffect_value!)
        if (this.backgroundFilter_value !== undefined)
            target.backgroundFilter(this.backgroundFilter_value!)
        if (this.foregroundFilter_value !== undefined)
            target.foregroundFilter(this.foregroundFilter_value!)
        if (this.compositingFilter_value !== undefined)
            target.compositingFilter(this.compositingFilter_value!)
        if (this.opacity_value !== undefined)
            target.opacity(this.opacity_value!)
        if (this.border_value !== undefined)
            target.border(this.border_value!)
        if (this.borderStyle_value !== undefined)
            target.borderStyle(this.borderStyle_value!)
        if (this.borderWidth_value !== undefined)
            target.borderWidth(this.borderWidth_value!)
        if (this.borderColor_value !== undefined)
            target.borderColor(this.borderColor_value!)
        if (this.borderRadius_value !== undefined)
            target.borderRadius(this.borderRadius_value!)
        if (this.borderImage_value !== undefined)
            target.borderImage(this.borderImage_value!)
        if (this.outline_value !== undefined)
            target.outline(this.outline_value!)
        if (this.outlineStyle_value !== undefined)
            target.outlineStyle(this.outlineStyle_value!)
        if (this.outlineWidth_value !== undefined)
            target.outlineWidth(this.outlineWidth_value!)
        if (this.outlineColor_value !== undefined)
            target.outlineColor(this.outlineColor_value!)
        if (this.outlineRadius_value !== undefined)
            target.outlineRadius(this.outlineRadius_value!)
        if (this.foregroundColor_value !== undefined)
            target.foregroundColor(this.foregroundColor_value!)
        if (this.onClick_value !== undefined)
            target.onClick(this.onClick_value!)
        if (this.onHover_value !== undefined)
            target.onHover(this.onHover_value!)
        if (this.onHoverMove_value !== undefined)
            target.onHoverMove(this.onHoverMove_value!)
        if (this.onAccessibilityHover_value !== undefined)
            target.onAccessibilityHover(this.onAccessibilityHover_value!)
        if (this.hoverEffect_value !== undefined)
            target.hoverEffect(this.hoverEffect_value!)
        if (this.onMouse_value !== undefined)
            target.onMouse(this.onMouse_value!)
        if (this.onTouch_value !== undefined)
            target.onTouch(this.onTouch_value!)
        if (this.onKeyEvent_value !== undefined)
            target.onKeyEvent(this.onKeyEvent_value!)
        if (this.onDigitalCrown_value !== undefined)
            target.onDigitalCrown(this.onDigitalCrown_value!)
        if (this.onKeyPreIme_value !== undefined)
            target.onKeyPreIme(this.onKeyPreIme_value!)
        if (this.onKeyEventDispatch_value !== undefined)
            target.onKeyEventDispatch(this.onKeyEventDispatch_value!)
        if (this.onFocusAxisEvent_value !== undefined)
            target.onFocusAxisEvent(this.onFocusAxisEvent_value!)
        if (this.onAxisEvent_value !== undefined)
            target.onAxisEvent(this.onAxisEvent_value!)
        if (this.focusable_value !== undefined)
            target.focusable(this.focusable_value!)
        if (this.nextFocus_value !== undefined)
            target.nextFocus(this.nextFocus_value!)
        if (this.tabStop_value !== undefined)
            target.tabStop(this.tabStop_value!)
        if (this.onFocus_value !== undefined)
            target.onFocus(this.onFocus_value!)
        if (this.onBlur_value !== undefined)
            target.onBlur(this.onBlur_value!)
        if (this.tabIndex_value !== undefined)
            target.tabIndex(this.tabIndex_value!)
        if (this.defaultFocus_value !== undefined)
            target.defaultFocus(this.defaultFocus_value!)
        if (this.groupDefaultFocus_value !== undefined)
            target.groupDefaultFocus(this.groupDefaultFocus_value!)
        if (this.focusOnTouch_value !== undefined)
            target.focusOnTouch(this.focusOnTouch_value!)
        if (this.focusBox_value !== undefined)
            target.focusBox(this.focusBox_value!)
        if (this.animation_value !== undefined)
            target.animation(this.animation_value!)
        if (this.transition_value !== undefined)
            target.transition(this.transition_value!)
        if (this.motionBlur_value !== undefined)
            target.motionBlur(this.motionBlur_value!)
        if (this.brightness_value !== undefined)
            target.brightness(this.brightness_value!)
        if (this.contrast_value !== undefined)
            target.contrast(this.contrast_value!)
        if (this.grayscale_value !== undefined)
            target.grayscale(this.grayscale_value!)
        if (this.colorBlend_value !== undefined)
            target.colorBlend(this.colorBlend_value!)
        if (this.saturate_value !== undefined)
            target.saturate(this.saturate_value!)
        if (this.sepia_value !== undefined)
            target.sepia(this.sepia_value!)
        if (this.invert_value !== undefined)
            target.invert(this.invert_value!)
        if (this.hueRotate_value !== undefined)
            target.hueRotate(this.hueRotate_value!)
        if (this.useShadowBatching_value !== undefined)
            target.useShadowBatching(this.useShadowBatching_value!)
        if (this.useEffect_value !== undefined)
            target.useEffect(this.useEffect_value!)
        if (this.renderGroup_value !== undefined)
            target.renderGroup(this.renderGroup_value!)
        if (this.freeze_value !== undefined)
            target.freeze(this.freeze_value!)
        if (this.translate_value !== undefined)
            target.translate(this.translate_value!)
        if (this.scale_value !== undefined)
            target.scale(this.scale_value!)
        if (this.rotate_value !== undefined)
            target.rotate(this.rotate_value!)
        if (this.transform_value !== undefined)
            target.transform(this.transform_value!)
        if (this.onAppear_value !== undefined)
            target.onAppear(this.onAppear_value!)
        if (this.onDisAppear_value !== undefined)
            target.onDisAppear(this.onDisAppear_value!)
        if (this.onAttach_value !== undefined)
            target.onAttach(this.onAttach_value!)
        if (this.onDetach_value !== undefined)
            target.onDetach(this.onDetach_value!)
        if (this.onAreaChange_value !== undefined)
            target.onAreaChange(this.onAreaChange_value!)
        if (this.visibility_value !== undefined)
            target.visibility(this.visibility_value!)
        if (this.flexGrow_value !== undefined)
            target.flexGrow(this.flexGrow_value!)
        if (this.flexShrink_value !== undefined)
            target.flexShrink(this.flexShrink_value!)
        if (this.flexBasis_value !== undefined)
            target.flexBasis(this.flexBasis_value!)
        if (this.alignSelf_value !== undefined)
            target.alignSelf(this.alignSelf_value!)
        if (this.displayPriority_value !== undefined)
            target.displayPriority(this.displayPriority_value!)
        if (this.zIndex_value !== undefined)
            target.zIndex(this.zIndex_value!)
        if (this.direction_value !== undefined)
            target.direction(this.direction_value!)
        if (this.align_value !== undefined)
            target.align(this.align_value!)
        if (this.position_value !== undefined)
            target.position(this.position_value!)
        if (this.markAnchor_value !== undefined)
            target.markAnchor(this.markAnchor_value!)
        if (this.offset_value !== undefined)
            target.offset(this.offset_value!)
        if (this.enabled_value !== undefined)
            target.enabled(this.enabled_value!)
        if (this.alignRules_value !== undefined)
            target.alignRules(this.alignRules_value!)
        if (this.aspectRatio_value !== undefined)
            target.aspectRatio(this.aspectRatio_value!)
        if (this.clickEffect_value !== undefined)
            target.clickEffect(this.clickEffect_value!)
        if (this.onDragStart_value !== undefined)
            target.onDragStart(this.onDragStart_value!)
        if (this.onDragEnter_value !== undefined)
            target.onDragEnter(this.onDragEnter_value!)
        if (this.onDragMove_value !== undefined)
            target.onDragMove(this.onDragMove_value!)
        if (this.onDragLeave_value !== undefined)
            target.onDragLeave(this.onDragLeave_value!)
        if (this.onDrop_value !== undefined)
            target.onDrop(this.onDrop_value!)
        if (this.onDragEnd_value !== undefined)
            target.onDragEnd(this.onDragEnd_value!)
        if (this.allowDrop_value !== undefined)
            target.allowDrop(this.allowDrop_value!)
        if (this.draggable_value !== undefined)
            target.draggable(this.draggable_value!)
        if (this.dragPreview_value !== undefined)
            target.dragPreview(this.dragPreview_value!)
        if (this.onPreDrag_value !== undefined)
            target.onPreDrag(this.onPreDrag_value!)
        if (this.linearGradient_value !== undefined)
            target.linearGradient(this.linearGradient_value!)
        if (this.sweepGradient_value !== undefined)
            target.sweepGradient(this.sweepGradient_value!)
        if (this.radialGradient_value !== undefined)
            target.radialGradient(this.radialGradient_value!)
        if (this.motionPath_value !== undefined)
            target.motionPath(this.motionPath_value!)
        if (this.shadow_value !== undefined)
            target.shadow(this.shadow_value!)
        if (this.clip_value !== undefined)
            target.clip(this.clip_value!)
        if (this.clipShape_value !== undefined)
            target.clipShape(this.clipShape_value!)
        if (this.mask_value !== undefined)
            target.mask(this.mask_value!)
        if (this.maskShape_value !== undefined)
            target.maskShape(this.maskShape_value!)
        if (this.key_value !== undefined)
            target.key(this.key_value!)
        if (this.id_value !== undefined)
            target.id(this.id_value!)
        if (this.geometryTransition_value !== undefined)
            target.geometryTransition(this.geometryTransition_value!)
        if (this.stateStyles_value !== undefined)
            target.stateStyles(this.stateStyles_value!)
        if (this.restoreId_value !== undefined)
            target.restoreId(this.restoreId_value!)
        if (this.sphericalEffect_value !== undefined)
            target.sphericalEffect(this.sphericalEffect_value!)
        if (this.lightUpEffect_value !== undefined)
            target.lightUpEffect(this.lightUpEffect_value!)
        if (this.pixelStretchEffect_value !== undefined)
            target.pixelStretchEffect(this.pixelStretchEffect_value!)
        if (this.accessibilityGroup_value !== undefined)
            target.accessibilityGroup(this.accessibilityGroup_value!)
        if (this.accessibilityText_value !== undefined)
            target.accessibilityText(this.accessibilityText_value!)
        if (this.accessibilityNextFocusId_value !== undefined)
            target.accessibilityNextFocusId(this.accessibilityNextFocusId_value!)
        if (this.accessibilityDefaultFocus_value !== undefined)
            target.accessibilityDefaultFocus(this.accessibilityDefaultFocus_value!)
        if (this.accessibilityUseSamePage_value !== undefined)
            target.accessibilityUseSamePage(this.accessibilityUseSamePage_value!)
        if (this.accessibilityScrollTriggerable_value !== undefined)
            target.accessibilityScrollTriggerable(this.accessibilityScrollTriggerable_value!)
        if (this.accessibilityRole_value !== undefined)
            target.accessibilityRole(this.accessibilityRole_value!)
        if (this.onAccessibilityFocus_value !== undefined)
            target.onAccessibilityFocus(this.onAccessibilityFocus_value!)
        if (this.accessibilityTextHint_value !== undefined)
            target.accessibilityTextHint(this.accessibilityTextHint_value!)
        if (this.accessibilityDescription_value !== undefined)
            target.accessibilityDescription(this.accessibilityDescription_value!)
        if (this.accessibilityLevel_value !== undefined)
            target.accessibilityLevel(this.accessibilityLevel_value!)
        if (this.accessibilityVirtualNode_value !== undefined)
            target.accessibilityVirtualNode(this.accessibilityVirtualNode_value!)
        if (this.accessibilityChecked_value !== undefined)
            target.accessibilityChecked(this.accessibilityChecked_value!)
        if (this.accessibilitySelected_value !== undefined)
            target.accessibilitySelected(this.accessibilitySelected_value!)
        if (this.obscured_value !== undefined)
            target.obscured(this.obscured_value!)
        if (this.reuseId_value !== undefined)
            target.reuseId(this.reuseId_value!)
        if (this.reuse_value !== undefined)
            target.reuse(this.reuse_value!)
        if (this.renderFit_value !== undefined)
            target.renderFit(this.renderFit_value!)
        if (this.gestureModifier_value !== undefined)
            target.gestureModifier(this.gestureModifier_value!)
        if (this.backgroundBrightness_value !== undefined)
            target.backgroundBrightness(this.backgroundBrightness_value!)
        if (this.onGestureJudgeBegin_value !== undefined)
            target.onGestureJudgeBegin(this.onGestureJudgeBegin_value!)
        if (this.onGestureRecognizerJudgeBegin_value !== undefined)
            target.onGestureRecognizerJudgeBegin(this.onGestureRecognizerJudgeBegin_value!)
        if (this.shouldBuiltInRecognizerParallelWith_value !== undefined)
            target.shouldBuiltInRecognizerParallelWith(this.shouldBuiltInRecognizerParallelWith_value!)
        if (this.monopolizeEvents_value !== undefined)
            target.monopolizeEvents(this.monopolizeEvents_value!)
        if (this.onTouchIntercept_value !== undefined)
            target.onTouchIntercept(this.onTouchIntercept_value!)
        if (this.onSizeChange_value !== undefined)
            target.onSizeChange(this.onSizeChange_value!)
        if (this.accessibilityFocusDrawLevel_value !== undefined)
            target.accessibilityFocusDrawLevel(this.accessibilityFocusDrawLevel_value!)
    }
}
export type CommonAttribute = CommonMethod;
export interface OverlayOptions {
    align?: Alignment;
    offset?: OverlayOffset;
}
export interface OverlayOffset {
    x?: number;
    y?: number;
}
export type FractionStop = [
    number,
    number
]
export interface CommonShapeMethod extends CommonMethod {
    stroke(value: ResourceColor | undefined): this {
        throw new Error("Unimplemented method stroke")
    }
    fill(value: ResourceColor | undefined): this {
        throw new Error("Unimplemented method fill")
    }
    strokeDashOffset(value: number | string | undefined): this {
        throw new Error("Unimplemented method strokeDashOffset")
    }
    strokeLineCap(value: LineCapStyle | undefined): this {
        throw new Error("Unimplemented method strokeLineCap")
    }
    strokeLineJoin(value: LineJoinStyle | undefined): this {
        throw new Error("Unimplemented method strokeLineJoin")
    }
    strokeMiterLimit(value: number | string | undefined): this {
        throw new Error("Unimplemented method strokeMiterLimit")
    }
    strokeOpacity(value: number | string | Resource | undefined): this {
        throw new Error("Unimplemented method strokeOpacity")
    }
    fillOpacity(value: number | string | Resource | undefined): this {
        throw new Error("Unimplemented method fillOpacity")
    }
    strokeWidth(value: Length | undefined): this {
        throw new Error("Unimplemented method strokeWidth")
    }
    antiAlias(value: boolean | undefined): this {
        throw new Error("Unimplemented method antiAlias")
    }
    strokeDashArray(value: Array<Length> | undefined): this {
        throw new Error("Unimplemented method strokeDashArray")
    }
    attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkCommonShapeMethodStyle extends ArkCommonMethodStyle implements CommonShapeMethod {
    stroke_value?: ResourceColor | undefined
    fill_value?: ResourceColor | undefined
    strokeDashOffset_value?: number | string | undefined
    strokeLineCap_value?: LineCapStyle | undefined
    strokeLineJoin_value?: LineJoinStyle | undefined
    strokeMiterLimit_value?: number | string | undefined
    strokeOpacity_value?: number | string | Resource | undefined
    fillOpacity_value?: number | string | Resource | undefined
    strokeWidth_value?: Length | undefined
    antiAlias_value?: boolean | undefined
    strokeDashArray_value?: Array<Length> | undefined
    public stroke(value: ResourceColor | undefined): this {
        return this
    }
    public fill(value: ResourceColor | undefined): this {
        return this
    }
    public strokeDashOffset(value: number | string | undefined): this {
        return this
    }
    public strokeLineCap(value: LineCapStyle | undefined): this {
        return this
    }
    public strokeLineJoin(value: LineJoinStyle | undefined): this {
        return this
    }
    public strokeMiterLimit(value: number | string | undefined): this {
        return this
    }
    public strokeOpacity(value: number | string | Resource | undefined): this {
        return this
    }
    public fillOpacity(value: number | string | Resource | undefined): this {
        return this
    }
    public strokeWidth(value: Length | undefined): this {
        return this
    }
    public antiAlias(value: boolean | undefined): this {
        return this
    }
    public strokeDashArray(value: Array<Length> | undefined): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
    public apply(target: CommonShapeMethod): void {
        super.apply(target)
        if (this.stroke_value !== undefined)
            target.stroke(this.stroke_value!)
        if (this.fill_value !== undefined)
            target.fill(this.fill_value!)
        if (this.strokeDashOffset_value !== undefined)
            target.strokeDashOffset(this.strokeDashOffset_value!)
        if (this.strokeLineCap_value !== undefined)
            target.strokeLineCap(this.strokeLineCap_value!)
        if (this.strokeLineJoin_value !== undefined)
            target.strokeLineJoin(this.strokeLineJoin_value!)
        if (this.strokeMiterLimit_value !== undefined)
            target.strokeMiterLimit(this.strokeMiterLimit_value!)
        if (this.strokeOpacity_value !== undefined)
            target.strokeOpacity(this.strokeOpacity_value!)
        if (this.fillOpacity_value !== undefined)
            target.fillOpacity(this.fillOpacity_value!)
        if (this.strokeWidth_value !== undefined)
            target.strokeWidth(this.strokeWidth_value!)
        if (this.antiAlias_value !== undefined)
            target.antiAlias(this.antiAlias_value!)
        if (this.strokeDashArray_value !== undefined)
            target.strokeDashArray(this.strokeDashArray_value!)
    }
}
export interface PixelRoundPolicy {
    start?: PixelRoundCalcPolicy;
    top?: PixelRoundCalcPolicy;
    end?: PixelRoundCalcPolicy;
    bottom?: PixelRoundCalcPolicy;
}
export interface LinearGradientBlurOptions {
    fractionStops: Array<FractionStop>;
    direction: GradientDirection;
}
export interface MotionBlurAnchor {
    x: number;
    y: number;
}
export interface MotionBlurOptions {
    radius: number;
    anchor: MotionBlurAnchor;
}
export interface GeometryInfo extends SizeResult {
    borderWidth: EdgeWidths;
    margin: Padding;
    padding: Padding;
}
export interface SizeResult {
    width: number;
    height: number;
}
export interface MeasureResult extends SizeResult {
}
export type NavDestinationInfo = object;
export type NavigationInfo = object;
export type RouterPageInfo = object;
export { UIContext } from "./../generated/ohos.arkui.UIContext"
export { DrawContext } from "./../generated/arkui.Graphics"
export type VisualEffect = uiEffect.VisualEffect;
export type Filter = uiEffect.Filter;
export type Blender = uiEffect.Blender;
export type PromptActionDialogController = promptAction.DialogController;
export interface RectResult {
    x: number;
    y: number;
    width: number;
    height: number;
}
export interface CaretOffset {
    index: number;
    x: number;
    y: number;
}
export interface TextContentControllerOptions {
    offset?: number;
}
export enum ContentClipMode {
    CONTENT_ONLY = 0,
    BOUNDARY = 1,
    SAFE_AREA = 2
}
export interface ScrollableCommonMethod extends CommonMethod {
    scrollBar(value: BarState | undefined): this {
        throw new Error("Unimplemented method scrollBar")
    }
    scrollBarColor(value: Color | number | string | undefined): this {
        throw new Error("Unimplemented method scrollBarColor")
    }
    scrollBarWidth(value: number | string | undefined): this {
        throw new Error("Unimplemented method scrollBarWidth")
    }
    nestedScroll(value: NestedScrollOptions | undefined): this {
        throw new Error("Unimplemented method nestedScroll")
    }
    enableScrollInteraction(value: boolean | undefined): this {
        throw new Error("Unimplemented method enableScrollInteraction")
    }
    friction(value: number | Resource | undefined): this {
        throw new Error("Unimplemented method friction")
    }
    onReachStart(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onReachStart")
    }
    onReachEnd(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onReachEnd")
    }
    onScrollStart(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onScrollStart")
    }
    onScrollStop(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onScrollStop")
    }
    flingSpeedLimit(value: number | undefined): this {
        throw new Error("Unimplemented method flingSpeedLimit")
    }
    clipContent(value: ContentClipMode | RectShape | undefined): this {
        throw new Error("Unimplemented method clipContent")
    }
    digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        throw new Error("Unimplemented method digitalCrownSensitivity")
    }
    backToTop(value: boolean | undefined): this {
        throw new Error("Unimplemented method backToTop")
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        throw new Error("Unimplemented method edgeEffect")
    }
    fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        throw new Error("Unimplemented method fadingEdge")
    }
    attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkScrollableCommonMethodStyle extends ArkCommonMethodStyle implements ScrollableCommonMethod {
    public scrollBar(value: BarState | undefined): this {
        return this
    }
    public scrollBarColor(value: Color | number | string | undefined): this {
        return this
    }
    public scrollBarWidth(value: number | string | undefined): this {
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        return this
    }
    public friction(value: number | Resource | undefined): this {
        return this
    }
    public onReachStart(value: (() => void) | undefined): this {
        return this
    }
    public onReachEnd(value: (() => void) | undefined): this {
        return this
    }
    public onScrollStart(value: (() => void) | undefined): this {
        return this
    }
    public onScrollStop(value: (() => void) | undefined): this {
        return this
    }
    public flingSpeedLimit(value: number | undefined): this {
        return this
    }
    public clipContent(value: ContentClipMode | RectShape | undefined): this {
        return this
    }
    public digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        return this
    }
    public backToTop(value: boolean | undefined): this {
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        return this
    }
    public fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
    public apply(target: ScrollableCommonMethod): void {
        super.apply(target)
    }
}
export type OnWillScrollCallback = (scrollOffset: number, scrollState: ScrollState, scrollSource: ScrollSource) => ScrollResult | undefined;
export type OnScrollCallback = (scrollOffset: number, scrollState: ScrollState) => void;
export type OnItemDragStartCallback = (event: ItemDragInfo, itemIndex: number) => CustomBuilder | undefined;
export type OnMoveHandler = (from: number, to: number) => void;
export interface ItemDragEventHandler {
    onLongPress?: ((value0: number) => void);
    onDragStart?: ((value0: number) => void);
    onMoveThrough?: OnMoveHandler;
    onDrop?: ((value0: number) => void);
}
export interface DynamicNode {
}
export interface EdgeEffectOptions {
    alwaysEnabled: boolean;
    effectEdge?: number;
}
export enum EffectEdge {
    START = 1,
    END = 2
}
export interface BackgroundBrightnessOptions {
    rate: number;
    lightUpDegree: number;
}
export interface PointLightStyle {
    lightSource?: LightSource;
    illuminated?: IlluminatedType;
    bloom?: number;
}
export interface LightSource {
    positionX: Dimension;
    positionY: Dimension;
    positionZ: Dimension;
    intensity: number;
    color?: ResourceColor;
}
export interface KeyframeAnimateParam {
    delay?: number;
    iterations?: number;
    onFinish?: (() => void);
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export interface KeyframeState {
    duration: number;
    curve?: curves.Curve | string | curves.ICurve;
    event: (() => void);
}
export type HoverCallback = (isHover: boolean, event: HoverEvent) => void;
export type AccessibilityCallback = (isHover: boolean, event: AccessibilityHoverEvent) => void;
export interface VisibleAreaEventOptions {
    ratios: Array<number>;
    expectedUpdateInterval?: number;
}
export type VisibleAreaChangeCallback = (isExpanding: boolean, currentRatio: number) => void;
export interface UIGestureEvent {
}
export interface SelectionOptions {
    menuPolicy?: MenuPolicy;
}
export interface FocusMovement {
    forward?: string;
    backward?: string;
    up?: string;
    down?: string;
    left?: string;
    right?: string;
}
export enum KeyboardAvoidMode {
    DEFAULT = 0,
    NONE = 1
}
export enum HoverModeAreaType {
    TOP_SCREEN = 0,
    BOTTOM_SCREEN = 1
}
export interface DateRange {
    start?: Date;
    end?: Date;
}
export interface TerminationInfo {
    code: number;
    want?: Want;
}
export type DateTimeOptions = intl.DateTimeOptions;
export interface Bindable<T = void> {
    readonly value: T;
    readonly onChange: ((instance: T) => void);
}
export class ArkCommonMethodComponent extends ComponentBase implements CommonMethod {
    getPeer(): ArkCommonMethodPeer {
        return (this.peer as ArkCommonMethodPeer)
    }
    public width(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority("width")) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public height(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority("height")) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setHeightAttribute(value_casted)
            return this
        }
        return this
    }
    public drawModifier(value: DrawModifier | undefined): this {
        if (this.checkPriority("drawModifier")) {
            const value_casted = value as (DrawModifier | undefined)
            this.getPeer()?.setDrawModifierAttribute(value_casted)
            return this
        }
        return this
    }
    public responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority("responseRegion")) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority("mouseResponseRegion")) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setMouseResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public size(value: SizeOptions | undefined): this {
        if (this.checkPriority("size")) {
            const value_casted = value as (SizeOptions | undefined)
            this.getPeer()?.setSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public constraintSize(value: ConstraintSizeOptions | undefined): this {
        if (this.checkPriority("constraintSize")) {
            const value_casted = value as (ConstraintSizeOptions | undefined)
            this.getPeer()?.setConstraintSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public hitTestBehavior(value: HitTestMode | undefined): this {
        if (this.checkPriority("hitTestBehavior")) {
            const value_casted = value as (HitTestMode | undefined)
            this.getPeer()?.setHitTestBehaviorAttribute(value_casted)
            return this
        }
        return this
    }
    public onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        if (this.checkPriority("onChildTouchTest")) {
            const value_casted = value as (((value: Array<TouchTestInfo>) => TouchResult) | undefined)
            this.getPeer()?.setOnChildTouchTestAttribute(value_casted)
            return this
        }
        return this
    }
    public layoutWeight(value: number | string | undefined): this {
        if (this.checkPriority("layoutWeight")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setLayoutWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public chainWeight(value: ChainWeightOptions | undefined): this {
        if (this.checkPriority("chainWeight")) {
            const value_casted = value as (ChainWeightOptions | undefined)
            this.getPeer()?.setChainWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public padding(value: Padding | Length | LocalizedPadding | undefined): this {
        if (this.checkPriority("padding")) {
            const value_casted = value as (Padding | Length | LocalizedPadding | undefined)
            this.getPeer()?.setPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        if (this.checkPriority("safeAreaPadding")) {
            const value_casted = value as (Padding | LengthMetrics | LocalizedPadding | undefined)
            this.getPeer()?.setSafeAreaPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public margin(value: Padding | Length | LocalizedPadding | undefined): this {
        if (this.checkPriority("margin")) {
            const value_casted = value as (Padding | Length | LocalizedPadding | undefined)
            this.getPeer()?.setMarginAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundColor(value: ResourceColor | undefined): this {
        if (this.checkPriority("backgroundColor")) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setBackgroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelRound(value: PixelRoundPolicy | undefined): this {
        if (this.checkPriority("pixelRound")) {
            const value_casted = value as (PixelRoundPolicy | undefined)
            this.getPeer()?.setPixelRoundAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        if (this.checkPriority("backgroundImageSize")) {
            const value_casted = value as (SizeOptions | ImageSize | undefined)
            this.getPeer()?.setBackgroundImageSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImagePosition(value: Position | Alignment | undefined): this {
        if (this.checkPriority("backgroundImagePosition")) {
            const value_casted = value as (Position | Alignment | undefined)
            this.getPeer()?.setBackgroundImagePositionAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        if (this.checkPriority("backgroundEffect")) {
            const value_casted = value as (BackgroundEffectOptions | undefined)
            this.getPeer()?.setBackgroundEffect0Attribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageResizable(value: ResizableOptions | undefined): this {
        if (this.checkPriority("backgroundImageResizable")) {
            const value_casted = value as (ResizableOptions | undefined)
            this.getPeer()?.setBackgroundImageResizableAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        if (this.checkPriority("foregroundEffect")) {
            const value_casted = value as (ForegroundEffectOptions | undefined)
            this.getPeer()?.setForegroundEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public visualEffect(value: uiEffect.VisualEffect | undefined): this {
        if (this.checkPriority("visualEffect")) {
            const value_casted = value as (uiEffect.VisualEffect | undefined)
            this.getPeer()?.setVisualEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("backgroundFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setBackgroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("foregroundFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setForegroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public compositingFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("compositingFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setCompositingFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public opacity(value: number | Resource | undefined): this {
        if (this.checkPriority("opacity")) {
            const value_casted = value as (number | Resource | undefined)
            this.getPeer()?.setOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public border(value: BorderOptions | undefined): this {
        if (this.checkPriority("border")) {
            const value_casted = value as (BorderOptions | undefined)
            this.getPeer()?.setBorderAttribute(value_casted)
            return this
        }
        return this
    }
    public borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        if (this.checkPriority("borderStyle")) {
            const value_casted = value as (BorderStyle | EdgeStyles | undefined)
            this.getPeer()?.setBorderStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        if (this.checkPriority("borderWidth")) {
            const value_casted = value as (Length | EdgeWidths | LocalizedEdgeWidths | undefined)
            this.getPeer()?.setBorderWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority("borderColor")) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setBorderColorAttribute(value_casted)
            return this
        }
        return this
    }
    public borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        if (this.checkPriority("borderRadius")) {
            const value_casted = value as (Length | BorderRadiuses | LocalizedBorderRadiuses | undefined)
            this.getPeer()?.setBorderRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public borderImage(value: BorderImageOption | undefined): this {
        if (this.checkPriority("borderImage")) {
            const value_casted = value as (BorderImageOption | undefined)
            this.getPeer()?.setBorderImageAttribute(value_casted)
            return this
        }
        return this
    }
    public outline(value: OutlineOptions | undefined): this {
        if (this.checkPriority("outline")) {
            const value_casted = value as (OutlineOptions | undefined)
            this.getPeer()?.setOutlineAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        if (this.checkPriority("outlineStyle")) {
            const value_casted = value as (OutlineStyle | EdgeOutlineStyles | undefined)
            this.getPeer()?.setOutlineStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        if (this.checkPriority("outlineWidth")) {
            const value_casted = value as (Dimension | EdgeOutlineWidths | undefined)
            this.getPeer()?.setOutlineWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority("outlineColor")) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setOutlineColorAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        if (this.checkPriority("outlineRadius")) {
            const value_casted = value as (Dimension | OutlineRadiuses | undefined)
            this.getPeer()?.setOutlineRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        if (this.checkPriority("foregroundColor")) {
            const value_casted = value as (ResourceColor | ColoringStrategy | undefined)
            this.getPeer()?.setForegroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public onClick(value: ((event: ClickEvent) => void) | undefined): this {
        if (this.checkPriority("onClick")) {
            const value_casted = value as (((event: ClickEvent) => void) | undefined)
            this.getPeer()?.setOnClick0Attribute(value_casted)
            return this
        }
        return this
    }
    public onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        if (this.checkPriority("onHover")) {
            const value_casted = value as (((isHover: boolean,event: HoverEvent) => void) | undefined)
            this.getPeer()?.setOnHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        if (this.checkPriority("onHoverMove")) {
            const value_casted = value as (((value0: HoverEvent) => void) | undefined)
            this.getPeer()?.setOnHoverMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        if (this.checkPriority("onAccessibilityHover")) {
            const value_casted = value as (AccessibilityCallback | undefined)
            this.getPeer()?.setOnAccessibilityHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public hoverEffect(value: HoverEffect | undefined): this {
        if (this.checkPriority("hoverEffect")) {
            const value_casted = value as (HoverEffect | undefined)
            this.getPeer()?.setHoverEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        if (this.checkPriority("onMouse")) {
            const value_casted = value as (((event: MouseEvent) => void) | undefined)
            this.getPeer()?.setOnMouseAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        if (this.checkPriority("onTouch")) {
            const value_casted = value as (((event: TouchEvent) => void) | undefined)
            this.getPeer()?.setOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEvent(value: ((event: KeyEvent) => void) | undefined): this {
        if (this.checkPriority("onKeyEvent")) {
            const value_casted = value as (((event: KeyEvent) => void) | undefined)
            this.getPeer()?.setOnKeyEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        if (this.checkPriority("onDigitalCrown")) {
            const value_casted = value as (((value0: CrownEvent) => void) | undefined)
            this.getPeer()?.setOnDigitalCrownAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        if (this.checkPriority("onKeyPreIme")) {
            const value_casted = value as (((value0: KeyEvent) => boolean) | undefined)
            this.getPeer()?.setOnKeyPreImeAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        if (this.checkPriority("onKeyEventDispatch")) {
            const value_casted = value as (((value0: KeyEvent) => boolean) | undefined)
            this.getPeer()?.setOnKeyEventDispatchAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        if (this.checkPriority("onFocusAxisEvent")) {
            const value_casted = value as (((value0: FocusAxisEvent) => void) | undefined)
            this.getPeer()?.setOnFocusAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        if (this.checkPriority("onAxisEvent")) {
            const value_casted = value as (((value0: AxisEvent) => void) | undefined)
            this.getPeer()?.setOnAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public focusable(value: boolean | undefined): this {
        if (this.checkPriority("focusable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusableAttribute(value_casted)
            return this
        }
        return this
    }
    public nextFocus(value: FocusMovement | undefined): this {
        if (this.checkPriority("nextFocus")) {
            const value_casted = value as (FocusMovement | undefined)
            this.getPeer()?.setNextFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public tabStop(value: boolean | undefined): this {
        if (this.checkPriority("tabStop")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setTabStopAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocus(value: (() => void) | undefined): this {
        if (this.checkPriority("onFocus")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public onBlur(value: (() => void) | undefined): this {
        if (this.checkPriority("onBlur")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public tabIndex(value: number | undefined): this {
        if (this.checkPriority("tabIndex")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setTabIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public defaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("defaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public groupDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("groupDefaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setGroupDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public focusOnTouch(value: boolean | undefined): this {
        if (this.checkPriority("focusOnTouch")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public focusBox(value: FocusBoxStyle | undefined): this {
        if (this.checkPriority("focusBox")) {
            const value_casted = value as (FocusBoxStyle | undefined)
            this.getPeer()?.setFocusBoxAttribute(value_casted)
            return this
        }
        return this
    }
    public animation(value: AnimateParam | undefined): this {
        if (this.checkPriority("animation")) {
            const value_casted = value as (AnimateParam | undefined)
            this.getPeer()?.setAnimationAttribute(value_casted)
            return this
        }
        return this
    }
    public transition(value: TransitionEffect | undefined): this {
        if (this.checkPriority("transition")) {
            const value_casted = value as (TransitionEffect | undefined)
            this.getPeer()?.setTransition0Attribute(value_casted)
            return this
        }
        return this
    }
    public motionBlur(value: MotionBlurOptions | undefined): this {
        if (this.checkPriority("motionBlur")) {
            const value_casted = value as (MotionBlurOptions | undefined)
            this.getPeer()?.setMotionBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public brightness(value: number | undefined): this {
        if (this.checkPriority("brightness")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public contrast(value: number | undefined): this {
        if (this.checkPriority("contrast")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setContrastAttribute(value_casted)
            return this
        }
        return this
    }
    public grayscale(value: number | undefined): this {
        if (this.checkPriority("grayscale")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setGrayscaleAttribute(value_casted)
            return this
        }
        return this
    }
    public colorBlend(value: Color | string | Resource | undefined): this {
        if (this.checkPriority("colorBlend")) {
            const value_casted = value as (Color | string | Resource | undefined)
            this.getPeer()?.setColorBlendAttribute(value_casted)
            return this
        }
        return this
    }
    public saturate(value: number | undefined): this {
        if (this.checkPriority("saturate")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setSaturateAttribute(value_casted)
            return this
        }
        return this
    }
    public sepia(value: number | undefined): this {
        if (this.checkPriority("sepia")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setSepiaAttribute(value_casted)
            return this
        }
        return this
    }
    public invert(value: number | InvertOptions | undefined): this {
        if (this.checkPriority("invert")) {
            const value_casted = value as (number | InvertOptions | undefined)
            this.getPeer()?.setInvertAttribute(value_casted)
            return this
        }
        return this
    }
    public hueRotate(value: number | string | undefined): this {
        if (this.checkPriority("hueRotate")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setHueRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public useShadowBatching(value: boolean | undefined): this {
        if (this.checkPriority("useShadowBatching")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseShadowBatchingAttribute(value_casted)
            return this
        }
        return this
    }
    public useEffect(value: boolean | undefined): this {
        if (this.checkPriority("useEffect")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseEffect0Attribute(value_casted)
            return this
        }
        return this
    }
    public renderGroup(value: boolean | undefined): this {
        if (this.checkPriority("renderGroup")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setRenderGroupAttribute(value_casted)
            return this
        }
        return this
    }
    public freeze(value: boolean | undefined): this {
        if (this.checkPriority("freeze")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFreezeAttribute(value_casted)
            return this
        }
        return this
    }
    public translate(value: TranslateOptions | undefined): this {
        if (this.checkPriority("translate")) {
            const value_casted = value as (TranslateOptions | undefined)
            this.getPeer()?.setTranslateAttribute(value_casted)
            return this
        }
        return this
    }
    public scale(value: ScaleOptions | undefined): this {
        if (this.checkPriority("scale")) {
            const value_casted = value as (ScaleOptions | undefined)
            this.getPeer()?.setScaleAttribute(value_casted)
            return this
        }
        return this
    }
    public rotate(value: RotateOptions | undefined): this {
        if (this.checkPriority("rotate")) {
            const value_casted = value as (RotateOptions | undefined)
            this.getPeer()?.setRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public transform(value: Object | undefined): this {
        if (this.checkPriority("transform")) {
            const value_casted = value as (Object | undefined)
            this.getPeer()?.setTransformAttribute(value_casted)
            return this
        }
        return this
    }
    public onAppear(value: (() => void) | undefined): this {
        if (this.checkPriority("onAppear")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onDisAppear(value: (() => void) | undefined): this {
        if (this.checkPriority("onDisAppear")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnDisAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onAttach(value: VoidCallback | undefined): this {
        if (this.checkPriority("onAttach")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnAttachAttribute(value_casted)
            return this
        }
        return this
    }
    public onDetach(value: VoidCallback | undefined): this {
        if (this.checkPriority("onDetach")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnDetachAttribute(value_casted)
            return this
        }
        return this
    }
    public onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        if (this.checkPriority("onAreaChange")) {
            const value_casted = value as (((oldValue: Area,newValue: Area) => void) | undefined)
            this.getPeer()?.setOnAreaChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public visibility(value: Visibility | undefined): this {
        if (this.checkPriority("visibility")) {
            const value_casted = value as (Visibility | undefined)
            this.getPeer()?.setVisibilityAttribute(value_casted)
            return this
        }
        return this
    }
    public flexGrow(value: number | undefined): this {
        if (this.checkPriority("flexGrow")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setFlexGrowAttribute(value_casted)
            return this
        }
        return this
    }
    public flexShrink(value: number | undefined): this {
        if (this.checkPriority("flexShrink")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setFlexShrinkAttribute(value_casted)
            return this
        }
        return this
    }
    public flexBasis(value: number | string | undefined): this {
        if (this.checkPriority("flexBasis")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setFlexBasisAttribute(value_casted)
            return this
        }
        return this
    }
    public alignSelf(value: ItemAlign | undefined): this {
        if (this.checkPriority("alignSelf")) {
            const value_casted = value as (ItemAlign | undefined)
            this.getPeer()?.setAlignSelfAttribute(value_casted)
            return this
        }
        return this
    }
    public displayPriority(value: number | undefined): this {
        if (this.checkPriority("displayPriority")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setDisplayPriorityAttribute(value_casted)
            return this
        }
        return this
    }
    public zIndex(value: number | undefined): this {
        if (this.checkPriority("zIndex")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setZIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public direction(value: Direction | undefined): this {
        if (this.checkPriority("direction")) {
            const value_casted = value as (Direction | undefined)
            this.getPeer()?.setDirectionAttribute(value_casted)
            return this
        }
        return this
    }
    public align(value: Alignment | undefined): this {
        if (this.checkPriority("align")) {
            const value_casted = value as (Alignment | undefined)
            this.getPeer()?.setAlignAttribute(value_casted)
            return this
        }
        return this
    }
    public position(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority("position")) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setPositionAttribute(value_casted)
            return this
        }
        return this
    }
    public markAnchor(value: Position | LocalizedPosition | undefined): this {
        if (this.checkPriority("markAnchor")) {
            const value_casted = value as (Position | LocalizedPosition | undefined)
            this.getPeer()?.setMarkAnchorAttribute(value_casted)
            return this
        }
        return this
    }
    public offset(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority("offset")) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public enabled(value: boolean | undefined): this {
        if (this.checkPriority("enabled")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnabledAttribute(value_casted)
            return this
        }
        return this
    }
    public alignRules(value: AlignRuleOption | undefined): this {
        if (this.checkPriority("alignRules")) {
            const value_casted = value as (AlignRuleOption | undefined)
            this.getPeer()?.setAlignRules0Attribute(value_casted)
            return this
        }
        return this
    }
    public alignRules(value: LocalizedAlignRuleOptions | undefined): this {
        if (this.checkPriority("alignRules")) {
            const value_casted = value as (LocalizedAlignRuleOptions | undefined)
            this.getPeer()?.setAlignRules1Attribute(value_casted)
            return this
        }
        return this
    }
    public aspectRatio(value: number | undefined): this {
        if (this.checkPriority("aspectRatio")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setAspectRatioAttribute(value_casted)
            return this
        }
        return this
    }
    public clickEffect(value: ClickEffect | undefined): this {
        if (this.checkPriority("clickEffect")) {
            const value_casted = value as (ClickEffect | undefined)
            this.getPeer()?.setClickEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        if (this.checkPriority("onDragStart")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined)
            this.getPeer()?.setOnDragStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragEnter")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEnterAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragMove")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragLeave")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragLeaveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDrop")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDrop0Attribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragEnd")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEndAttribute(value_casted)
            return this
        }
        return this
    }
    public allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | undefined): this {
        if (this.checkPriority("allowDrop")) {
            const value_casted = value as (Array<uniformTypeDescriptor.UniformDataType> | undefined)
            this.getPeer()?.setAllowDropAttribute(value_casted)
            return this
        }
        return this
    }
    public draggable(value: boolean | undefined): this {
        if (this.checkPriority("draggable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDraggableAttribute(value_casted)
            return this
        }
        return this
    }
    public dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        if (this.checkPriority("dragPreview")) {
            const value_casted = value as (CustomBuilder | DragItemInfo | string | undefined)
            this.getPeer()?.setDragPreview0Attribute(value_casted)
            return this
        }
        return this
    }
    public onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        if (this.checkPriority("onPreDrag")) {
            const value_casted = value as (((value0: PreDragStatus) => void) | undefined)
            this.getPeer()?.setOnPreDragAttribute(value_casted)
            return this
        }
        return this
    }
    public linearGradient(value: LinearGradientOptions | undefined): this {
        if (this.checkPriority("linearGradient")) {
            const value_casted = value as (LinearGradientOptions | undefined)
            this.getPeer()?.setLinearGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public sweepGradient(value: SweepGradientOptions | undefined): this {
        if (this.checkPriority("sweepGradient")) {
            const value_casted = value as (SweepGradientOptions | undefined)
            this.getPeer()?.setSweepGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public radialGradient(value: RadialGradientOptions | undefined): this {
        if (this.checkPriority("radialGradient")) {
            const value_casted = value as (RadialGradientOptions | undefined)
            this.getPeer()?.setRadialGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public motionPath(value: MotionPathOptions | undefined): this {
        if (this.checkPriority("motionPath")) {
            const value_casted = value as (MotionPathOptions | undefined)
            this.getPeer()?.setMotionPathAttribute(value_casted)
            return this
        }
        return this
    }
    public shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        if (this.checkPriority("shadow")) {
            const value_casted = value as (ShadowOptions | ShadowStyle | undefined)
            this.getPeer()?.setShadowAttribute(value_casted)
            return this
        }
        return this
    }
    public clip(value: boolean | undefined): this {
        if (this.checkPriority("clip")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setClipAttribute(value_casted)
            return this
        }
        return this
    }
    public clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority("clipShape")) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setClipShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public mask(value: ProgressMask | undefined): this {
        if (this.checkPriority("mask")) {
            const value_casted = value as (ProgressMask | undefined)
            this.getPeer()?.setMaskAttribute(value_casted)
            return this
        }
        return this
    }
    public maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority("maskShape")) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setMaskShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public key(value: string | undefined): this {
        if (this.checkPriority("key")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setKeyAttribute(value_casted)
            return this
        }
        return this
    }
    public id(value: string | undefined): this {
        if (this.checkPriority("id")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setIdAttribute(value_casted)
            return this
        }
        return this
    }
    public geometryTransition(value: string | undefined): this {
        if (this.checkPriority("geometryTransition")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setGeometryTransition0Attribute(value_casted)
            return this
        }
        return this
    }
    public stateStyles(value: StateStyles | undefined): this {
        if (this.checkPriority("stateStyles")) {
            const value_casted = value as (StateStyles | undefined)
            this.getPeer()?.setStateStylesAttribute(value_casted)
            return this
        }
        return this
    }
    public restoreId(value: number | undefined): this {
        if (this.checkPriority("restoreId")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setRestoreIdAttribute(value_casted)
            return this
        }
        return this
    }
    public sphericalEffect(value: number | undefined): this {
        if (this.checkPriority("sphericalEffect")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setSphericalEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public lightUpEffect(value: number | undefined): this {
        if (this.checkPriority("lightUpEffect")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setLightUpEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        if (this.checkPriority("pixelStretchEffect")) {
            const value_casted = value as (PixelStretchEffectOptions | undefined)
            this.getPeer()?.setPixelStretchEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityGroup(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityGroup")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityGroup0Attribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityText(value: string | undefined): this {
        if (this.checkPriority("accessibilityText")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityText0Attribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityNextFocusId(value: string | undefined): this {
        if (this.checkPriority("accessibilityNextFocusId")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityNextFocusIdAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityDefaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        if (this.checkPriority("accessibilityUseSamePage")) {
            const value_casted = value as (AccessibilitySamePageMode | undefined)
            this.getPeer()?.setAccessibilityUseSamePageAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityScrollTriggerable(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityScrollTriggerable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityScrollTriggerableAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityText(value: Resource | undefined): this {
        if (this.checkPriority("accessibilityText")) {
            const value_casted = value as (Resource | undefined)
            this.getPeer()?.setAccessibilityText1Attribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityRole(value: AccessibilityRoleType | undefined): this {
        if (this.checkPriority("accessibilityRole")) {
            const value_casted = value as (AccessibilityRoleType | undefined)
            this.getPeer()?.setAccessibilityRoleAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        if (this.checkPriority("onAccessibilityFocus")) {
            const value_casted = value as (AccessibilityFocusCallback | undefined)
            this.getPeer()?.setOnAccessibilityFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityTextHint(value: string | undefined): this {
        if (this.checkPriority("accessibilityTextHint")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityTextHintAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescription(value: string | undefined): this {
        if (this.checkPriority("accessibilityDescription")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityDescription0Attribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescription(value: Resource | undefined): this {
        if (this.checkPriority("accessibilityDescription")) {
            const value_casted = value as (Resource | undefined)
            this.getPeer()?.setAccessibilityDescription1Attribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityLevel(value: string | undefined): this {
        if (this.checkPriority("accessibilityLevel")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        if (this.checkPriority("accessibilityVirtualNode")) {
            const value_casted = value as (CustomBuilder | undefined)
            this.getPeer()?.setAccessibilityVirtualNodeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityChecked(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityChecked")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityCheckedAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilitySelected(value: boolean | undefined): this {
        if (this.checkPriority("accessibilitySelected")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilitySelectedAttribute(value_casted)
            return this
        }
        return this
    }
    public obscured(value: Array<ObscuredReasons> | undefined): this {
        if (this.checkPriority("obscured")) {
            const value_casted = value as (Array<ObscuredReasons> | undefined)
            this.getPeer()?.setObscuredAttribute(value_casted)
            return this
        }
        return this
    }
    public reuseId(value: string | undefined): this {
        if (this.checkPriority("reuseId")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setReuseIdAttribute(value_casted)
            return this
        }
        return this
    }
    public reuse(value: ReuseOptions | undefined): this {
        if (this.checkPriority("reuse")) {
            const value_casted = value as (ReuseOptions | undefined)
            this.getPeer()?.setReuseAttribute(value_casted)
            return this
        }
        return this
    }
    public renderFit(value: RenderFit | undefined): this {
        if (this.checkPriority("renderFit")) {
            const value_casted = value as (RenderFit | undefined)
            this.getPeer()?.setRenderFitAttribute(value_casted)
            return this
        }
        return this
    }
    public gestureModifier(value: GestureModifier | undefined): this {
        if (this.checkPriority("gestureModifier")) {
            const value_casted = value as (GestureModifier | undefined)
            this.getPeer()?.setGestureModifierAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        if (this.checkPriority("backgroundBrightness")) {
            const value_casted = value as (BackgroundBrightnessOptions | undefined)
            this.getPeer()?.setBackgroundBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        if (this.checkPriority("onGestureJudgeBegin")) {
            const value_casted = value as (((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined)
            this.getPeer()?.setOnGestureJudgeBeginAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        if (this.checkPriority("onGestureRecognizerJudgeBegin")) {
            const value_casted = value as (GestureRecognizerJudgeBeginCallback | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin0Attribute(value_casted)
            return this
        }
        return this
    }
    public shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        if (this.checkPriority("shouldBuiltInRecognizerParallelWith")) {
            const value_casted = value as (ShouldBuiltInRecognizerParallelWithCallback | undefined)
            this.getPeer()?.setShouldBuiltInRecognizerParallelWithAttribute(value_casted)
            return this
        }
        return this
    }
    public monopolizeEvents(value: boolean | undefined): this {
        if (this.checkPriority("monopolizeEvents")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setMonopolizeEventsAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        if (this.checkPriority("onTouchIntercept")) {
            const value_casted = value as (((value0: TouchEvent) => HitTestMode) | undefined)
            this.getPeer()?.setOnTouchInterceptAttribute(value_casted)
            return this
        }
        return this
    }
    public onSizeChange(value: SizeChangeCallback | undefined): this {
        if (this.checkPriority("onSizeChange")) {
            const value_casted = value as (SizeChangeCallback | undefined)
            this.getPeer()?.setOnSizeChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        if (this.checkPriority("accessibilityFocusDrawLevel")) {
            const value_casted = value as (FocusDrawLevel | undefined)
            this.getPeer()?.setAccessibilityFocusDrawLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public customProperty(name: string | undefined, value: Object | undefined): this {
        if (this.checkPriority("customProperty")) {
            const name_casted = name as (string | undefined)
            const value_casted = value as (Object | undefined)
            this.getPeer()?.setCustomPropertyAttribute(name_casted, value_casted)
            return this
        }
        return this
    }
    public expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        if (this.checkPriority("expandSafeArea")) {
            const types_casted = types as (Array<SafeAreaType> | undefined)
            const edges_casted = edges as (Array<SafeAreaEdge> | undefined)
            this.getPeer()?.setExpandSafeAreaAttribute(types_casted, edges_casted)
            return this
        }
        return this
    }
    public background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        if (this.checkPriority("background")) {
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (BackgroundOptions | undefined)
            this.getPeer()?.setBackgroundAttribute(builder_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): this {
        if (this.checkPriority("backgroundImage")) {
            const src_casted = src as (ResourceStr | image.PixelMap | undefined)
            const repeat_casted = repeat as (ImageRepeat | undefined)
            this.getPeer()?.setBackgroundImage0Attribute(src_casted, repeat_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): this {
        if (this.checkPriority("backgroundImage")) {
            const src_casted = src as (ResourceStr | image.PixelMap | undefined)
            const options_casted = options as (BackgroundImageOptions | undefined)
            this.getPeer()?.setBackgroundImage1Attribute(src_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backgroundBlurStyle")) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (BackgroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backgroundEffect")) {
            const options_casted = options as (BackgroundEffectOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundEffect1Attribute(options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("foregroundBlurStyle")) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (ForegroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setForegroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: number | undefined): this {
        if (this.checkPriority("onClick")) {
            const event_casted = event as (((event: ClickEvent) => void) | undefined)
            const distanceThreshold_casted = distanceThreshold as (number | undefined)
            this.getPeer()?.setOnClick1Attribute(event_casted, distanceThreshold_casted)
            return this
        }
        return this
    }
    public focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        if (this.checkPriority("focusScopeId")) {
            const id_casted = id as (string | undefined)
            const isGroup_casted = isGroup as (boolean | undefined)
            const arrowStepOut_casted = arrowStepOut as (boolean | undefined)
            this.getPeer()?.setFocusScopeIdAttribute(id_casted, isGroup_casted, arrowStepOut_casted)
            return this
        }
        return this
    }
    public focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        if (this.checkPriority("focusScopePriority")) {
            const scopeId_casted = scopeId as (string | undefined)
            const priority_casted = priority as (FocusPriority | undefined)
            this.getPeer()?.setFocusScopePriorityAttribute(scopeId_casted, priority_casted)
            return this
        }
        return this
    }
    public transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        if (this.checkPriority("transition")) {
            const effect_casted = effect as (TransitionEffect | undefined)
            const onFinish_casted = onFinish as (TransitionFinishCallback | undefined)
            this.getPeer()?.setTransition1Attribute(effect_casted, onFinish_casted)
            return this
        }
        return this
    }
    public gesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        if (this.checkPriority("gesture")) {
            const gesture_casted = gesture as (GestureType | undefined)
            const mask_casted = mask as (GestureMask | undefined)
            this.getPeer()?.setGestureAttribute(gesture_casted, mask_casted)
            return this
        }
        return this
    }
    public priorityGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        if (this.checkPriority("priorityGesture")) {
            const gesture_casted = gesture as (GestureType | undefined)
            const mask_casted = mask as (GestureMask | undefined)
            this.getPeer()?.setPriorityGestureAttribute(gesture_casted, mask_casted)
            return this
        }
        return this
    }
    public parallelGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        if (this.checkPriority("parallelGesture")) {
            const gesture_casted = gesture as (GestureType | undefined)
            const mask_casted = mask as (GestureMask | undefined)
            this.getPeer()?.setParallelGestureAttribute(gesture_casted, mask_casted)
            return this
        }
        return this
    }
    public blur(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("blur")) {
            const blurRadius_casted = blurRadius as (number | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBlurAttribute(blurRadius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public linearGradientBlur(value: number | undefined, options: LinearGradientBlurOptions | undefined): this {
        if (this.checkPriority("linearGradientBlur")) {
            const value_casted = value as (number | undefined)
            const options_casted = options as (LinearGradientBlurOptions | undefined)
            this.getPeer()?.setLinearGradientBlurAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public systemBarEffect(): this {
        if (this.checkPriority("systemBarEffect")) {
            this.getPeer()?.setSystemBarEffectAttribute()
            return this
        }
        return this
    }
    public useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        if (this.checkPriority("useEffect")) {
            const useEffect_casted = useEffect as (boolean | undefined)
            const effectType_casted = effectType as (EffectType | undefined)
            this.getPeer()?.setUseEffect1Attribute(useEffect_casted, effectType_casted)
            return this
        }
        return this
    }
    public backdropBlur(radius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backdropBlur")) {
            const radius_casted = radius as (number | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackdropBlurAttribute(radius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        if (this.checkPriority("sharedTransition")) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (sharedTransitionOptions | undefined)
            this.getPeer()?.setSharedTransitionAttribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        if (this.checkPriority("chainMode")) {
            const direction_casted = direction as (Axis | undefined)
            const style_casted = style as (ChainStyle | undefined)
            this.getPeer()?.setChainModeAttribute(direction_casted, style_casted)
            return this
        }
        return this
    }
    public onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        if (this.checkPriority("onDrop")) {
            const eventCallback_casted = eventCallback as (OnDragEventCallback | undefined)
            const dropOptions_casted = dropOptions as (DropOptions | undefined)
            this.getPeer()?.setOnDrop1Attribute(eventCallback_casted, dropOptions_casted)
            return this
        }
        return this
    }
    public dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        if (this.checkPriority("dragPreview")) {
            const preview_casted = preview as (CustomBuilder | DragItemInfo | string | undefined)
            const config_casted = config as (PreviewConfiguration | undefined)
            this.getPeer()?.setDragPreview1Attribute(preview_casted, config_casted)
            return this
        }
        return this
    }
    public dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        if (this.checkPriority("dragPreviewOptions")) {
            const value_casted = value as (DragPreviewOptions | undefined)
            const options_casted = options as (DragInteractionOptions | undefined)
            this.getPeer()?.setDragPreviewOptionsAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        if (this.checkPriority("overlay")) {
            const value_casted = value as (string | CustomBuilder | ComponentContent | undefined)
            const options_casted = options as (OverlayOptions | undefined)
            this.getPeer()?.setOverlayAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        if (this.checkPriority("blendMode")) {
            const value_casted = value as (BlendMode | undefined)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setBlendModeAttribute(value_casted, type_casted)
            return this
        }
        return this
    }
    public advancedBlendMode(effect: BlendMode | uiEffect.Blender | undefined, type?: BlendApplyType): this {
        if (this.checkPriority("advancedBlendMode")) {
            const effect_casted = effect as (BlendMode | uiEffect.Blender | undefined)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setAdvancedBlendModeAttribute(effect_casted, type_casted)
            return this
        }
        return this
    }
    public geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        if (this.checkPriority("geometryTransition")) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (GeometryTransitionOptions | undefined)
            this.getPeer()?.setGeometryTransition1Attribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        if (this.checkPriority("bindTips")) {
            const message_casted = message as (TipsMessageType | undefined)
            const options_casted = options as (TipsOptions | undefined)
            this.getPeer()?.setBindTipsAttribute(message_casted, options_casted)
            return this
        }
        return this
    }
    public bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        if (this.checkPriority("bindPopup")) {
            const show_casted = show as (boolean | undefined)
            const popup_casted = popup as (PopupOptions | CustomPopupOptions | undefined)
            this.getPeer()?.setBindPopupAttribute(show_casted, popup_casted)
            return this
        }
        return this
    }
    public bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority("bindMenu")) {
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu0Attribute(content_casted, options_casted)
            return this
        }
        return this
    }
    public bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority("bindMenu")) {
            const isShow_casted = isShow as (boolean | undefined)
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu1Attribute(isShow_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority("bindContextMenu")) {
            const content_casted = content as (CustomBuilder | undefined)
            const responseType_casted = responseType as (ResponseType | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu0Attribute(content_casted, responseType_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority("bindContextMenu")) {
            const isShown_casted = isShown as (boolean | undefined)
            const content_casted = content as (CustomBuilder | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu1Attribute(isShown_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        if (this.checkPriority("bindContentCover")) {
            const isShow_casted = isShow as (boolean | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const type_casted = type as (ModalTransition | undefined)
            this.getPeer()?.setBindContentCover0Attribute(isShow_casted, builder_casted, type_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        if (this.checkPriority("bindContentCover")) {
            const isShow_casted = isShow as (boolean | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (ContentCoverOptions | undefined)
            this.getPeer()?.setBindContentCover1Attribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public bindSheet(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        if (this.checkPriority("bindSheet")) {
            const isShow_casted = isShow as (boolean | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (SheetOptions | undefined)
            this.getPeer()?.setBindSheetAttribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public onVisibleAreaChange(ratios: Array<number> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority("onVisibleAreaChange")) {
            const ratios_casted = ratios as (Array<number> | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaChangeAttribute(ratios_casted, event_casted)
            return this
        }
        return this
    }
    public onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority("onVisibleAreaApproximateChange")) {
            const options_casted = options as (VisibleAreaEventOptions | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaApproximateChangeAttribute(options_casted, event_casted)
            return this
        }
        return this
    }
    public keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        if (this.checkPriority("keyboardShortcut")) {
            const value_casted = value as (string | FunctionKey | undefined)
            const keys_casted = keys as (Array<ModifierKey> | undefined)
            const action_casted = action as ((() => void) | undefined)
            this.getPeer()?.setKeyboardShortcutAttribute(value_casted, keys_casted, action_casted)
            return this
        }
        return this
    }
    public accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions: AccessibilityOptions | undefined): this {
        if (this.checkPriority("accessibilityGroup")) {
            const isGroup_casted = isGroup as (boolean | undefined)
            const accessibilityOptions_casted = accessibilityOptions as (AccessibilityOptions | undefined)
            this.getPeer()?.setAccessibilityGroup1Attribute(isGroup_casted, accessibilityOptions_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        if (this.checkPriority("onGestureRecognizerJudgeBegin")) {
            const callback__casted = callback_ as (GestureRecognizerJudgeBeginCallback | undefined)
            const exposeInnerGesture_casted = exposeInnerGesture as (boolean | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin1Attribute(callback__casted, exposeInnerGesture_casted)
            return this
        }
        return this
    }
    _modifier?: AttributeModifier<CommonMethod> | undefined
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        this._modifier = value
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
}
export function withCommonMethodStyle(receiver: CommonMethod, modifier: AttributeModifier<CommonMethod> | undefined): void {
    if (modifier !== undefined)
    {
        let style  = new ArkCommonMethodStyle()
        if (modifier!.isUpdater())
            (modifier! as AttributeUpdater<CommonMethod>).initializeModifier(style)
        else
            (modifier! as AttributeModifier<CommonMethod>).applyNormalAttribute(style)
        style.apply(receiver)
    }
}
export class ArkCommonShapeMethodComponent extends ArkCommonMethodComponent implements CommonShapeMethod {
    getPeer(): ArkCommonShapeMethodPeer {
        return (this.peer as ArkCommonShapeMethodPeer)
    }
    public stroke(value: ResourceColor | undefined): this {
        if (this.checkPriority("stroke")) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setStrokeAttribute(value_casted)
            return this
        }
        return this
    }
    public fill(value: ResourceColor | undefined): this {
        if (this.checkPriority("fill")) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setFillAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashOffset(value: number | string | undefined): this {
        if (this.checkPriority("strokeDashOffset")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setStrokeDashOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineCap(value: LineCapStyle | undefined): this {
        if (this.checkPriority("strokeLineCap")) {
            const value_casted = value as (LineCapStyle | undefined)
            this.getPeer()?.setStrokeLineCapAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineJoin(value: LineJoinStyle | undefined): this {
        if (this.checkPriority("strokeLineJoin")) {
            const value_casted = value as (LineJoinStyle | undefined)
            this.getPeer()?.setStrokeLineJoinAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeMiterLimit(value: number | string | undefined): this {
        if (this.checkPriority("strokeMiterLimit")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setStrokeMiterLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeOpacity(value: number | string | Resource | undefined): this {
        if (this.checkPriority("strokeOpacity")) {
            const value_casted = value as (number | string | Resource | undefined)
            this.getPeer()?.setStrokeOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public fillOpacity(value: number | string | Resource | undefined): this {
        if (this.checkPriority("fillOpacity")) {
            const value_casted = value as (number | string | Resource | undefined)
            this.getPeer()?.setFillOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeWidth(value: Length | undefined): this {
        if (this.checkPriority("strokeWidth")) {
            const value_casted = value as (Length | undefined)
            this.getPeer()?.setStrokeWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public antiAlias(value: boolean | undefined): this {
        if (this.checkPriority("antiAlias")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAntiAliasAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashArray(value: Array<Length> | undefined): this {
        if (this.checkPriority("strokeDashArray")) {
            const value_casted = value as (Array<Length> | undefined)
            this.getPeer()?.setStrokeDashArrayAttribute(value_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        this._modifier = value as AttributeModifier<CommonMethod>
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
}
export function withCommonShapeMethodStyle(receiver: CommonShapeMethod, modifier: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): void {
    if (modifier !== undefined)
    {
        let style  = new ArkCommonShapeMethodStyle()
        if (modifier!.isUpdater())
            (modifier! as AttributeUpdater<CommonMethod>).initializeModifier(style)
        else
            (modifier! as AttributeModifier<CommonMethod>).applyNormalAttribute(style)
        style.apply(receiver)
    }
}
export class ArkScrollableCommonMethodComponent extends ArkCommonMethodComponent implements ScrollableCommonMethod {
    getPeer(): ArkScrollableCommonMethodPeer {
        return (this.peer as ArkScrollableCommonMethodPeer)
    }
    public scrollBar(value: BarState | undefined): this {
        if (this.checkPriority("scrollBar")) {
            const value_casted = value as (BarState | undefined)
            this.getPeer()?.setScrollBarAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarColor(value: Color | number | string | undefined): this {
        if (this.checkPriority("scrollBarColor")) {
            const value_casted = value as (Color | number | string | undefined)
            this.getPeer()?.setScrollBarColorAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarWidth(value: number | string | undefined): this {
        if (this.checkPriority("scrollBarWidth")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setScrollBarWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        if (this.checkPriority("nestedScroll")) {
            const value_casted = value as (NestedScrollOptions | undefined)
            this.getPeer()?.setNestedScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        if (this.checkPriority("enableScrollInteraction")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnableScrollInteractionAttribute(value_casted)
            return this
        }
        return this
    }
    public friction(value: number | Resource | undefined): this {
        if (this.checkPriority("friction")) {
            const value_casted = value as (number | Resource | undefined)
            this.getPeer()?.setFrictionAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachStart(value: (() => void) | undefined): this {
        if (this.checkPriority("onReachStart")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachEnd(value: (() => void) | undefined): this {
        if (this.checkPriority("onReachEnd")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachEndAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStart(value: (() => void) | undefined): this {
        if (this.checkPriority("onScrollStart")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStop(value: (() => void) | undefined): this {
        if (this.checkPriority("onScrollStop")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStopAttribute(value_casted)
            return this
        }
        return this
    }
    public flingSpeedLimit(value: number | undefined): this {
        if (this.checkPriority("flingSpeedLimit")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setFlingSpeedLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public clipContent(value: ContentClipMode | RectShape | undefined): this {
        if (this.checkPriority("clipContent")) {
            const value_casted = value as (ContentClipMode | RectShape | undefined)
            this.getPeer()?.setClipContentAttribute(value_casted)
            return this
        }
        return this
    }
    public digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        if (this.checkPriority("digitalCrownSensitivity")) {
            const value_casted = value as (CrownSensitivity | undefined)
            this.getPeer()?.setDigitalCrownSensitivityAttribute(value_casted)
            return this
        }
        return this
    }
    public backToTop(value: boolean | undefined): this {
        if (this.checkPriority("backToTop")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setBackToTopAttribute(value_casted)
            return this
        }
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        if (this.checkPriority("edgeEffect")) {
            const edgeEffect_casted = edgeEffect as (EdgeEffect | undefined)
            const options_casted = options as (EdgeEffectOptions | undefined)
            this.getPeer()?.setEdgeEffectAttribute(edgeEffect_casted, options_casted)
            return this
        }
        return this
    }
    public fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        if (this.checkPriority("fadingEdge")) {
            const enabled_casted = enabled as (boolean | undefined)
            const options_casted = options as (FadingEdgeOptions | undefined)
            this.getPeer()?.setFadingEdgeAttribute(enabled_casted, options_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        this._modifier = value as AttributeModifier<CommonMethod>
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
}
export function withScrollableCommonMethodStyle(receiver: ScrollableCommonMethod, modifier: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): void {
    if (modifier !== undefined)
    {
        let style  = new ArkScrollableCommonMethodStyle()
        if (modifier!.isUpdater())
            (modifier! as AttributeUpdater<CommonMethod>).initializeModifier(style)
        else
            (modifier! as AttributeModifier<CommonMethod>).applyNormalAttribute(style)
        style.apply(receiver)
    }
}
export class ArkCommonMethodSet implements CommonMethod {
    _instanceId: number = -1;
    setInstanceId(instanceId: number): void {
        this._instanceId = instanceId
    }
    _width_flag?: boolean
    _width0_value?: Length | LayoutPolicy | undefined
    _height_flag?: boolean
    _height0_value?: Length | LayoutPolicy | undefined
    _drawModifier_flag?: boolean
    _drawModifier0_value?: DrawModifier | undefined
    _responseRegion_flag?: boolean
    _responseRegion0_value?: Array<Rectangle> | Rectangle | undefined
    _mouseResponseRegion_flag?: boolean
    _mouseResponseRegion0_value?: Array<Rectangle> | Rectangle | undefined
    _size_flag?: boolean
    _size0_value?: SizeOptions | undefined
    _constraintSize_flag?: boolean
    _constraintSize0_value?: ConstraintSizeOptions | undefined
    _hitTestBehavior_flag?: boolean
    _hitTestBehavior0_value?: HitTestMode | undefined
    _onChildTouchTest_flag?: boolean
    _onChildTouchTest0_value?: ((value: Array<TouchTestInfo>) => TouchResult) | undefined
    _layoutWeight_flag?: boolean
    _layoutWeight0_value?: number | string | undefined
    _chainWeight_flag?: boolean
    _chainWeight0_value?: ChainWeightOptions | undefined
    _padding_flag?: boolean
    _padding0_value?: Padding | Length | LocalizedPadding | undefined
    _safeAreaPadding_flag?: boolean
    _safeAreaPadding0_value?: Padding | LengthMetrics | LocalizedPadding | undefined
    _margin_flag?: boolean
    _margin0_value?: Padding | Length | LocalizedPadding | undefined
    _backgroundColor_flag?: boolean
    _backgroundColor0_value?: ResourceColor | undefined
    _pixelRound_flag?: boolean
    _pixelRound0_value?: PixelRoundPolicy | undefined
    _backgroundImageSize_flag?: boolean
    _backgroundImageSize0_value?: SizeOptions | ImageSize | undefined
    _backgroundImagePosition_flag?: boolean
    _backgroundImagePosition0_value?: Position | Alignment | undefined
    _backgroundEffect_flag?: boolean
    _backgroundEffect0_value?: BackgroundEffectOptions | undefined
    _backgroundEffect1_value?: SystemAdaptiveOptions | undefined
    _backgroundImageResizable_flag?: boolean
    _backgroundImageResizable0_value?: ResizableOptions | undefined
    _foregroundEffect_flag?: boolean
    _foregroundEffect0_value?: ForegroundEffectOptions | undefined
    _visualEffect_flag?: boolean
    _visualEffect0_value?: uiEffect.VisualEffect | undefined
    _backgroundFilter_flag?: boolean
    _backgroundFilter0_value?: uiEffect.Filter | undefined
    _foregroundFilter_flag?: boolean
    _foregroundFilter0_value?: uiEffect.Filter | undefined
    _compositingFilter_flag?: boolean
    _compositingFilter0_value?: uiEffect.Filter | undefined
    _opacity_flag?: boolean
    _opacity0_value?: number | Resource | undefined
    _border_flag?: boolean
    _border0_value?: BorderOptions | undefined
    _borderStyle_flag?: boolean
    _borderStyle0_value?: BorderStyle | EdgeStyles | undefined
    _borderWidth_flag?: boolean
    _borderWidth0_value?: Length | EdgeWidths | LocalizedEdgeWidths | undefined
    _borderColor_flag?: boolean
    _borderColor0_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    _borderRadius_flag?: boolean
    _borderRadius0_value?: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
    _borderImage_flag?: boolean
    _borderImage0_value?: BorderImageOption | undefined
    _outline_flag?: boolean
    _outline0_value?: OutlineOptions | undefined
    _outlineStyle_flag?: boolean
    _outlineStyle0_value?: OutlineStyle | EdgeOutlineStyles | undefined
    _outlineWidth_flag?: boolean
    _outlineWidth0_value?: Dimension | EdgeOutlineWidths | undefined
    _outlineColor_flag?: boolean
    _outlineColor0_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    _outlineRadius_flag?: boolean
    _outlineRadius0_value?: Dimension | OutlineRadiuses | undefined
    _foregroundColor_flag?: boolean
    _foregroundColor0_value?: ResourceColor | ColoringStrategy | undefined
    _onClick_flag?: boolean
    _onClick0_value?: ((event: ClickEvent) => void) | undefined
    _onClick1_value?: number | undefined
    _onHover_flag?: boolean
    _onHover0_value?: ((isHover: boolean,event: HoverEvent) => void) | undefined
    _onHoverMove_flag?: boolean
    _onHoverMove0_value?: ((value0: HoverEvent) => void) | undefined
    _onAccessibilityHover_flag?: boolean
    _onAccessibilityHover0_value?: AccessibilityCallback | undefined
    _hoverEffect_flag?: boolean
    _hoverEffect0_value?: HoverEffect | undefined
    _onMouse_flag?: boolean
    _onMouse0_value?: ((event: MouseEvent) => void) | undefined
    _onTouch_flag?: boolean
    _onTouch0_value?: ((event: TouchEvent) => void) | undefined
    _onKeyEvent_flag?: boolean
    _onKeyEvent0_value?: ((event: KeyEvent) => void) | undefined
    _onDigitalCrown_flag?: boolean
    _onDigitalCrown0_value?: ((value0: CrownEvent) => void) | undefined
    _onKeyPreIme_flag?: boolean
    _onKeyPreIme0_value?: ((value0: KeyEvent) => boolean) | undefined
    _onKeyEventDispatch_flag?: boolean
    _onKeyEventDispatch0_value?: ((value0: KeyEvent) => boolean) | undefined
    _onFocusAxisEvent_flag?: boolean
    _onFocusAxisEvent0_value?: ((value0: FocusAxisEvent) => void) | undefined
    _onAxisEvent_flag?: boolean
    _onAxisEvent0_value?: ((value0: AxisEvent) => void) | undefined
    _focusable_flag?: boolean
    _focusable0_value?: boolean | undefined
    _nextFocus_flag?: boolean
    _nextFocus0_value?: FocusMovement | undefined
    _tabStop_flag?: boolean
    _tabStop0_value?: boolean | undefined
    _onFocus_flag?: boolean
    _onFocus0_value?: (() => void) | undefined
    _onBlur_flag?: boolean
    _onBlur0_value?: (() => void) | undefined
    _tabIndex_flag?: boolean
    _tabIndex0_value?: number | undefined
    _defaultFocus_flag?: boolean
    _defaultFocus0_value?: boolean | undefined
    _groupDefaultFocus_flag?: boolean
    _groupDefaultFocus0_value?: boolean | undefined
    _focusOnTouch_flag?: boolean
    _focusOnTouch0_value?: boolean | undefined
    _focusBox_flag?: boolean
    _focusBox0_value?: FocusBoxStyle | undefined
    _animation_flag?: boolean
    _animation0_value?: AnimateParam | undefined
    _transition_flag?: boolean
    _transition0_value?: TransitionEffect | undefined
    _transition1_value?: TransitionFinishCallback | undefined
    _motionBlur_flag?: boolean
    _motionBlur0_value?: MotionBlurOptions | undefined
    _brightness_flag?: boolean
    _brightness0_value?: number | undefined
    _contrast_flag?: boolean
    _contrast0_value?: number | undefined
    _grayscale_flag?: boolean
    _grayscale0_value?: number | undefined
    _colorBlend_flag?: boolean
    _colorBlend0_value?: Color | string | Resource | undefined
    _saturate_flag?: boolean
    _saturate0_value?: number | undefined
    _sepia_flag?: boolean
    _sepia0_value?: number | undefined
    _invert_flag?: boolean
    _invert0_value?: number | InvertOptions | undefined
    _hueRotate_flag?: boolean
    _hueRotate0_value?: number | string | undefined
    _useShadowBatching_flag?: boolean
    _useShadowBatching0_value?: boolean | undefined
    _useEffect_flag?: boolean
    _useEffect0_value?: boolean | undefined
    _useEffect1_value?: EffectType | undefined
    _renderGroup_flag?: boolean
    _renderGroup0_value?: boolean | undefined
    _freeze_flag?: boolean
    _freeze0_value?: boolean | undefined
    _translate_flag?: boolean
    _translate0_value?: TranslateOptions | undefined
    _scale_flag?: boolean
    _scale0_value?: ScaleOptions | undefined
    _rotate_flag?: boolean
    _rotate0_value?: RotateOptions | undefined
    _transform_flag?: boolean
    _transform0_value?: Object | undefined
    _onAppear_flag?: boolean
    _onAppear0_value?: (() => void) | undefined
    _onDisAppear_flag?: boolean
    _onDisAppear0_value?: (() => void) | undefined
    _onAttach_flag?: boolean
    _onAttach0_value?: VoidCallback | undefined
    _onDetach_flag?: boolean
    _onDetach0_value?: VoidCallback | undefined
    _onAreaChange_flag?: boolean
    _onAreaChange0_value?: ((oldValue: Area,newValue: Area) => void) | undefined
    _visibility_flag?: boolean
    _visibility0_value?: Visibility | undefined
    _flexGrow_flag?: boolean
    _flexGrow0_value?: number | undefined
    _flexShrink_flag?: boolean
    _flexShrink0_value?: number | undefined
    _flexBasis_flag?: boolean
    _flexBasis0_value?: number | string | undefined
    _alignSelf_flag?: boolean
    _alignSelf0_value?: ItemAlign | undefined
    _displayPriority_flag?: boolean
    _displayPriority0_value?: number | undefined
    _zIndex_flag?: boolean
    _zIndex0_value?: number | undefined
    _direction_flag?: boolean
    _direction0_value?: Direction | undefined
    _align_flag?: boolean
    _align0_value?: Alignment | undefined
    _position_flag?: boolean
    _position0_value?: Position | Edges | LocalizedEdges | undefined
    _markAnchor_flag?: boolean
    _markAnchor0_value?: Position | LocalizedPosition | undefined
    _offset_flag?: boolean
    _offset0_value?: Position | Edges | LocalizedEdges | undefined
    _enabled_flag?: boolean
    _enabled0_value?: boolean | undefined
    _alignRules_flag?: boolean
    _alignRules0_value?: LocalizedAlignRuleOptions | undefined
    _aspectRatio_flag?: boolean
    _aspectRatio0_value?: number | undefined
    _clickEffect_flag?: boolean
    _clickEffect0_value?: ClickEffect | undefined
    _onDragStart_flag?: boolean
    _onDragStart0_value?: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined
    _onDragEnter_flag?: boolean
    _onDragEnter0_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    _onDragMove_flag?: boolean
    _onDragMove0_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    _onDragLeave_flag?: boolean
    _onDragLeave0_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    _onDrop_flag?: boolean
    _onDrop0_value?: OnDragEventCallback | undefined
    _onDrop1_value?: DropOptions | undefined
    _onDragEnd_flag?: boolean
    _onDragEnd0_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    _allowDrop_flag?: boolean
    _allowDrop0_value?: Array<uniformTypeDescriptor.UniformDataType> | undefined
    _draggable_flag?: boolean
    _draggable0_value?: boolean | undefined
    _dragPreview_flag?: boolean
    _dragPreview0_value?: CustomBuilder | DragItemInfo | string | undefined
    _dragPreview1_value?: PreviewConfiguration | undefined
    _onPreDrag_flag?: boolean
    _onPreDrag0_value?: ((value0: PreDragStatus) => void) | undefined
    _linearGradient_flag?: boolean
    _linearGradient0_value?: LinearGradientOptions | undefined
    _sweepGradient_flag?: boolean
    _sweepGradient0_value?: SweepGradientOptions | undefined
    _radialGradient_flag?: boolean
    _radialGradient0_value?: RadialGradientOptions | undefined
    _motionPath_flag?: boolean
    _motionPath0_value?: MotionPathOptions | undefined
    _shadow_flag?: boolean
    _shadow0_value?: ShadowOptions | ShadowStyle | undefined
    _clip_flag?: boolean
    _clip0_value?: boolean | undefined
    _clipShape_flag?: boolean
    _clipShape0_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    _mask_flag?: boolean
    _mask0_value?: ProgressMask | undefined
    _maskShape_flag?: boolean
    _maskShape0_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    _key_flag?: boolean
    _key0_value?: string | undefined
    _id_flag?: boolean
    _id0_value?: string | undefined
    _geometryTransition_flag?: boolean
    _geometryTransition0_value?: string | undefined
    _geometryTransition1_value?: GeometryTransitionOptions | undefined
    _stateStyles_flag?: boolean
    _stateStyles0_value?: StateStyles | undefined
    _restoreId_flag?: boolean
    _restoreId0_value?: number | undefined
    _sphericalEffect_flag?: boolean
    _sphericalEffect0_value?: number | undefined
    _lightUpEffect_flag?: boolean
    _lightUpEffect0_value?: number | undefined
    _pixelStretchEffect_flag?: boolean
    _pixelStretchEffect0_value?: PixelStretchEffectOptions | undefined
    _accessibilityGroup_flag?: boolean
    _accessibilityGroup0_value?: boolean | undefined
    _accessibilityGroup1_value?: AccessibilityOptions | undefined
    _accessibilityText_flag?: boolean
    _accessibilityText0_value?: Resource | undefined
    _accessibilityNextFocusId_flag?: boolean
    _accessibilityNextFocusId0_value?: string | undefined
    _accessibilityDefaultFocus_flag?: boolean
    _accessibilityDefaultFocus0_value?: boolean | undefined
    _accessibilityUseSamePage_flag?: boolean
    _accessibilityUseSamePage0_value?: AccessibilitySamePageMode | undefined
    _accessibilityScrollTriggerable_flag?: boolean
    _accessibilityScrollTriggerable0_value?: boolean | undefined
    _accessibilityRole_flag?: boolean
    _accessibilityRole0_value?: AccessibilityRoleType | undefined
    _onAccessibilityFocus_flag?: boolean
    _onAccessibilityFocus0_value?: AccessibilityFocusCallback | undefined
    _accessibilityTextHint_flag?: boolean
    _accessibilityTextHint0_value?: string | undefined
    _accessibilityDescription_flag?: boolean
    _accessibilityDescription0_value?: Resource | undefined
    _accessibilityLevel_flag?: boolean
    _accessibilityLevel0_value?: string | undefined
    _accessibilityVirtualNode_flag?: boolean
    _accessibilityVirtualNode0_value?: CustomBuilder | undefined
    _accessibilityChecked_flag?: boolean
    _accessibilityChecked0_value?: boolean | undefined
    _accessibilitySelected_flag?: boolean
    _accessibilitySelected0_value?: boolean | undefined
    _obscured_flag?: boolean
    _obscured0_value?: Array<ObscuredReasons> | undefined
    _reuseId_flag?: boolean
    _reuseId0_value?: string | undefined
    _reuse_flag?: boolean
    _reuse0_value?: ReuseOptions | undefined
    _renderFit_flag?: boolean
    _renderFit0_value?: RenderFit | undefined
    _gestureModifier_flag?: boolean
    _gestureModifier0_value?: GestureModifier | undefined
    _backgroundBrightness_flag?: boolean
    _backgroundBrightness0_value?: BackgroundBrightnessOptions | undefined
    _onGestureJudgeBegin_flag?: boolean
    _onGestureJudgeBegin0_value?: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined
    _onGestureRecognizerJudgeBegin_flag?: boolean
    _onGestureRecognizerJudgeBegin0_value?: GestureRecognizerJudgeBeginCallback | undefined
    _onGestureRecognizerJudgeBegin1_value?: boolean | undefined
    _shouldBuiltInRecognizerParallelWith_flag?: boolean
    _shouldBuiltInRecognizerParallelWith0_value?: ShouldBuiltInRecognizerParallelWithCallback | undefined
    _monopolizeEvents_flag?: boolean
    _monopolizeEvents0_value?: boolean | undefined
    _onTouchIntercept_flag?: boolean
    _onTouchIntercept0_value?: ((value0: TouchEvent) => HitTestMode) | undefined
    _onSizeChange_flag?: boolean
    _onSizeChange0_value?: SizeChangeCallback | undefined
    _accessibilityFocusDrawLevel_flag?: boolean
    _accessibilityFocusDrawLevel0_value?: FocusDrawLevel | undefined
    _customProperty_flag?: boolean
    _customProperty0_value?: string | undefined
    _customProperty1_value?: Object | undefined
    _expandSafeArea_flag?: boolean
    _expandSafeArea0_value?: Array<SafeAreaType> | undefined
    _expandSafeArea1_value?: Array<SafeAreaEdge> | undefined
    _background_flag?: boolean
    _background0_value?: CustomBuilder | undefined
    _background1_value?: BackgroundOptions | undefined
    _backgroundImage_flag?: boolean
    _backgroundImage0_value?: ResourceStr | image.PixelMap | undefined
    _backgroundImage1_value?: BackgroundImageOptions | undefined
    _backgroundBlurStyle_flag?: boolean
    _backgroundBlurStyle0_value?: BlurStyle | undefined
    _backgroundBlurStyle1_value?: BackgroundBlurStyleOptions | undefined
    _backgroundBlurStyle2_value?: SystemAdaptiveOptions | undefined
    _foregroundBlurStyle_flag?: boolean
    _foregroundBlurStyle0_value?: BlurStyle | undefined
    _foregroundBlurStyle1_value?: ForegroundBlurStyleOptions | undefined
    _foregroundBlurStyle2_value?: SystemAdaptiveOptions | undefined
    _focusScopeId_flag?: boolean
    _focusScopeId0_value?: string | undefined
    _focusScopeId1_value?: boolean | undefined
    _focusScopeId2_value?: boolean | undefined
    _focusScopePriority_flag?: boolean
    _focusScopePriority0_value?: string | undefined
    _focusScopePriority1_value?: FocusPriority | undefined
    _gesture_flag?: boolean
    _gesture0_value?: GestureType | undefined
    _gesture1_value?: GestureMask | undefined
    _priorityGesture_flag?: boolean
    _priorityGesture0_value?: GestureType | undefined
    _priorityGesture1_value?: GestureMask | undefined
    _parallelGesture_flag?: boolean
    _parallelGesture0_value?: GestureType | undefined
    _parallelGesture1_value?: GestureMask | undefined
    _blur_flag?: boolean
    _blur0_value?: number | undefined
    _blur1_value?: BlurOptions | undefined
    _blur2_value?: SystemAdaptiveOptions | undefined
    _linearGradientBlur_flag?: boolean
    _linearGradientBlur0_value?: number | undefined
    _linearGradientBlur1_value?: LinearGradientBlurOptions | undefined
    _systemBarEffect_flag?: boolean
    _backdropBlur_flag?: boolean
    _backdropBlur0_value?: number | undefined
    _backdropBlur1_value?: BlurOptions | undefined
    _backdropBlur2_value?: SystemAdaptiveOptions | undefined
    _sharedTransition_flag?: boolean
    _sharedTransition0_value?: string | undefined
    _sharedTransition1_value?: sharedTransitionOptions | undefined
    _chainMode_flag?: boolean
    _chainMode0_value?: Axis | undefined
    _chainMode1_value?: ChainStyle | undefined
    _dragPreviewOptions_flag?: boolean
    _dragPreviewOptions0_value?: DragPreviewOptions | undefined
    _dragPreviewOptions1_value?: DragInteractionOptions | undefined
    _overlay_flag?: boolean
    _overlay0_value?: string | CustomBuilder | ComponentContent | undefined
    _overlay1_value?: OverlayOptions | undefined
    _blendMode_flag?: boolean
    _blendMode0_value?: BlendMode | undefined
    _blendMode1_value?: BlendApplyType | undefined
    _advancedBlendMode_flag?: boolean
    _advancedBlendMode0_value?: BlendMode | uiEffect.Blender | undefined
    _advancedBlendMode1_value?: BlendApplyType | undefined
    _bindTips_flag?: boolean
    _bindTips0_value?: TipsMessageType | undefined
    _bindTips1_value?: TipsOptions | undefined
    _bindPopup_flag?: boolean
    _bindPopup0_value?: boolean | undefined
    _bindPopup1_value?: PopupOptions | CustomPopupOptions | undefined
    _bindMenu_flag?: boolean
    _bindMenu0_value?: boolean | undefined
    _bindMenu1_value?: Array<MenuElement> | CustomBuilder | undefined
    _bindMenu2_value?: MenuOptions | undefined
    _bindContextMenu_flag?: boolean
    _bindContextMenu0_value?: boolean | undefined
    _bindContextMenu1_value?: CustomBuilder | undefined
    _bindContextMenu2_value?: ContextMenuOptions | undefined
    _bindContentCover_flag?: boolean
    _bindContentCover0_value?: boolean | undefined
    _bindContentCover1_value?: CustomBuilder | undefined
    _bindContentCover2_value?: ContentCoverOptions | undefined
    _bindSheet_flag?: boolean
    _bindSheet0_value?: boolean | undefined
    _bindSheet1_value?: CustomBuilder | undefined
    _bindSheet2_value?: SheetOptions | undefined
    _onVisibleAreaChange_flag?: boolean
    _onVisibleAreaChange0_value?: Array<number> | undefined
    _onVisibleAreaChange1_value?: VisibleAreaChangeCallback | undefined
    _onVisibleAreaApproximateChange_flag?: boolean
    _onVisibleAreaApproximateChange0_value?: VisibleAreaEventOptions | undefined
    _onVisibleAreaApproximateChange1_value?: VisibleAreaChangeCallback | undefined
    _keyboardShortcut_flag?: boolean
    _keyboardShortcut0_value?: string | FunctionKey | undefined
    _keyboardShortcut1_value?: Array<ModifierKey> | undefined
    _keyboardShortcut2_value?: (() => void) | undefined
    applyModifierPatch(component: CommonMethod): void {
        if (this._width_flag)
            component.width((this._width0_value as Length | LayoutPolicy | undefined))
        if (this._height_flag)
            component.height((this._height0_value as Length | LayoutPolicy | undefined))
        if (this._drawModifier_flag)
            component.drawModifier((this._drawModifier0_value as DrawModifier | undefined))
        if (this._responseRegion_flag)
            component.responseRegion((this._responseRegion0_value as Array<Rectangle> | Rectangle | undefined))
        if (this._mouseResponseRegion_flag)
            component.mouseResponseRegion((this._mouseResponseRegion0_value as Array<Rectangle> | Rectangle | undefined))
        if (this._size_flag)
            component.size((this._size0_value as SizeOptions | undefined))
        if (this._constraintSize_flag)
            component.constraintSize((this._constraintSize0_value as ConstraintSizeOptions | undefined))
        if (this._hitTestBehavior_flag)
            component.hitTestBehavior((this._hitTestBehavior0_value as HitTestMode | undefined))
        if (this._onChildTouchTest_flag)
            component.onChildTouchTest((this._onChildTouchTest0_value as ((value: Array<TouchTestInfo>) => TouchResult) | undefined))
        if (this._layoutWeight_flag)
            component.layoutWeight((this._layoutWeight0_value as number | string | undefined))
        if (this._chainWeight_flag)
            component.chainWeight((this._chainWeight0_value as ChainWeightOptions | undefined))
        if (this._padding_flag)
            component.padding((this._padding0_value as Padding | Length | LocalizedPadding | undefined))
        if (this._safeAreaPadding_flag)
            component.safeAreaPadding((this._safeAreaPadding0_value as Padding | LengthMetrics | LocalizedPadding | undefined))
        if (this._margin_flag)
            component.margin((this._margin0_value as Padding | Length | LocalizedPadding | undefined))
        if (this._backgroundColor_flag)
            component.backgroundColor((this._backgroundColor0_value as ResourceColor | undefined))
        if (this._pixelRound_flag)
            component.pixelRound((this._pixelRound0_value as PixelRoundPolicy | undefined))
        if (this._backgroundImageSize_flag)
            component.backgroundImageSize((this._backgroundImageSize0_value as SizeOptions | ImageSize | undefined))
        if (this._backgroundImagePosition_flag)
            component.backgroundImagePosition((this._backgroundImagePosition0_value as Position | Alignment | undefined))
        if (this._backgroundEffect_flag)
            component.backgroundEffect((this._backgroundEffect0_value as BackgroundEffectOptions | undefined), (this._backgroundEffect1_value as SystemAdaptiveOptions | undefined))
        if (this._backgroundImageResizable_flag)
            component.backgroundImageResizable((this._backgroundImageResizable0_value as ResizableOptions | undefined))
        if (this._foregroundEffect_flag)
            component.foregroundEffect((this._foregroundEffect0_value as ForegroundEffectOptions | undefined))
        if (this._visualEffect_flag)
            component.visualEffect((this._visualEffect0_value as uiEffect.VisualEffect | undefined))
        if (this._backgroundFilter_flag)
            component.backgroundFilter((this._backgroundFilter0_value as uiEffect.Filter | undefined))
        if (this._foregroundFilter_flag)
            component.foregroundFilter((this._foregroundFilter0_value as uiEffect.Filter | undefined))
        if (this._compositingFilter_flag)
            component.compositingFilter((this._compositingFilter0_value as uiEffect.Filter | undefined))
        if (this._opacity_flag)
            component.opacity((this._opacity0_value as number | Resource | undefined))
        if (this._border_flag)
            component.border((this._border0_value as BorderOptions | undefined))
        if (this._borderStyle_flag)
            component.borderStyle((this._borderStyle0_value as BorderStyle | EdgeStyles | undefined))
        if (this._borderWidth_flag)
            component.borderWidth((this._borderWidth0_value as Length | EdgeWidths | LocalizedEdgeWidths | undefined))
        if (this._borderColor_flag)
            component.borderColor((this._borderColor0_value as ResourceColor | EdgeColors | LocalizedEdgeColors | undefined))
        if (this._borderRadius_flag)
            component.borderRadius((this._borderRadius0_value as Length | BorderRadiuses | LocalizedBorderRadiuses | undefined))
        if (this._borderImage_flag)
            component.borderImage((this._borderImage0_value as BorderImageOption | undefined))
        if (this._outline_flag)
            component.outline((this._outline0_value as OutlineOptions | undefined))
        if (this._outlineStyle_flag)
            component.outlineStyle((this._outlineStyle0_value as OutlineStyle | EdgeOutlineStyles | undefined))
        if (this._outlineWidth_flag)
            component.outlineWidth((this._outlineWidth0_value as Dimension | EdgeOutlineWidths | undefined))
        if (this._outlineColor_flag)
            component.outlineColor((this._outlineColor0_value as ResourceColor | EdgeColors | LocalizedEdgeColors | undefined))
        if (this._outlineRadius_flag)
            component.outlineRadius((this._outlineRadius0_value as Dimension | OutlineRadiuses | undefined))
        if (this._foregroundColor_flag)
            component.foregroundColor((this._foregroundColor0_value as ResourceColor | ColoringStrategy | undefined))
        if (this._onClick_flag)
            component.onClick((this._onClick0_value as ((event: ClickEvent) => void) | undefined), (this._onClick1_value as number | undefined))
        if (this._onHover_flag)
            component.onHover((this._onHover0_value as ((isHover: boolean,event: HoverEvent) => void) | undefined))
        if (this._onHoverMove_flag)
            component.onHoverMove((this._onHoverMove0_value as ((value0: HoverEvent) => void) | undefined))
        if (this._onAccessibilityHover_flag)
            component.onAccessibilityHover((this._onAccessibilityHover0_value as AccessibilityCallback | undefined))
        if (this._hoverEffect_flag)
            component.hoverEffect((this._hoverEffect0_value as HoverEffect | undefined))
        if (this._onMouse_flag)
            component.onMouse((this._onMouse0_value as ((event: MouseEvent) => void) | undefined))
        if (this._onTouch_flag)
            component.onTouch((this._onTouch0_value as ((event: TouchEvent) => void) | undefined))
        if (this._onKeyEvent_flag)
            component.onKeyEvent((this._onKeyEvent0_value as ((event: KeyEvent) => void) | undefined))
        if (this._onDigitalCrown_flag)
            component.onDigitalCrown((this._onDigitalCrown0_value as ((value0: CrownEvent) => void) | undefined))
        if (this._onKeyPreIme_flag)
            component.onKeyPreIme((this._onKeyPreIme0_value as ((value0: KeyEvent) => boolean) | undefined))
        if (this._onKeyEventDispatch_flag)
            component.onKeyEventDispatch((this._onKeyEventDispatch0_value as ((value0: KeyEvent) => boolean) | undefined))
        if (this._onFocusAxisEvent_flag)
            component.onFocusAxisEvent((this._onFocusAxisEvent0_value as ((value0: FocusAxisEvent) => void) | undefined))
        if (this._onAxisEvent_flag)
            component.onAxisEvent((this._onAxisEvent0_value as ((value0: AxisEvent) => void) | undefined))
        if (this._focusable_flag)
            component.focusable((this._focusable0_value as boolean | undefined))
        if (this._nextFocus_flag)
            component.nextFocus((this._nextFocus0_value as FocusMovement | undefined))
        if (this._tabStop_flag)
            component.tabStop((this._tabStop0_value as boolean | undefined))
        if (this._onFocus_flag)
            component.onFocus((this._onFocus0_value as (() => void) | undefined))
        if (this._onBlur_flag)
            component.onBlur((this._onBlur0_value as (() => void) | undefined))
        if (this._tabIndex_flag)
            component.tabIndex((this._tabIndex0_value as number | undefined))
        if (this._defaultFocus_flag)
            component.defaultFocus((this._defaultFocus0_value as boolean | undefined))
        if (this._groupDefaultFocus_flag)
            component.groupDefaultFocus((this._groupDefaultFocus0_value as boolean | undefined))
        if (this._focusOnTouch_flag)
            component.focusOnTouch((this._focusOnTouch0_value as boolean | undefined))
        if (this._focusBox_flag)
            component.focusBox((this._focusBox0_value as FocusBoxStyle | undefined))
        if (this._animation_flag)
            component.animation((this._animation0_value as AnimateParam | undefined))
        if (this._transition_flag)
            component.transition((this._transition0_value as TransitionEffect | undefined), (this._transition1_value as TransitionFinishCallback | undefined))
        if (this._motionBlur_flag)
            component.motionBlur((this._motionBlur0_value as MotionBlurOptions | undefined))
        if (this._brightness_flag)
            component.brightness((this._brightness0_value as number | undefined))
        if (this._contrast_flag)
            component.contrast((this._contrast0_value as number | undefined))
        if (this._grayscale_flag)
            component.grayscale((this._grayscale0_value as number | undefined))
        if (this._colorBlend_flag)
            component.colorBlend((this._colorBlend0_value as Color | string | Resource | undefined))
        if (this._saturate_flag)
            component.saturate((this._saturate0_value as number | undefined))
        if (this._sepia_flag)
            component.sepia((this._sepia0_value as number | undefined))
        if (this._invert_flag)
            component.invert((this._invert0_value as number | InvertOptions | undefined))
        if (this._hueRotate_flag)
            component.hueRotate((this._hueRotate0_value as number | string | undefined))
        if (this._useShadowBatching_flag)
            component.useShadowBatching((this._useShadowBatching0_value as boolean | undefined))
        if (this._useEffect_flag)
            component.useEffect((this._useEffect0_value as boolean | undefined), (this._useEffect1_value as EffectType | undefined))
        if (this._renderGroup_flag)
            component.renderGroup((this._renderGroup0_value as boolean | undefined))
        if (this._freeze_flag)
            component.freeze((this._freeze0_value as boolean | undefined))
        if (this._translate_flag)
            component.translate((this._translate0_value as TranslateOptions | undefined))
        if (this._scale_flag)
            component.scale((this._scale0_value as ScaleOptions | undefined))
        if (this._rotate_flag)
            component.rotate((this._rotate0_value as RotateOptions | undefined))
        if (this._transform_flag)
            component.transform((this._transform0_value as Object | undefined))
        if (this._onAppear_flag)
            component.onAppear((this._onAppear0_value as (() => void) | undefined))
        if (this._onDisAppear_flag)
            component.onDisAppear((this._onDisAppear0_value as (() => void) | undefined))
        if (this._onAttach_flag)
            component.onAttach((this._onAttach0_value as VoidCallback | undefined))
        if (this._onDetach_flag)
            component.onDetach((this._onDetach0_value as VoidCallback | undefined))
        if (this._onAreaChange_flag)
            component.onAreaChange((this._onAreaChange0_value as ((oldValue: Area,newValue: Area) => void) | undefined))
        if (this._visibility_flag)
            component.visibility((this._visibility0_value as Visibility | undefined))
        if (this._flexGrow_flag)
            component.flexGrow((this._flexGrow0_value as number | undefined))
        if (this._flexShrink_flag)
            component.flexShrink((this._flexShrink0_value as number | undefined))
        if (this._flexBasis_flag)
            component.flexBasis((this._flexBasis0_value as number | string | undefined))
        if (this._alignSelf_flag)
            component.alignSelf((this._alignSelf0_value as ItemAlign | undefined))
        if (this._displayPriority_flag)
            component.displayPriority((this._displayPriority0_value as number | undefined))
        if (this._zIndex_flag)
            component.zIndex((this._zIndex0_value as number | undefined))
        if (this._direction_flag)
            component.direction((this._direction0_value as Direction | undefined))
        if (this._align_flag)
            component.align((this._align0_value as Alignment | undefined))
        if (this._position_flag)
            component.position((this._position0_value as Position | Edges | LocalizedEdges | undefined))
        if (this._markAnchor_flag)
            component.markAnchor((this._markAnchor0_value as Position | LocalizedPosition | undefined))
        if (this._offset_flag)
            component.offset((this._offset0_value as Position | Edges | LocalizedEdges | undefined))
        if (this._enabled_flag)
            component.enabled((this._enabled0_value as boolean | undefined))
        if (this._alignRules_flag)
            component.alignRules((this._alignRules0_value as LocalizedAlignRuleOptions | undefined))
        if (this._aspectRatio_flag)
            component.aspectRatio((this._aspectRatio0_value as number | undefined))
        if (this._clickEffect_flag)
            component.clickEffect((this._clickEffect0_value as ClickEffect | undefined))
        if (this._onDragStart_flag)
            component.onDragStart((this._onDragStart0_value as ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined))
        if (this._onDragEnter_flag)
            component.onDragEnter((this._onDragEnter0_value as ((event: DragEvent,extraParams?: string) => void) | undefined))
        if (this._onDragMove_flag)
            component.onDragMove((this._onDragMove0_value as ((event: DragEvent,extraParams?: string) => void) | undefined))
        if (this._onDragLeave_flag)
            component.onDragLeave((this._onDragLeave0_value as ((event: DragEvent,extraParams?: string) => void) | undefined))
        if (this._onDrop_flag)
            component.onDrop((this._onDrop0_value as OnDragEventCallback | undefined), (this._onDrop1_value as DropOptions | undefined))
        if (this._onDragEnd_flag)
            component.onDragEnd((this._onDragEnd0_value as ((event: DragEvent,extraParams?: string) => void) | undefined))
        if (this._allowDrop_flag)
            component.allowDrop((this._allowDrop0_value as Array<uniformTypeDescriptor.UniformDataType> | undefined))
        if (this._draggable_flag)
            component.draggable((this._draggable0_value as boolean | undefined))
        if (this._dragPreview_flag)
            component.dragPreview((this._dragPreview0_value as CustomBuilder | DragItemInfo | string | undefined), (this._dragPreview1_value as PreviewConfiguration | undefined))
        if (this._onPreDrag_flag)
            component.onPreDrag((this._onPreDrag0_value as ((value0: PreDragStatus) => void) | undefined))
        if (this._linearGradient_flag)
            component.linearGradient((this._linearGradient0_value as LinearGradientOptions | undefined))
        if (this._sweepGradient_flag)
            component.sweepGradient((this._sweepGradient0_value as SweepGradientOptions | undefined))
        if (this._radialGradient_flag)
            component.radialGradient((this._radialGradient0_value as RadialGradientOptions | undefined))
        if (this._motionPath_flag)
            component.motionPath((this._motionPath0_value as MotionPathOptions | undefined))
        if (this._shadow_flag)
            component.shadow((this._shadow0_value as ShadowOptions | ShadowStyle | undefined))
        if (this._clip_flag)
            component.clip((this._clip0_value as boolean | undefined))
        if (this._clipShape_flag)
            component.clipShape((this._clipShape0_value as CircleShape | EllipseShape | PathShape | RectShape | undefined))
        if (this._mask_flag)
            component.mask((this._mask0_value as ProgressMask | undefined))
        if (this._maskShape_flag)
            component.maskShape((this._maskShape0_value as CircleShape | EllipseShape | PathShape | RectShape | undefined))
        if (this._key_flag)
            component.key((this._key0_value as string | undefined))
        if (this._id_flag)
            component.id((this._id0_value as string | undefined))
        if (this._geometryTransition_flag)
            component.geometryTransition((this._geometryTransition0_value as string | undefined), (this._geometryTransition1_value as GeometryTransitionOptions | undefined))
        if (this._stateStyles_flag)
            component.stateStyles((this._stateStyles0_value as StateStyles | undefined))
        if (this._restoreId_flag)
            component.restoreId((this._restoreId0_value as number | undefined))
        if (this._sphericalEffect_flag)
            component.sphericalEffect((this._sphericalEffect0_value as number | undefined))
        if (this._lightUpEffect_flag)
            component.lightUpEffect((this._lightUpEffect0_value as number | undefined))
        if (this._pixelStretchEffect_flag)
            component.pixelStretchEffect((this._pixelStretchEffect0_value as PixelStretchEffectOptions | undefined))
        if (this._accessibilityGroup_flag)
            component.accessibilityGroup((this._accessibilityGroup0_value as boolean | undefined), (this._accessibilityGroup1_value as AccessibilityOptions | undefined))
        if (this._accessibilityText_flag)
            component.accessibilityText((this._accessibilityText0_value as Resource | undefined))
        if (this._accessibilityNextFocusId_flag)
            component.accessibilityNextFocusId((this._accessibilityNextFocusId0_value as string | undefined))
        if (this._accessibilityDefaultFocus_flag)
            component.accessibilityDefaultFocus((this._accessibilityDefaultFocus0_value as boolean | undefined))
        if (this._accessibilityUseSamePage_flag)
            component.accessibilityUseSamePage((this._accessibilityUseSamePage0_value as AccessibilitySamePageMode | undefined))
        if (this._accessibilityScrollTriggerable_flag)
            component.accessibilityScrollTriggerable((this._accessibilityScrollTriggerable0_value as boolean | undefined))
        if (this._accessibilityRole_flag)
            component.accessibilityRole((this._accessibilityRole0_value as AccessibilityRoleType | undefined))
        if (this._onAccessibilityFocus_flag)
            component.onAccessibilityFocus((this._onAccessibilityFocus0_value as AccessibilityFocusCallback | undefined))
        if (this._accessibilityTextHint_flag)
            component.accessibilityTextHint((this._accessibilityTextHint0_value as string | undefined))
        if (this._accessibilityDescription_flag)
            component.accessibilityDescription((this._accessibilityDescription0_value as Resource | undefined))
        if (this._accessibilityLevel_flag)
            component.accessibilityLevel((this._accessibilityLevel0_value as string | undefined))
        if (this._accessibilityVirtualNode_flag)
            component.accessibilityVirtualNode((this._accessibilityVirtualNode0_value as CustomBuilder | undefined))
        if (this._accessibilityChecked_flag)
            component.accessibilityChecked((this._accessibilityChecked0_value as boolean | undefined))
        if (this._accessibilitySelected_flag)
            component.accessibilitySelected((this._accessibilitySelected0_value as boolean | undefined))
        if (this._obscured_flag)
            component.obscured((this._obscured0_value as Array<ObscuredReasons> | undefined))
        if (this._reuseId_flag)
            component.reuseId((this._reuseId0_value as string | undefined))
        if (this._reuse_flag)
            component.reuse((this._reuse0_value as ReuseOptions | undefined))
        if (this._renderFit_flag)
            component.renderFit((this._renderFit0_value as RenderFit | undefined))
        if (this._gestureModifier_flag)
            component.gestureModifier((this._gestureModifier0_value as GestureModifier | undefined))
        if (this._backgroundBrightness_flag)
            component.backgroundBrightness((this._backgroundBrightness0_value as BackgroundBrightnessOptions | undefined))
        if (this._onGestureJudgeBegin_flag)
            component.onGestureJudgeBegin((this._onGestureJudgeBegin0_value as ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined))
        if (this._onGestureRecognizerJudgeBegin_flag)
            component.onGestureRecognizerJudgeBegin((this._onGestureRecognizerJudgeBegin0_value as GestureRecognizerJudgeBeginCallback | undefined), (this._onGestureRecognizerJudgeBegin1_value as boolean | undefined))
        if (this._shouldBuiltInRecognizerParallelWith_flag)
            component.shouldBuiltInRecognizerParallelWith((this._shouldBuiltInRecognizerParallelWith0_value as ShouldBuiltInRecognizerParallelWithCallback | undefined))
        if (this._monopolizeEvents_flag)
            component.monopolizeEvents((this._monopolizeEvents0_value as boolean | undefined))
        if (this._onTouchIntercept_flag)
            component.onTouchIntercept((this._onTouchIntercept0_value as ((value0: TouchEvent) => HitTestMode) | undefined))
        if (this._onSizeChange_flag)
            component.onSizeChange((this._onSizeChange0_value as SizeChangeCallback | undefined))
        if (this._accessibilityFocusDrawLevel_flag)
            component.accessibilityFocusDrawLevel((this._accessibilityFocusDrawLevel0_value as FocusDrawLevel | undefined))
        if (this._customProperty_flag)
            component.customProperty((this._customProperty0_value as string | undefined), (this._customProperty1_value as Object | undefined))
        if (this._expandSafeArea_flag)
            component.expandSafeArea((this._expandSafeArea0_value as Array<SafeAreaType> | undefined), (this._expandSafeArea1_value as Array<SafeAreaEdge> | undefined))
        if (this._background_flag)
            component.background((this._background0_value as CustomBuilder | undefined), (this._background1_value as BackgroundOptions | undefined))
        if (this._backgroundImage_flag)
            component.backgroundImage((this._backgroundImage0_value as ResourceStr | image.PixelMap | undefined), (this._backgroundImage1_value as BackgroundImageOptions | undefined))
        if (this._backgroundBlurStyle_flag)
            component.backgroundBlurStyle((this._backgroundBlurStyle0_value as BlurStyle | undefined), (this._backgroundBlurStyle1_value as BackgroundBlurStyleOptions | undefined), (this._backgroundBlurStyle2_value as SystemAdaptiveOptions | undefined))
        if (this._foregroundBlurStyle_flag)
            component.foregroundBlurStyle((this._foregroundBlurStyle0_value as BlurStyle | undefined), (this._foregroundBlurStyle1_value as ForegroundBlurStyleOptions | undefined), (this._foregroundBlurStyle2_value as SystemAdaptiveOptions | undefined))
        if (this._focusScopeId_flag)
            component.focusScopeId((this._focusScopeId0_value as string | undefined), (this._focusScopeId1_value as boolean | undefined), (this._focusScopeId2_value as boolean | undefined))
        if (this._focusScopePriority_flag)
            component.focusScopePriority((this._focusScopePriority0_value as string | undefined), (this._focusScopePriority1_value as FocusPriority | undefined))
        if (this._gesture_flag)
            component.gesture((this._gesture0_value as GestureType | undefined), (this._gesture1_value as GestureMask | undefined))
        if (this._priorityGesture_flag)
            component.priorityGesture((this._priorityGesture0_value as GestureType | undefined), (this._priorityGesture1_value as GestureMask | undefined))
        if (this._parallelGesture_flag)
            component.parallelGesture((this._parallelGesture0_value as GestureType | undefined), (this._parallelGesture1_value as GestureMask | undefined))
        if (this._blur_flag)
            component.blur((this._blur0_value as number | undefined), (this._blur1_value as BlurOptions | undefined), (this._blur2_value as SystemAdaptiveOptions | undefined))
        if (this._linearGradientBlur_flag)
            component.linearGradientBlur((this._linearGradientBlur0_value as number | undefined), (this._linearGradientBlur1_value as LinearGradientBlurOptions | undefined))
        if (this._systemBarEffect_flag)
            component.systemBarEffect()
        if (this._backdropBlur_flag)
            component.backdropBlur((this._backdropBlur0_value as number | undefined), (this._backdropBlur1_value as BlurOptions | undefined), (this._backdropBlur2_value as SystemAdaptiveOptions | undefined))
        if (this._sharedTransition_flag)
            component.sharedTransition((this._sharedTransition0_value as string | undefined), (this._sharedTransition1_value as sharedTransitionOptions | undefined))
        if (this._chainMode_flag)
            component.chainMode((this._chainMode0_value as Axis | undefined), (this._chainMode1_value as ChainStyle | undefined))
        if (this._dragPreviewOptions_flag)
            component.dragPreviewOptions((this._dragPreviewOptions0_value as DragPreviewOptions | undefined), (this._dragPreviewOptions1_value as DragInteractionOptions | undefined))
        if (this._overlay_flag)
            component.overlay((this._overlay0_value as string | CustomBuilder | ComponentContent | undefined), (this._overlay1_value as OverlayOptions | undefined))
        if (this._blendMode_flag)
            component.blendMode((this._blendMode0_value as BlendMode | undefined), (this._blendMode1_value as BlendApplyType | undefined))
        if (this._advancedBlendMode_flag)
            component.advancedBlendMode((this._advancedBlendMode0_value as BlendMode | uiEffect.Blender | undefined), (this._advancedBlendMode1_value as BlendApplyType | undefined))
        if (this._bindTips_flag)
            component.bindTips((this._bindTips0_value as TipsMessageType | undefined), (this._bindTips1_value as TipsOptions | undefined))
        if (this._bindPopup_flag)
            component.bindPopup((this._bindPopup0_value as boolean | undefined), (this._bindPopup1_value as PopupOptions | CustomPopupOptions | undefined))
        if (this._bindMenu_flag)
            component.bindMenu((this._bindMenu0_value as boolean | undefined), (this._bindMenu1_value as Array<MenuElement> | CustomBuilder | undefined), (this._bindMenu2_value as MenuOptions | undefined))
        if (this._bindContextMenu_flag)
            component.bindContextMenu((this._bindContextMenu0_value as boolean | undefined), (this._bindContextMenu1_value as CustomBuilder | undefined), (this._bindContextMenu2_value as ContextMenuOptions | undefined))
        if (this._bindContentCover_flag)
            component.bindContentCover((this._bindContentCover0_value as boolean | undefined), (this._bindContentCover1_value as CustomBuilder | undefined), (this._bindContentCover2_value as ContentCoverOptions | undefined))
        if (this._bindSheet_flag)
            component.bindSheet((this._bindSheet0_value as boolean | undefined), (this._bindSheet1_value as CustomBuilder | undefined), (this._bindSheet2_value as SheetOptions | undefined))
        if (this._onVisibleAreaChange_flag)
            component.onVisibleAreaChange((this._onVisibleAreaChange0_value as Array<number> | undefined), (this._onVisibleAreaChange1_value as VisibleAreaChangeCallback | undefined))
        if (this._onVisibleAreaApproximateChange_flag)
            component.onVisibleAreaApproximateChange((this._onVisibleAreaApproximateChange0_value as VisibleAreaEventOptions | undefined), (this._onVisibleAreaApproximateChange1_value as VisibleAreaChangeCallback | undefined))
        if (this._keyboardShortcut_flag)
            component.keyboardShortcut((this._keyboardShortcut0_value as string | FunctionKey | undefined), (this._keyboardShortcut1_value as Array<ModifierKey> | undefined), (this._keyboardShortcut2_value as (() => void) | undefined))
    }
    public width(value: Length | LayoutPolicy | undefined): this {
        this._width_flag = true
        this._width0_value = value
        return this
    }
    public height(value: Length | LayoutPolicy | undefined): this {
        this._height_flag = true
        this._height0_value = value
        return this
    }
    public drawModifier(value: DrawModifier | undefined): this {
        this._drawModifier_flag = true
        this._drawModifier0_value = value
        return this
    }
    public responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        this._responseRegion_flag = true
        this._responseRegion0_value = value
        return this
    }
    public mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        this._mouseResponseRegion_flag = true
        this._mouseResponseRegion0_value = value
        return this
    }
    public size(value: SizeOptions | undefined): this {
        this._size_flag = true
        this._size0_value = value
        return this
    }
    public constraintSize(value: ConstraintSizeOptions | undefined): this {
        this._constraintSize_flag = true
        this._constraintSize0_value = value
        return this
    }
    public hitTestBehavior(value: HitTestMode | undefined): this {
        this._hitTestBehavior_flag = true
        this._hitTestBehavior0_value = value
        return this
    }
    public onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        this._onChildTouchTest_flag = true
        this._onChildTouchTest0_value = value
        return this
    }
    public layoutWeight(value: number | string | undefined): this {
        this._layoutWeight_flag = true
        this._layoutWeight0_value = value
        return this
    }
    public chainWeight(value: ChainWeightOptions | undefined): this {
        this._chainWeight_flag = true
        this._chainWeight0_value = value
        return this
    }
    public padding(value: Padding | Length | LocalizedPadding | undefined): this {
        this._padding_flag = true
        this._padding0_value = value
        return this
    }
    public safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        this._safeAreaPadding_flag = true
        this._safeAreaPadding0_value = value
        return this
    }
    public margin(value: Padding | Length | LocalizedPadding | undefined): this {
        this._margin_flag = true
        this._margin0_value = value
        return this
    }
    public backgroundColor(value: ResourceColor | undefined): this {
        this._backgroundColor_flag = true
        this._backgroundColor0_value = value
        return this
    }
    public pixelRound(value: PixelRoundPolicy | undefined): this {
        this._pixelRound_flag = true
        this._pixelRound0_value = value
        return this
    }
    public backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        this._backgroundImageSize_flag = true
        this._backgroundImageSize0_value = value
        return this
    }
    public backgroundImagePosition(value: Position | Alignment | undefined): this {
        this._backgroundImagePosition_flag = true
        this._backgroundImagePosition0_value = value
        return this
    }
    public backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        this._backgroundEffect_flag = true
        this._backgroundEffect0_value = options
        this._backgroundEffect1_value = sysOptions
        return this
    }
    public backgroundImageResizable(value: ResizableOptions | undefined): this {
        this._backgroundImageResizable_flag = true
        this._backgroundImageResizable0_value = value
        return this
    }
    public foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        this._foregroundEffect_flag = true
        this._foregroundEffect0_value = value
        return this
    }
    public visualEffect(value: uiEffect.VisualEffect | undefined): this {
        this._visualEffect_flag = true
        this._visualEffect0_value = value
        return this
    }
    public backgroundFilter(value: uiEffect.Filter | undefined): this {
        this._backgroundFilter_flag = true
        this._backgroundFilter0_value = value
        return this
    }
    public foregroundFilter(value: uiEffect.Filter | undefined): this {
        this._foregroundFilter_flag = true
        this._foregroundFilter0_value = value
        return this
    }
    public compositingFilter(value: uiEffect.Filter | undefined): this {
        this._compositingFilter_flag = true
        this._compositingFilter0_value = value
        return this
    }
    public opacity(value: number | Resource | undefined): this {
        this._opacity_flag = true
        this._opacity0_value = value
        return this
    }
    public border(value: BorderOptions | undefined): this {
        this._border_flag = true
        this._border0_value = value
        return this
    }
    public borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        this._borderStyle_flag = true
        this._borderStyle0_value = value
        return this
    }
    public borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        this._borderWidth_flag = true
        this._borderWidth0_value = value
        return this
    }
    public borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        this._borderColor_flag = true
        this._borderColor0_value = value
        return this
    }
    public borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        this._borderRadius_flag = true
        this._borderRadius0_value = value
        return this
    }
    public borderImage(value: BorderImageOption | undefined): this {
        this._borderImage_flag = true
        this._borderImage0_value = value
        return this
    }
    public outline(value: OutlineOptions | undefined): this {
        this._outline_flag = true
        this._outline0_value = value
        return this
    }
    public outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        this._outlineStyle_flag = true
        this._outlineStyle0_value = value
        return this
    }
    public outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        this._outlineWidth_flag = true
        this._outlineWidth0_value = value
        return this
    }
    public outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        this._outlineColor_flag = true
        this._outlineColor0_value = value
        return this
    }
    public outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        this._outlineRadius_flag = true
        this._outlineRadius0_value = value
        return this
    }
    public foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        this._foregroundColor_flag = true
        this._foregroundColor0_value = value
        return this
    }
    public onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: number | undefined): this {
        this._onClick_flag = true
        this._onClick0_value = event
        this._onClick1_value = distanceThreshold
        return this
    }
    public onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        this._onHover_flag = true
        this._onHover0_value = value
        return this
    }
    public onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        this._onHoverMove_flag = true
        this._onHoverMove0_value = value
        return this
    }
    public onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        this._onAccessibilityHover_flag = true
        this._onAccessibilityHover0_value = value
        return this
    }
    public hoverEffect(value: HoverEffect | undefined): this {
        this._hoverEffect_flag = true
        this._hoverEffect0_value = value
        return this
    }
    public onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        this._onMouse_flag = true
        this._onMouse0_value = value
        return this
    }
    public onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        this._onTouch_flag = true
        this._onTouch0_value = value
        return this
    }
    public onKeyEvent(value: ((event: KeyEvent) => void) | undefined): this {
        this._onKeyEvent_flag = true
        this._onKeyEvent0_value = value
        return this
    }
    public onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        this._onDigitalCrown_flag = true
        this._onDigitalCrown0_value = value
        return this
    }
    public onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        this._onKeyPreIme_flag = true
        this._onKeyPreIme0_value = value
        return this
    }
    public onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        this._onKeyEventDispatch_flag = true
        this._onKeyEventDispatch0_value = value
        return this
    }
    public onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        this._onFocusAxisEvent_flag = true
        this._onFocusAxisEvent0_value = value
        return this
    }
    public onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        this._onAxisEvent_flag = true
        this._onAxisEvent0_value = value
        return this
    }
    public focusable(value: boolean | undefined): this {
        this._focusable_flag = true
        this._focusable0_value = value
        return this
    }
    public nextFocus(value: FocusMovement | undefined): this {
        this._nextFocus_flag = true
        this._nextFocus0_value = value
        return this
    }
    public tabStop(value: boolean | undefined): this {
        this._tabStop_flag = true
        this._tabStop0_value = value
        return this
    }
    public onFocus(value: (() => void) | undefined): this {
        this._onFocus_flag = true
        this._onFocus0_value = value
        return this
    }
    public onBlur(value: (() => void) | undefined): this {
        this._onBlur_flag = true
        this._onBlur0_value = value
        return this
    }
    public tabIndex(value: number | undefined): this {
        this._tabIndex_flag = true
        this._tabIndex0_value = value
        return this
    }
    public defaultFocus(value: boolean | undefined): this {
        this._defaultFocus_flag = true
        this._defaultFocus0_value = value
        return this
    }
    public groupDefaultFocus(value: boolean | undefined): this {
        this._groupDefaultFocus_flag = true
        this._groupDefaultFocus0_value = value
        return this
    }
    public focusOnTouch(value: boolean | undefined): this {
        this._focusOnTouch_flag = true
        this._focusOnTouch0_value = value
        return this
    }
    public focusBox(value: FocusBoxStyle | undefined): this {
        this._focusBox_flag = true
        this._focusBox0_value = value
        return this
    }
    public animation(value: AnimateParam | undefined): this {
        this._animation_flag = true
        this._animation0_value = value
        return this
    }
    public transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        this._transition_flag = true
        this._transition0_value = effect
        this._transition1_value = onFinish
        return this
    }
    public motionBlur(value: MotionBlurOptions | undefined): this {
        this._motionBlur_flag = true
        this._motionBlur0_value = value
        return this
    }
    public brightness(value: number | undefined): this {
        this._brightness_flag = true
        this._brightness0_value = value
        return this
    }
    public contrast(value: number | undefined): this {
        this._contrast_flag = true
        this._contrast0_value = value
        return this
    }
    public grayscale(value: number | undefined): this {
        this._grayscale_flag = true
        this._grayscale0_value = value
        return this
    }
    public colorBlend(value: Color | string | Resource | undefined): this {
        this._colorBlend_flag = true
        this._colorBlend0_value = value
        return this
    }
    public saturate(value: number | undefined): this {
        this._saturate_flag = true
        this._saturate0_value = value
        return this
    }
    public sepia(value: number | undefined): this {
        this._sepia_flag = true
        this._sepia0_value = value
        return this
    }
    public invert(value: number | InvertOptions | undefined): this {
        this._invert_flag = true
        this._invert0_value = value
        return this
    }
    public hueRotate(value: number | string | undefined): this {
        this._hueRotate_flag = true
        this._hueRotate0_value = value
        return this
    }
    public useShadowBatching(value: boolean | undefined): this {
        this._useShadowBatching_flag = true
        this._useShadowBatching0_value = value
        return this
    }
    public useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        this._useEffect_flag = true
        this._useEffect0_value = useEffect
        this._useEffect1_value = effectType
        return this
    }
    public renderGroup(value: boolean | undefined): this {
        this._renderGroup_flag = true
        this._renderGroup0_value = value
        return this
    }
    public freeze(value: boolean | undefined): this {
        this._freeze_flag = true
        this._freeze0_value = value
        return this
    }
    public translate(value: TranslateOptions | undefined): this {
        this._translate_flag = true
        this._translate0_value = value
        return this
    }
    public scale(value: ScaleOptions | undefined): this {
        this._scale_flag = true
        this._scale0_value = value
        return this
    }
    public rotate(value: RotateOptions | undefined): this {
        this._rotate_flag = true
        this._rotate0_value = value
        return this
    }
    public transform(value: Object | undefined): this {
        this._transform_flag = true
        this._transform0_value = value
        return this
    }
    public onAppear(value: (() => void) | undefined): this {
        this._onAppear_flag = true
        this._onAppear0_value = value
        return this
    }
    public onDisAppear(value: (() => void) | undefined): this {
        this._onDisAppear_flag = true
        this._onDisAppear0_value = value
        return this
    }
    public onAttach(value: VoidCallback | undefined): this {
        this._onAttach_flag = true
        this._onAttach0_value = value
        return this
    }
    public onDetach(value: VoidCallback | undefined): this {
        this._onDetach_flag = true
        this._onDetach0_value = value
        return this
    }
    public onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        this._onAreaChange_flag = true
        this._onAreaChange0_value = value
        return this
    }
    public visibility(value: Visibility | undefined): this {
        this._visibility_flag = true
        this._visibility0_value = value
        return this
    }
    public flexGrow(value: number | undefined): this {
        this._flexGrow_flag = true
        this._flexGrow0_value = value
        return this
    }
    public flexShrink(value: number | undefined): this {
        this._flexShrink_flag = true
        this._flexShrink0_value = value
        return this
    }
    public flexBasis(value: number | string | undefined): this {
        this._flexBasis_flag = true
        this._flexBasis0_value = value
        return this
    }
    public alignSelf(value: ItemAlign | undefined): this {
        this._alignSelf_flag = true
        this._alignSelf0_value = value
        return this
    }
    public displayPriority(value: number | undefined): this {
        this._displayPriority_flag = true
        this._displayPriority0_value = value
        return this
    }
    public zIndex(value: number | undefined): this {
        this._zIndex_flag = true
        this._zIndex0_value = value
        return this
    }
    public direction(value: Direction | undefined): this {
        this._direction_flag = true
        this._direction0_value = value
        return this
    }
    public align(value: Alignment | undefined): this {
        this._align_flag = true
        this._align0_value = value
        return this
    }
    public position(value: Position | Edges | LocalizedEdges | undefined): this {
        this._position_flag = true
        this._position0_value = value
        return this
    }
    public markAnchor(value: Position | LocalizedPosition | undefined): this {
        this._markAnchor_flag = true
        this._markAnchor0_value = value
        return this
    }
    public offset(value: Position | Edges | LocalizedEdges | undefined): this {
        this._offset_flag = true
        this._offset0_value = value
        return this
    }
    public enabled(value: boolean | undefined): this {
        this._enabled_flag = true
        this._enabled0_value = value
        return this
    }
    public alignRules(value: LocalizedAlignRuleOptions | undefined): this {
        this._alignRules_flag = true
        this._alignRules0_value = value
        return this
    }
    public aspectRatio(value: number | undefined): this {
        this._aspectRatio_flag = true
        this._aspectRatio0_value = value
        return this
    }
    public clickEffect(value: ClickEffect | undefined): this {
        this._clickEffect_flag = true
        this._clickEffect0_value = value
        return this
    }
    public onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        this._onDragStart_flag = true
        this._onDragStart0_value = value
        return this
    }
    public onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        this._onDragEnter_flag = true
        this._onDragEnter0_value = value
        return this
    }
    public onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        this._onDragMove_flag = true
        this._onDragMove0_value = value
        return this
    }
    public onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        this._onDragLeave_flag = true
        this._onDragLeave0_value = value
        return this
    }
    public onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        this._onDrop_flag = true
        this._onDrop0_value = eventCallback
        this._onDrop1_value = dropOptions
        return this
    }
    public onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        this._onDragEnd_flag = true
        this._onDragEnd0_value = value
        return this
    }
    public allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | undefined): this {
        this._allowDrop_flag = true
        this._allowDrop0_value = value
        return this
    }
    public draggable(value: boolean | undefined): this {
        this._draggable_flag = true
        this._draggable0_value = value
        return this
    }
    public dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        this._dragPreview_flag = true
        this._dragPreview0_value = preview
        this._dragPreview1_value = config
        return this
    }
    public onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        this._onPreDrag_flag = true
        this._onPreDrag0_value = value
        return this
    }
    public linearGradient(value: LinearGradientOptions | undefined): this {
        this._linearGradient_flag = true
        this._linearGradient0_value = value
        return this
    }
    public sweepGradient(value: SweepGradientOptions | undefined): this {
        this._sweepGradient_flag = true
        this._sweepGradient0_value = value
        return this
    }
    public radialGradient(value: RadialGradientOptions | undefined): this {
        this._radialGradient_flag = true
        this._radialGradient0_value = value
        return this
    }
    public motionPath(value: MotionPathOptions | undefined): this {
        this._motionPath_flag = true
        this._motionPath0_value = value
        return this
    }
    public shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        this._shadow_flag = true
        this._shadow0_value = value
        return this
    }
    public clip(value: boolean | undefined): this {
        this._clip_flag = true
        this._clip0_value = value
        return this
    }
    public clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        this._clipShape_flag = true
        this._clipShape0_value = value
        return this
    }
    public mask(value: ProgressMask | undefined): this {
        this._mask_flag = true
        this._mask0_value = value
        return this
    }
    public maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        this._maskShape_flag = true
        this._maskShape0_value = value
        return this
    }
    public key(value: string | undefined): this {
        this._key_flag = true
        this._key0_value = value
        return this
    }
    public id(value: string | undefined): this {
        this._id_flag = true
        this._id0_value = value
        return this
    }
    public geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        this._geometryTransition_flag = true
        this._geometryTransition0_value = id
        this._geometryTransition1_value = options
        return this
    }
    public stateStyles(value: StateStyles | undefined): this {
        this._stateStyles_flag = true
        this._stateStyles0_value = value
        return this
    }
    public restoreId(value: number | undefined): this {
        this._restoreId_flag = true
        this._restoreId0_value = value
        return this
    }
    public sphericalEffect(value: number | undefined): this {
        this._sphericalEffect_flag = true
        this._sphericalEffect0_value = value
        return this
    }
    public lightUpEffect(value: number | undefined): this {
        this._lightUpEffect_flag = true
        this._lightUpEffect0_value = value
        return this
    }
    public pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        this._pixelStretchEffect_flag = true
        this._pixelStretchEffect0_value = value
        return this
    }
    public accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions: AccessibilityOptions | undefined): this {
        this._accessibilityGroup_flag = true
        this._accessibilityGroup0_value = isGroup
        this._accessibilityGroup1_value = accessibilityOptions
        return this
    }
    public accessibilityText(value: Resource | undefined): this {
        this._accessibilityText_flag = true
        this._accessibilityText0_value = value
        return this
    }
    public accessibilityNextFocusId(value: string | undefined): this {
        this._accessibilityNextFocusId_flag = true
        this._accessibilityNextFocusId0_value = value
        return this
    }
    public accessibilityDefaultFocus(value: boolean | undefined): this {
        this._accessibilityDefaultFocus_flag = true
        this._accessibilityDefaultFocus0_value = value
        return this
    }
    public accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        this._accessibilityUseSamePage_flag = true
        this._accessibilityUseSamePage0_value = value
        return this
    }
    public accessibilityScrollTriggerable(value: boolean | undefined): this {
        this._accessibilityScrollTriggerable_flag = true
        this._accessibilityScrollTriggerable0_value = value
        return this
    }
    public accessibilityRole(value: AccessibilityRoleType | undefined): this {
        this._accessibilityRole_flag = true
        this._accessibilityRole0_value = value
        return this
    }
    public onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        this._onAccessibilityFocus_flag = true
        this._onAccessibilityFocus0_value = value
        return this
    }
    public accessibilityTextHint(value: string | undefined): this {
        this._accessibilityTextHint_flag = true
        this._accessibilityTextHint0_value = value
        return this
    }
    public accessibilityDescription(value: Resource | undefined): this {
        this._accessibilityDescription_flag = true
        this._accessibilityDescription0_value = value
        return this
    }
    public accessibilityLevel(value: string | undefined): this {
        this._accessibilityLevel_flag = true
        this._accessibilityLevel0_value = value
        return this
    }
    public accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        this._accessibilityVirtualNode_flag = true
        this._accessibilityVirtualNode0_value = value
        return this
    }
    public accessibilityChecked(value: boolean | undefined): this {
        this._accessibilityChecked_flag = true
        this._accessibilityChecked0_value = value
        return this
    }
    public accessibilitySelected(value: boolean | undefined): this {
        this._accessibilitySelected_flag = true
        this._accessibilitySelected0_value = value
        return this
    }
    public obscured(value: Array<ObscuredReasons> | undefined): this {
        this._obscured_flag = true
        this._obscured0_value = value
        return this
    }
    public reuseId(value: string | undefined): this {
        this._reuseId_flag = true
        this._reuseId0_value = value
        return this
    }
    public reuse(value: ReuseOptions | undefined): this {
        this._reuse_flag = true
        this._reuse0_value = value
        return this
    }
    public renderFit(value: RenderFit | undefined): this {
        this._renderFit_flag = true
        this._renderFit0_value = value
        return this
    }
    public gestureModifier(value: GestureModifier | undefined): this {
        this._gestureModifier_flag = true
        this._gestureModifier0_value = value
        return this
    }
    public backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        this._backgroundBrightness_flag = true
        this._backgroundBrightness0_value = value
        return this
    }
    public onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        this._onGestureJudgeBegin_flag = true
        this._onGestureJudgeBegin0_value = value
        return this
    }
    public onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        this._onGestureRecognizerJudgeBegin_flag = true
        this._onGestureRecognizerJudgeBegin0_value = callback_
        this._onGestureRecognizerJudgeBegin1_value = exposeInnerGesture
        return this
    }
    public shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        this._shouldBuiltInRecognizerParallelWith_flag = true
        this._shouldBuiltInRecognizerParallelWith0_value = value
        return this
    }
    public monopolizeEvents(value: boolean | undefined): this {
        this._monopolizeEvents_flag = true
        this._monopolizeEvents0_value = value
        return this
    }
    public onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        this._onTouchIntercept_flag = true
        this._onTouchIntercept0_value = value
        return this
    }
    public onSizeChange(value: SizeChangeCallback | undefined): this {
        this._onSizeChange_flag = true
        this._onSizeChange0_value = value
        return this
    }
    public accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        this._accessibilityFocusDrawLevel_flag = true
        this._accessibilityFocusDrawLevel0_value = value
        return this
    }
    public customProperty(name: string | undefined, value: Object | undefined): this {
        this._customProperty_flag = true
        this._customProperty0_value = name
        this._customProperty1_value = value
        return this
    }
    public expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        this._expandSafeArea_flag = true
        this._expandSafeArea0_value = types
        this._expandSafeArea1_value = edges
        return this
    }
    public background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        this._background_flag = true
        this._background0_value = builder
        this._background1_value = options
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): this {
        this._backgroundImage_flag = true
        this._backgroundImage0_value = src
        this._backgroundImage1_value = options
        return this
    }
    public backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        this._backgroundBlurStyle_flag = true
        this._backgroundBlurStyle0_value = style
        this._backgroundBlurStyle1_value = options
        this._backgroundBlurStyle2_value = sysOptions
        return this
    }
    public foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        this._foregroundBlurStyle_flag = true
        this._foregroundBlurStyle0_value = style
        this._foregroundBlurStyle1_value = options
        this._foregroundBlurStyle2_value = sysOptions
        return this
    }
    public focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        this._focusScopeId_flag = true
        this._focusScopeId0_value = id
        this._focusScopeId1_value = isGroup
        this._focusScopeId2_value = arrowStepOut
        return this
    }
    public focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        this._focusScopePriority_flag = true
        this._focusScopePriority0_value = scopeId
        this._focusScopePriority1_value = priority
        return this
    }
    public gesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        this._gesture_flag = true
        this._gesture0_value = gesture
        this._gesture1_value = mask
        return this
    }
    public priorityGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        this._priorityGesture_flag = true
        this._priorityGesture0_value = gesture
        this._priorityGesture1_value = mask
        return this
    }
    public parallelGesture(gesture: GestureType | undefined, mask?: GestureMask): this {
        this._parallelGesture_flag = true
        this._parallelGesture0_value = gesture
        this._parallelGesture1_value = mask
        return this
    }
    public blur(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        this._blur_flag = true
        this._blur0_value = blurRadius
        this._blur1_value = options
        this._blur2_value = sysOptions
        return this
    }
    public linearGradientBlur(value: number | undefined, options: LinearGradientBlurOptions | undefined): this {
        this._linearGradientBlur_flag = true
        this._linearGradientBlur0_value = value
        this._linearGradientBlur1_value = options
        return this
    }
    public systemBarEffect(): this {
        this._systemBarEffect_flag = true
        return this
    }
    public backdropBlur(radius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        this._backdropBlur_flag = true
        this._backdropBlur0_value = radius
        this._backdropBlur1_value = options
        this._backdropBlur2_value = sysOptions
        return this
    }
    public sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        this._sharedTransition_flag = true
        this._sharedTransition0_value = id
        this._sharedTransition1_value = options
        return this
    }
    public chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        this._chainMode_flag = true
        this._chainMode0_value = direction
        this._chainMode1_value = style
        return this
    }
    public dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        this._dragPreviewOptions_flag = true
        this._dragPreviewOptions0_value = value
        this._dragPreviewOptions1_value = options
        return this
    }
    public overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        this._overlay_flag = true
        this._overlay0_value = value
        this._overlay1_value = options
        return this
    }
    public blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        this._blendMode_flag = true
        this._blendMode0_value = value
        this._blendMode1_value = type
        return this
    }
    public advancedBlendMode(effect: BlendMode | uiEffect.Blender | undefined, type?: BlendApplyType): this {
        this._advancedBlendMode_flag = true
        this._advancedBlendMode0_value = effect
        this._advancedBlendMode1_value = type
        return this
    }
    public bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        this._bindTips_flag = true
        this._bindTips0_value = message
        this._bindTips1_value = options
        return this
    }
    public bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        this._bindPopup_flag = true
        this._bindPopup0_value = show
        this._bindPopup1_value = popup
        return this
    }
    public bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        this._bindMenu_flag = true
        this._bindMenu0_value = isShow
        this._bindMenu1_value = content
        this._bindMenu2_value = options
        return this
    }
    public bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        this._bindContextMenu_flag = true
        this._bindContextMenu0_value = isShown
        this._bindContextMenu1_value = content
        this._bindContextMenu2_value = options
        return this
    }
    public bindContentCover(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        this._bindContentCover_flag = true
        this._bindContentCover0_value = isShow
        this._bindContentCover1_value = builder
        this._bindContentCover2_value = options
        return this
    }
    public bindSheet(isShow: boolean | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        this._bindSheet_flag = true
        this._bindSheet0_value = isShow
        this._bindSheet1_value = builder
        this._bindSheet2_value = options
        return this
    }
    public onVisibleAreaChange(ratios: Array<number> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        this._onVisibleAreaChange_flag = true
        this._onVisibleAreaChange0_value = ratios
        this._onVisibleAreaChange1_value = event
        return this
    }
    public onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        this._onVisibleAreaApproximateChange_flag = true
        this._onVisibleAreaApproximateChange0_value = options
        this._onVisibleAreaApproximateChange1_value = event
        return this
    }
    public keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        this._keyboardShortcut_flag = true
        this._keyboardShortcut0_value = value
        this._keyboardShortcut1_value = keys
        this._keyboardShortcut2_value = action
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export class ArkCommonShapeMethodSet extends ArkCommonMethodSet implements CommonShapeMethod {
    _instanceId: number = -1;
    setInstanceId(instanceId: number): void {
        this._instanceId = instanceId
    }
    _stroke_flag?: boolean
    _stroke0_value?: ResourceColor | undefined
    _fill_flag?: boolean
    _fill0_value?: ResourceColor | undefined
    _strokeDashOffset_flag?: boolean
    _strokeDashOffset0_value?: number | string | undefined
    _strokeLineCap_flag?: boolean
    _strokeLineCap0_value?: LineCapStyle | undefined
    _strokeLineJoin_flag?: boolean
    _strokeLineJoin0_value?: LineJoinStyle | undefined
    _strokeMiterLimit_flag?: boolean
    _strokeMiterLimit0_value?: number | string | undefined
    _strokeOpacity_flag?: boolean
    _strokeOpacity0_value?: number | string | Resource | undefined
    _fillOpacity_flag?: boolean
    _fillOpacity0_value?: number | string | Resource | undefined
    _strokeWidth_flag?: boolean
    _strokeWidth0_value?: Length | undefined
    _antiAlias_flag?: boolean
    _antiAlias0_value?: boolean | undefined
    _strokeDashArray_flag?: boolean
    _strokeDashArray0_value?: Array<Length> | undefined
    applyModifierPatch(component: CommonShapeMethod): void {
        if (this._stroke_flag)
            component.stroke((this._stroke0_value as ResourceColor | undefined))
        if (this._fill_flag)
            component.fill((this._fill0_value as ResourceColor | undefined))
        if (this._strokeDashOffset_flag)
            component.strokeDashOffset((this._strokeDashOffset0_value as number | string | undefined))
        if (this._strokeLineCap_flag)
            component.strokeLineCap((this._strokeLineCap0_value as LineCapStyle | undefined))
        if (this._strokeLineJoin_flag)
            component.strokeLineJoin((this._strokeLineJoin0_value as LineJoinStyle | undefined))
        if (this._strokeMiterLimit_flag)
            component.strokeMiterLimit((this._strokeMiterLimit0_value as number | string | undefined))
        if (this._strokeOpacity_flag)
            component.strokeOpacity((this._strokeOpacity0_value as number | string | Resource | undefined))
        if (this._fillOpacity_flag)
            component.fillOpacity((this._fillOpacity0_value as number | string | Resource | undefined))
        if (this._strokeWidth_flag)
            component.strokeWidth((this._strokeWidth0_value as Length | undefined))
        if (this._antiAlias_flag)
            component.antiAlias((this._antiAlias0_value as boolean | undefined))
        if (this._strokeDashArray_flag)
            component.strokeDashArray((this._strokeDashArray0_value as Array<Length> | undefined))
    }
    public stroke(value: ResourceColor | undefined): this {
        this._stroke_flag = true
        this._stroke0_value = value
        return this
    }
    public fill(value: ResourceColor | undefined): this {
        this._fill_flag = true
        this._fill0_value = value
        return this
    }
    public strokeDashOffset(value: number | string | undefined): this {
        this._strokeDashOffset_flag = true
        this._strokeDashOffset0_value = value
        return this
    }
    public strokeLineCap(value: LineCapStyle | undefined): this {
        this._strokeLineCap_flag = true
        this._strokeLineCap0_value = value
        return this
    }
    public strokeLineJoin(value: LineJoinStyle | undefined): this {
        this._strokeLineJoin_flag = true
        this._strokeLineJoin0_value = value
        return this
    }
    public strokeMiterLimit(value: number | string | undefined): this {
        this._strokeMiterLimit_flag = true
        this._strokeMiterLimit0_value = value
        return this
    }
    public strokeOpacity(value: number | string | Resource | undefined): this {
        this._strokeOpacity_flag = true
        this._strokeOpacity0_value = value
        return this
    }
    public fillOpacity(value: number | string | Resource | undefined): this {
        this._fillOpacity_flag = true
        this._fillOpacity0_value = value
        return this
    }
    public strokeWidth(value: Length | undefined): this {
        this._strokeWidth_flag = true
        this._strokeWidth0_value = value
        return this
    }
    public antiAlias(value: boolean | undefined): this {
        this._antiAlias_flag = true
        this._antiAlias0_value = value
        return this
    }
    public strokeDashArray(value: Array<Length> | undefined): this {
        this._strokeDashArray_flag = true
        this._strokeDashArray0_value = value
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export class ArkScrollableCommonMethodSet extends ArkCommonMethodSet implements ScrollableCommonMethod {
    _instanceId: number = -1;
    setInstanceId(instanceId: number): void {
        this._instanceId = instanceId
    }
    _scrollBar_flag?: boolean
    _scrollBar0_value?: BarState | undefined
    _scrollBarColor_flag?: boolean
    _scrollBarColor0_value?: Color | number | string | undefined
    _scrollBarWidth_flag?: boolean
    _scrollBarWidth0_value?: number | string | undefined
    _nestedScroll_flag?: boolean
    _nestedScroll0_value?: NestedScrollOptions | undefined
    _enableScrollInteraction_flag?: boolean
    _enableScrollInteraction0_value?: boolean | undefined
    _friction_flag?: boolean
    _friction0_value?: number | Resource | undefined
    _onReachStart_flag?: boolean
    _onReachStart0_value?: (() => void) | undefined
    _onReachEnd_flag?: boolean
    _onReachEnd0_value?: (() => void) | undefined
    _onScrollStart_flag?: boolean
    _onScrollStart0_value?: (() => void) | undefined
    _onScrollStop_flag?: boolean
    _onScrollStop0_value?: (() => void) | undefined
    _flingSpeedLimit_flag?: boolean
    _flingSpeedLimit0_value?: number | undefined
    _clipContent_flag?: boolean
    _clipContent0_value?: ContentClipMode | RectShape | undefined
    _digitalCrownSensitivity_flag?: boolean
    _digitalCrownSensitivity0_value?: CrownSensitivity | undefined
    _backToTop_flag?: boolean
    _backToTop0_value?: boolean | undefined
    _edgeEffect_flag?: boolean
    _edgeEffect0_value?: EdgeEffect | undefined
    _edgeEffect1_value?: EdgeEffectOptions | undefined
    _fadingEdge_flag?: boolean
    _fadingEdge0_value?: boolean | undefined
    _fadingEdge1_value?: FadingEdgeOptions | undefined
    applyModifierPatch(component: ScrollableCommonMethod): void {
        if (this._scrollBar_flag)
            component.scrollBar((this._scrollBar0_value as BarState | undefined))
        if (this._scrollBarColor_flag)
            component.scrollBarColor((this._scrollBarColor0_value as Color | number | string | undefined))
        if (this._scrollBarWidth_flag)
            component.scrollBarWidth((this._scrollBarWidth0_value as number | string | undefined))
        if (this._nestedScroll_flag)
            component.nestedScroll((this._nestedScroll0_value as NestedScrollOptions | undefined))
        if (this._enableScrollInteraction_flag)
            component.enableScrollInteraction((this._enableScrollInteraction0_value as boolean | undefined))
        if (this._friction_flag)
            component.friction((this._friction0_value as number | Resource | undefined))
        if (this._onReachStart_flag)
            component.onReachStart((this._onReachStart0_value as (() => void) | undefined))
        if (this._onReachEnd_flag)
            component.onReachEnd((this._onReachEnd0_value as (() => void) | undefined))
        if (this._onScrollStart_flag)
            component.onScrollStart((this._onScrollStart0_value as (() => void) | undefined))
        if (this._onScrollStop_flag)
            component.onScrollStop((this._onScrollStop0_value as (() => void) | undefined))
        if (this._flingSpeedLimit_flag)
            component.flingSpeedLimit((this._flingSpeedLimit0_value as number | undefined))
        if (this._clipContent_flag)
            component.clipContent((this._clipContent0_value as ContentClipMode | RectShape | undefined))
        if (this._digitalCrownSensitivity_flag)
            component.digitalCrownSensitivity((this._digitalCrownSensitivity0_value as CrownSensitivity | undefined))
        if (this._backToTop_flag)
            component.backToTop((this._backToTop0_value as boolean | undefined))
        if (this._edgeEffect_flag)
            component.edgeEffect((this._edgeEffect0_value as EdgeEffect | undefined), (this._edgeEffect1_value as EdgeEffectOptions | undefined))
        if (this._fadingEdge_flag)
            component.fadingEdge((this._fadingEdge0_value as boolean | undefined), (this._fadingEdge1_value as FadingEdgeOptions | undefined))
    }
    public scrollBar(value: BarState | undefined): this {
        this._scrollBar_flag = true
        this._scrollBar0_value = value
        return this
    }
    public scrollBarColor(value: Color | number | string | undefined): this {
        this._scrollBarColor_flag = true
        this._scrollBarColor0_value = value
        return this
    }
    public scrollBarWidth(value: number | string | undefined): this {
        this._scrollBarWidth_flag = true
        this._scrollBarWidth0_value = value
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        this._nestedScroll_flag = true
        this._nestedScroll0_value = value
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        this._enableScrollInteraction_flag = true
        this._enableScrollInteraction0_value = value
        return this
    }
    public friction(value: number | Resource | undefined): this {
        this._friction_flag = true
        this._friction0_value = value
        return this
    }
    public onReachStart(value: (() => void) | undefined): this {
        this._onReachStart_flag = true
        this._onReachStart0_value = value
        return this
    }
    public onReachEnd(value: (() => void) | undefined): this {
        this._onReachEnd_flag = true
        this._onReachEnd0_value = value
        return this
    }
    public onScrollStart(value: (() => void) | undefined): this {
        this._onScrollStart_flag = true
        this._onScrollStart0_value = value
        return this
    }
    public onScrollStop(value: (() => void) | undefined): this {
        this._onScrollStop_flag = true
        this._onScrollStop0_value = value
        return this
    }
    public flingSpeedLimit(value: number | undefined): this {
        this._flingSpeedLimit_flag = true
        this._flingSpeedLimit0_value = value
        return this
    }
    public clipContent(value: ContentClipMode | RectShape | undefined): this {
        this._clipContent_flag = true
        this._clipContent0_value = value
        return this
    }
    public digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        this._digitalCrownSensitivity_flag = true
        this._digitalCrownSensitivity0_value = value
        return this
    }
    public backToTop(value: boolean | undefined): this {
        this._backToTop_flag = true
        this._backToTop0_value = value
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        this._edgeEffect_flag = true
        this._edgeEffect0_value = edgeEffect
        this._edgeEffect1_value = options
        return this
    }
    public fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        this._fadingEdge_flag = true
        this._fadingEdge0_value = enabled
        this._fadingEdge1_value = options
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export function postCardAction(component: Object, action: Object): void {
    GlobalScope.postCardAction(component, action)
}
export function $r(value: string, params: Array<Object | undefined>): Resource {
    return GlobalScope.$r(value, params)
}
export function $rawfile(value: string): Resource {
    return GlobalScope.$rawfile(value)
}
export function animateTo(value: AnimateParam, event: (() => void)): void {
    GlobalScope.animateTo(value, event)
}
export function animateToImmediately(value: AnimateParam, event: (() => void)): void {
    GlobalScope.animateToImmediately(value, event)
}
export function vp2px(value: number): number {
    return GlobalScope.vp2px(value)
}
export function px2vp(value: number): number {
    return GlobalScope.px2vp(value)
}
export function applyStyles<T>(self: T, customStyles: CustomStyles): T {
    return GlobalScope.applyStyles(self, customStyles)
}
export class GestureModifier_serializer {
    public static write(buffer: SerializerBase, value: GestureModifier): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): GestureModifier {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return GestureModifierInternal.fromPtr(ptr)
    }
}
export class LayoutPolicy_serializer {
    public static write(buffer: SerializerBase, value: LayoutPolicy): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): LayoutPolicy {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutPolicyInternal.fromPtr(ptr)
    }
}
export class NestedScrollOptions_serializer {
    public static write(buffer: SerializerBase, value: NestedScrollOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_scrollForward  = value.scrollForward
        valueSerializer.writeInt32(TypeChecker.NestedScrollMode_ToNumeric(value_scrollForward))
        const value_scrollBackward  = value.scrollBackward
        valueSerializer.writeInt32(TypeChecker.NestedScrollMode_ToNumeric(value_scrollBackward))
    }
    public static read(buffer: DeserializerBase): NestedScrollOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scrollForward_result : NestedScrollMode = TypeChecker.NestedScrollMode_FromNumeric(valueDeserializer.readInt32())
        const scrollBackward_result : NestedScrollMode = TypeChecker.NestedScrollMode_FromNumeric(valueDeserializer.readInt32())
        let value : NestedScrollOptions = ({scrollForward: scrollForward_result, scrollBackward: scrollBackward_result} as NestedScrollOptions)
        return value
    }
}
export class PixelMapMock_serializer {
    public static write(buffer: SerializerBase, value: PixelMapMock): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): PixelMapMock {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return PixelMapMockInternal.fromPtr(ptr)
    }
}
export class PopupStateChangeParam_serializer {
    public static write(buffer: SerializerBase, value: PopupStateChangeParam): void {
        let valueSerializer : SerializerBase = buffer
        const value_isVisible  = value.isVisible
        valueSerializer.writeBoolean(value_isVisible)
    }
    public static read(buffer: DeserializerBase): PopupStateChangeParam {
        let valueDeserializer : DeserializerBase = buffer
        const isVisible_result : boolean = valueDeserializer.readBoolean()
        let value : PopupStateChangeParam = ({isVisible: isVisible_result} as PopupStateChangeParam)
        return value
    }
}
export class ProgressMask_serializer {
    public static write(buffer: SerializerBase, value: ProgressMask): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ProgressMask {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ProgressMaskInternal.fromPtr(ptr)
    }
}
export class RectResult_serializer {
    public static write(buffer: SerializerBase, value: RectResult): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
        const value_width  = value.width
        valueSerializer.writeNumber(value_width)
        const value_height  = value.height
        valueSerializer.writeNumber(value_height)
    }
    public static read(buffer: DeserializerBase): RectResult {
        let valueDeserializer : DeserializerBase = buffer
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        const width_result : number = (valueDeserializer.readNumber() as number)
        const height_result : number = (valueDeserializer.readNumber() as number)
        let value : RectResult = ({x: x_result, y: y_result, width: width_result, height: height_result} as RectResult)
        return value
    }
}
export class ScrollResult_serializer {
    public static write(buffer: SerializerBase, value: ScrollResult): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ScrollResult {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ScrollResultInternal.fromPtr(ptr)
    }
}
export class SizeResult_serializer {
    public static write(buffer: SerializerBase, value: SizeResult): void {
        let valueSerializer : SerializerBase = buffer
        const value_width  = value.width
        valueSerializer.writeNumber(value_width)
        const value_height  = value.height
        valueSerializer.writeNumber(value_height)
    }
    public static read(buffer: DeserializerBase): SizeResult {
        let valueDeserializer : DeserializerBase = buffer
        const width_result : number = (valueDeserializer.readNumber() as number)
        const height_result : number = (valueDeserializer.readNumber() as number)
        let value : SizeResult = ({width: width_result, height: height_result} as SizeResult)
        return value
    }
}
export class TextContentControllerBase_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerBase): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TextContentControllerBase {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TextContentControllerBaseInternal.fromPtr(ptr)
    }
}
export class TouchTestInfo_serializer {
    public static write(buffer: SerializerBase, value: TouchTestInfo): void {
        let valueSerializer : SerializerBase = buffer
        const value_windowX  = value.windowX
        valueSerializer.writeNumber(value_windowX)
        const value_windowY  = value.windowY
        valueSerializer.writeNumber(value_windowY)
        const value_parentX  = value.parentX
        valueSerializer.writeNumber(value_parentX)
        const value_parentY  = value.parentY
        valueSerializer.writeNumber(value_parentY)
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
        const value_rect  = value.rect
        RectResult_serializer.write(valueSerializer, value_rect)
        const value_id  = value.id
        valueSerializer.writeString(value_id)
    }
    public static read(buffer: DeserializerBase): TouchTestInfo {
        let valueDeserializer : DeserializerBase = buffer
        const windowX_result : number = (valueDeserializer.readNumber() as number)
        const windowY_result : number = (valueDeserializer.readNumber() as number)
        const parentX_result : number = (valueDeserializer.readNumber() as number)
        const parentY_result : number = (valueDeserializer.readNumber() as number)
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        const rect_result : RectResult = RectResult_serializer.read(valueDeserializer)
        const id_result : string = (valueDeserializer.readString() as string)
        let value : TouchTestInfo = ({windowX: windowX_result, windowY: windowY_result, parentX: parentX_result, parentY: parentY_result, x: x_result, y: y_result, rect: rect_result, id: id_result} as TouchTestInfo)
        return value
    }
}
export class UICommonEvent_serializer {
    public static write(buffer: SerializerBase, value: UICommonEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): UICommonEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return UICommonEventInternal.fromPtr(ptr)
    }
}
export class UIGestureEvent_serializer {
    public static write(buffer: SerializerBase, value: UIGestureEvent): void {
    }
    public static read(buffer: DeserializerBase): UIGestureEvent {
        throw new Error("Interface with functions is not supported")
    }
}
export class AlignRuleOption_serializer {
    public static write(buffer: SerializerBase, value: AlignRuleOption): void {
        let valueSerializer : SerializerBase = buffer
        const value__stub  = value._stub
        valueSerializer.writeInt32(value__stub)
    }
    public static read(buffer: DeserializerBase): AlignRuleOption {
        let valueDeserializer : DeserializerBase = buffer
        const _stub_result : int32 = valueDeserializer.readInt32()
        let value : AlignRuleOption = ({_stub: _stub_result} as AlignRuleOption)
        return value
    }
}
export class BackgroundBrightnessOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBrightnessOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_rate  = value.rate
        valueSerializer.writeNumber(value_rate)
        const value_lightUpDegree  = value.lightUpDegree
        valueSerializer.writeNumber(value_lightUpDegree)
    }
    public static read(buffer: DeserializerBase): BackgroundBrightnessOptions {
        let valueDeserializer : DeserializerBase = buffer
        const rate_result : number = (valueDeserializer.readNumber() as number)
        const lightUpDegree_result : number = (valueDeserializer.readNumber() as number)
        let value : BackgroundBrightnessOptions = ({rate: rate_result, lightUpDegree: lightUpDegree_result} as BackgroundBrightnessOptions)
        return value
    }
}
export class BackgroundImageOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundImageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_syncLoad  = value.syncLoad
        let value_syncLoad_type : int32 = RuntimeType.UNDEFINED
        value_syncLoad_type = runtimeType(value_syncLoad)
        valueSerializer.writeInt8((value_syncLoad_type).toChar())
        if ((value_syncLoad_type) != (RuntimeType.UNDEFINED)) {
            const value_syncLoad_value  = value_syncLoad!
            valueSerializer.writeBoolean(value_syncLoad_value)
        }
        const value_repeat  = value.repeat
        let value_repeat_type : int32 = RuntimeType.UNDEFINED
        value_repeat_type = runtimeType(value_repeat)
        valueSerializer.writeInt8((value_repeat_type).toChar())
        if ((value_repeat_type) != (RuntimeType.UNDEFINED)) {
            const value_repeat_value  = (value_repeat as ImageRepeat)
            valueSerializer.writeInt32(TypeChecker.ImageRepeat_ToNumeric(value_repeat_value))
        }
    }
    public static read(buffer: DeserializerBase): BackgroundImageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const syncLoad_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let syncLoad_buf : boolean | undefined
        if ((syncLoad_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            syncLoad_buf = valueDeserializer.readBoolean()
        }
        const syncLoad_result : boolean | undefined = syncLoad_buf
        const repeat_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeat_buf : ImageRepeat | undefined
        if ((repeat_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            repeat_buf = TypeChecker.ImageRepeat_FromNumeric(valueDeserializer.readInt32())
        }
        const repeat_result : ImageRepeat | undefined = repeat_buf
        let value : BackgroundImageOptions = ({syncLoad: syncLoad_result, repeat: repeat_result} as BackgroundImageOptions)
        return value
    }
}
export class BackgroundOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_align  = value.align
        let value_align_type : int32 = RuntimeType.UNDEFINED
        value_align_type = runtimeType(value_align)
        valueSerializer.writeInt8((value_align_type).toChar())
        if ((value_align_type) != (RuntimeType.UNDEFINED)) {
            const value_align_value  = (value_align as Alignment)
            valueSerializer.writeInt32(TypeChecker.Alignment_ToNumeric(value_align_value))
        }
    }
    public static read(buffer: DeserializerBase): BackgroundOptions {
        let valueDeserializer : DeserializerBase = buffer
        const align_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let align_buf : Alignment | undefined
        if ((align_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            align_buf = TypeChecker.Alignment_FromNumeric(valueDeserializer.readInt32())
        }
        const align_result : Alignment | undefined = align_buf
        let value : BackgroundOptions = ({align: align_result} as BackgroundOptions)
        return value
    }
}
export class BlurOptions_serializer {
    public static write(buffer: SerializerBase, value: BlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_grayscale  = value.grayscale
        const value_grayscale_0  = value_grayscale[0]
        valueSerializer.writeNumber(value_grayscale_0)
        const value_grayscale_1  = value_grayscale[1]
        valueSerializer.writeNumber(value_grayscale_1)
    }
    public static read(buffer: DeserializerBase): BlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const grayscale_buf_value0 : number = (valueDeserializer.readNumber() as number)
        const grayscale_buf_value1 : number = (valueDeserializer.readNumber() as number)
        const grayscale_result : [ number, number ] = ([grayscale_buf_value0, grayscale_buf_value1] as [ number, number ])
        let value : BlurOptions = ({grayscale: grayscale_result} as BlurOptions)
        return value
    }
}
export class CaretOffset_serializer {
    public static write(buffer: SerializerBase, value: CaretOffset): void {
        let valueSerializer : SerializerBase = buffer
        const value_index  = value.index
        valueSerializer.writeNumber(value_index)
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
    }
    public static read(buffer: DeserializerBase): CaretOffset {
        let valueDeserializer : DeserializerBase = buffer
        const index_result : number = (valueDeserializer.readNumber() as number)
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        let value : CaretOffset = ({index: index_result, x: x_result, y: y_result} as CaretOffset)
        return value
    }
}
export class ChildrenMainSize_serializer {
    public static write(buffer: SerializerBase, value: ChildrenMainSize): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ChildrenMainSize {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ChildrenMainSizeInternal.fromPtr(ptr)
    }
}
export class ClickEffect_serializer {
    public static write(buffer: SerializerBase, value: ClickEffect): void {
        let valueSerializer : SerializerBase = buffer
        const value_level  = value.level
        valueSerializer.writeInt32(TypeChecker.ClickEffectLevel_ToNumeric(value_level))
        const value_scale  = value.scale
        let value_scale_type : int32 = RuntimeType.UNDEFINED
        value_scale_type = runtimeType(value_scale)
        valueSerializer.writeInt8((value_scale_type).toChar())
        if ((value_scale_type) != (RuntimeType.UNDEFINED)) {
            const value_scale_value  = value_scale!
            valueSerializer.writeNumber(value_scale_value)
        }
    }
    public static read(buffer: DeserializerBase): ClickEffect {
        let valueDeserializer : DeserializerBase = buffer
        const level_result : ClickEffectLevel = TypeChecker.ClickEffectLevel_FromNumeric(valueDeserializer.readInt32())
        const scale_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scale_buf : number | undefined
        if ((scale_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            scale_buf = (valueDeserializer.readNumber() as number)
        }
        const scale_result : number | undefined = scale_buf
        let value : ClickEffect = ({level: level_result, scale: scale_result} as ClickEffect)
        return value
    }
}
export class CrownEvent_serializer {
    public static write(buffer: SerializerBase, value: CrownEvent): void {
        let valueSerializer : SerializerBase = buffer
        const value_timestamp  = value.timestamp
        valueSerializer.writeInt64(value_timestamp)
        const value_angularVelocity  = value.angularVelocity
        valueSerializer.writeNumber(value_angularVelocity)
        const value_degree  = value.degree
        valueSerializer.writeNumber(value_degree)
        const value_action  = value.action
        valueSerializer.writeInt32(TypeChecker.CrownAction_ToNumeric(value_action))
        const value_stopPropagation  = value.stopPropagation
        valueSerializer.holdAndWriteCallback(value_stopPropagation)
    }
    public static read(buffer: DeserializerBase): CrownEvent {
        let valueDeserializer : DeserializerBase = buffer
        const timestamp_result : int64 = valueDeserializer.readInt64()
        const angularVelocity_result : number = (valueDeserializer.readNumber() as number)
        const degree_result : number = (valueDeserializer.readNumber() as number)
        const action_result : CrownAction = TypeChecker.CrownAction_FromNumeric(valueDeserializer.readInt32())
        const stopPropagation_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const stopPropagation_buf_call : KPointer = valueDeserializer.readPointer()
        const stopPropagation_buf_callSync : KPointer = valueDeserializer.readPointer()
        const stopPropagation_result : (() => void) = ():void => { 
    const stopPropagation_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    stopPropagation_buf_argsSerializer.writeInt32(stopPropagation_buf_resource.resourceId);
    stopPropagation_buf_argsSerializer.writePointer(stopPropagation_buf_call);
    stopPropagation_buf_argsSerializer.writePointer(stopPropagation_buf_callSync);
    InteropNativeModule._CallCallback(-1867723152, stopPropagation_buf_argsSerializer.asBuffer(), stopPropagation_buf_argsSerializer.length());
    stopPropagation_buf_argsSerializer.release();
    return; }
        let value : CrownEvent = ({timestamp: timestamp_result, angularVelocity: angularVelocity_result, degree: degree_result, action: action_result, stopPropagation: stopPropagation_result} as CrownEvent)
        return value
    }
}
export class DateRange_serializer {
    public static write(buffer: SerializerBase, value: DateRange): void {
        let valueSerializer : SerializerBase = buffer
        const value_start  = value.start
        let value_start_type : int32 = RuntimeType.UNDEFINED
        value_start_type = runtimeType(value_start)
        valueSerializer.writeInt8((value_start_type).toChar())
        if ((value_start_type) != (RuntimeType.UNDEFINED)) {
            const value_start_value  = value_start!
            valueSerializer.writeInt64(value_start_value.getTime().toLong())
        }
        const value_end  = value.end
        let value_end_type : int32 = RuntimeType.UNDEFINED
        value_end_type = runtimeType(value_end)
        valueSerializer.writeInt8((value_end_type).toChar())
        if ((value_end_type) != (RuntimeType.UNDEFINED)) {
            const value_end_value  = value_end!
            valueSerializer.writeInt64(value_end_value.getTime().toLong())
        }
    }
    public static read(buffer: DeserializerBase): DateRange {
        let valueDeserializer : DeserializerBase = buffer
        const start_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let start_buf : Date | undefined
        if ((start_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            start_buf = new Date(valueDeserializer.readInt64())
        }
        const start_result : Date | undefined = start_buf
        const end_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let end_buf : Date | undefined
        if ((end_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            end_buf = new Date(valueDeserializer.readInt64())
        }
        const end_result : Date | undefined = end_buf
        let value : DateRange = ({start: start_result, end: end_result} as DateRange)
        return value
    }
}
export class DismissContentCoverAction_serializer {
    public static write(buffer: SerializerBase, value: DismissContentCoverAction): void {
        let valueSerializer : SerializerBase = buffer
        const value_dismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(value_dismiss)
        const value_reason  = value.reason
        valueSerializer.writeInt32(TypeChecker.DismissReason_ToNumeric(value_reason))
    }
    public static read(buffer: DeserializerBase): DismissContentCoverAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismiss_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismiss_buf_call : KPointer = valueDeserializer.readPointer()
        const dismiss_buf_callSync : KPointer = valueDeserializer.readPointer()
        const dismiss_result : VoidCallback = ():void => { 
    const dismiss_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    dismiss_buf_argsSerializer.writeInt32(dismiss_buf_resource.resourceId);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_call);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_callSync);
    InteropNativeModule._CallCallback(-2038961969, dismiss_buf_argsSerializer.asBuffer(), dismiss_buf_argsSerializer.length());
    dismiss_buf_argsSerializer.release();
    return; }
        const reason_result : DismissReason = TypeChecker.DismissReason_FromNumeric(valueDeserializer.readInt32())
        let value : DismissContentCoverAction = ({dismiss: dismiss_result, reason: reason_result} as DismissContentCoverAction)
        return value
    }
}
export class DismissPopupAction_serializer {
    public static write(buffer: SerializerBase, value: DismissPopupAction): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DismissPopupAction {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DismissPopupActionInternal.fromPtr(ptr)
    }
}
export class DismissSheetAction_serializer {
    public static write(buffer: SerializerBase, value: DismissSheetAction): void {
        let valueSerializer : SerializerBase = buffer
        const value_dismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(value_dismiss)
        const value_reason  = value.reason
        valueSerializer.writeInt32(TypeChecker.DismissReason_ToNumeric(value_reason))
    }
    public static read(buffer: DeserializerBase): DismissSheetAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismiss_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismiss_buf_call : KPointer = valueDeserializer.readPointer()
        const dismiss_buf_callSync : KPointer = valueDeserializer.readPointer()
        const dismiss_result : VoidCallback = ():void => { 
    const dismiss_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    dismiss_buf_argsSerializer.writeInt32(dismiss_buf_resource.resourceId);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_call);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_callSync);
    InteropNativeModule._CallCallback(-2038961969, dismiss_buf_argsSerializer.asBuffer(), dismiss_buf_argsSerializer.length());
    dismiss_buf_argsSerializer.release();
    return; }
        const reason_result : DismissReason = TypeChecker.DismissReason_FromNumeric(valueDeserializer.readInt32())
        let value : DismissSheetAction = ({dismiss: dismiss_result, reason: reason_result} as DismissSheetAction)
        return value
    }
}
export class DragEvent_serializer {
    public static write(buffer: SerializerBase, value: DragEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DragEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DragEventInternal.fromPtr(ptr)
    }
}
export class DragInteractionOptions_serializer {
    public static write(buffer: SerializerBase, value: DragInteractionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_isMultiSelectionEnabled  = value.isMultiSelectionEnabled
        let value_isMultiSelectionEnabled_type : int32 = RuntimeType.UNDEFINED
        value_isMultiSelectionEnabled_type = runtimeType(value_isMultiSelectionEnabled)
        valueSerializer.writeInt8((value_isMultiSelectionEnabled_type).toChar())
        if ((value_isMultiSelectionEnabled_type) != (RuntimeType.UNDEFINED)) {
            const value_isMultiSelectionEnabled_value  = value_isMultiSelectionEnabled!
            valueSerializer.writeBoolean(value_isMultiSelectionEnabled_value)
        }
        const value_defaultAnimationBeforeLifting  = value.defaultAnimationBeforeLifting
        let value_defaultAnimationBeforeLifting_type : int32 = RuntimeType.UNDEFINED
        value_defaultAnimationBeforeLifting_type = runtimeType(value_defaultAnimationBeforeLifting)
        valueSerializer.writeInt8((value_defaultAnimationBeforeLifting_type).toChar())
        if ((value_defaultAnimationBeforeLifting_type) != (RuntimeType.UNDEFINED)) {
            const value_defaultAnimationBeforeLifting_value  = value_defaultAnimationBeforeLifting!
            valueSerializer.writeBoolean(value_defaultAnimationBeforeLifting_value)
        }
        const value_enableEdgeAutoScroll  = value.enableEdgeAutoScroll
        let value_enableEdgeAutoScroll_type : int32 = RuntimeType.UNDEFINED
        value_enableEdgeAutoScroll_type = runtimeType(value_enableEdgeAutoScroll)
        valueSerializer.writeInt8((value_enableEdgeAutoScroll_type).toChar())
        if ((value_enableEdgeAutoScroll_type) != (RuntimeType.UNDEFINED)) {
            const value_enableEdgeAutoScroll_value  = value_enableEdgeAutoScroll!
            valueSerializer.writeBoolean(value_enableEdgeAutoScroll_value)
        }
        const value_enableHapticFeedback  = value.enableHapticFeedback
        let value_enableHapticFeedback_type : int32 = RuntimeType.UNDEFINED
        value_enableHapticFeedback_type = runtimeType(value_enableHapticFeedback)
        valueSerializer.writeInt8((value_enableHapticFeedback_type).toChar())
        if ((value_enableHapticFeedback_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHapticFeedback_value  = value_enableHapticFeedback!
            valueSerializer.writeBoolean(value_enableHapticFeedback_value)
        }
        const value_isLiftingDisabled  = value.isLiftingDisabled
        let value_isLiftingDisabled_type : int32 = RuntimeType.UNDEFINED
        value_isLiftingDisabled_type = runtimeType(value_isLiftingDisabled)
        valueSerializer.writeInt8((value_isLiftingDisabled_type).toChar())
        if ((value_isLiftingDisabled_type) != (RuntimeType.UNDEFINED)) {
            const value_isLiftingDisabled_value  = value_isLiftingDisabled!
            valueSerializer.writeBoolean(value_isLiftingDisabled_value)
        }
    }
    public static read(buffer: DeserializerBase): DragInteractionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const isMultiSelectionEnabled_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let isMultiSelectionEnabled_buf : boolean | undefined
        if ((isMultiSelectionEnabled_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            isMultiSelectionEnabled_buf = valueDeserializer.readBoolean()
        }
        const isMultiSelectionEnabled_result : boolean | undefined = isMultiSelectionEnabled_buf
        const defaultAnimationBeforeLifting_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let defaultAnimationBeforeLifting_buf : boolean | undefined
        if ((defaultAnimationBeforeLifting_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            defaultAnimationBeforeLifting_buf = valueDeserializer.readBoolean()
        }
        const defaultAnimationBeforeLifting_result : boolean | undefined = defaultAnimationBeforeLifting_buf
        const enableEdgeAutoScroll_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableEdgeAutoScroll_buf : boolean | undefined
        if ((enableEdgeAutoScroll_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableEdgeAutoScroll_buf = valueDeserializer.readBoolean()
        }
        const enableEdgeAutoScroll_result : boolean | undefined = enableEdgeAutoScroll_buf
        const enableHapticFeedback_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHapticFeedback_buf : boolean | undefined
        if ((enableHapticFeedback_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHapticFeedback_buf = valueDeserializer.readBoolean()
        }
        const enableHapticFeedback_result : boolean | undefined = enableHapticFeedback_buf
        const isLiftingDisabled_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let isLiftingDisabled_buf : boolean | undefined
        if ((isLiftingDisabled_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            isLiftingDisabled_buf = valueDeserializer.readBoolean()
        }
        const isLiftingDisabled_result : boolean | undefined = isLiftingDisabled_buf
        let value : DragInteractionOptions = ({isMultiSelectionEnabled: isMultiSelectionEnabled_result, defaultAnimationBeforeLifting: defaultAnimationBeforeLifting_result, enableEdgeAutoScroll: enableEdgeAutoScroll_result, enableHapticFeedback: enableHapticFeedback_result, isLiftingDisabled: isLiftingDisabled_result} as DragInteractionOptions)
        return value
    }
}
export class DragItemInfo_serializer {
    public static write(buffer: SerializerBase, value: DragItemInfo): void {
        let valueSerializer : SerializerBase = buffer
        const value_pixelMap  = value.pixelMap
        let value_pixelMap_type : int32 = RuntimeType.UNDEFINED
        value_pixelMap_type = runtimeType(value_pixelMap)
        valueSerializer.writeInt8((value_pixelMap_type).toChar())
        if ((value_pixelMap_type) != (RuntimeType.UNDEFINED)) {
            const value_pixelMap_value  = value_pixelMap!
            image_PixelMap_serializer.write(valueSerializer, value_pixelMap_value)
        }
        const value_builder  = value.builder
        let value_builder_type : int32 = RuntimeType.UNDEFINED
        value_builder_type = runtimeType(value_builder)
        valueSerializer.writeInt8((value_builder_type).toChar())
        if ((value_builder_type) != (RuntimeType.UNDEFINED)) {
            const value_builder_value  = value_builder!
            valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_builder_value))
        }
        const value_extraInfo  = value.extraInfo
        let value_extraInfo_type : int32 = RuntimeType.UNDEFINED
        value_extraInfo_type = runtimeType(value_extraInfo)
        valueSerializer.writeInt8((value_extraInfo_type).toChar())
        if ((value_extraInfo_type) != (RuntimeType.UNDEFINED)) {
            const value_extraInfo_value  = value_extraInfo!
            valueSerializer.writeString(value_extraInfo_value)
        }
    }
    public static read(buffer: DeserializerBase): DragItemInfo {
        let valueDeserializer : DeserializerBase = buffer
        const pixelMap_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pixelMap_buf : image.PixelMap | undefined
        if ((pixelMap_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            pixelMap_buf = (image_PixelMap_serializer.read(valueDeserializer) as image.PixelMap)
        }
        const pixelMap_result : image.PixelMap | undefined = pixelMap_buf
        const builder_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let builder_buf : CustomBuilder | undefined
        if ((builder_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const builder_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const builder_buf__call : KPointer = valueDeserializer.readPointer()
            const builder_buf__callSync : KPointer = valueDeserializer.readPointer()
            builder_buf = ():void => { 
    const builder_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    builder_buf__argsSerializer.writeInt32(builder_buf__resource.resourceId);
    builder_buf__argsSerializer.writePointer(builder_buf__call);
    builder_buf__argsSerializer.writePointer(builder_buf__callSync);
    InteropNativeModule._CallCallback(737226752, builder_buf__argsSerializer.asBuffer(), builder_buf__argsSerializer.length());
    builder_buf__argsSerializer.release();
    return; }
        }
        const builder_result : CustomBuilder | undefined = builder_buf
        const extraInfo_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let extraInfo_buf : string | undefined
        if ((extraInfo_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            extraInfo_buf = (valueDeserializer.readString() as string)
        }
        const extraInfo_result : string | undefined = extraInfo_buf
        let value : DragItemInfo = ({pixelMap: pixelMap_result, builder: builder_result, extraInfo: extraInfo_result} as DragItemInfo)
        return value
    }
}
export class DrawModifier_serializer {
    public static write(buffer: SerializerBase, value: DrawModifier): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DrawModifier {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DrawModifierInternal.fromPtr(ptr)
    }
}
export class DropOptions_serializer {
    public static write(buffer: SerializerBase, value: DropOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_disableDataPrefetch  = value.disableDataPrefetch
        let value_disableDataPrefetch_type : int32 = RuntimeType.UNDEFINED
        value_disableDataPrefetch_type = runtimeType(value_disableDataPrefetch)
        valueSerializer.writeInt8((value_disableDataPrefetch_type).toChar())
        if ((value_disableDataPrefetch_type) != (RuntimeType.UNDEFINED)) {
            const value_disableDataPrefetch_value  = value_disableDataPrefetch!
            valueSerializer.writeBoolean(value_disableDataPrefetch_value)
        }
    }
    public static read(buffer: DeserializerBase): DropOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableDataPrefetch_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disableDataPrefetch_buf : boolean | undefined
        if ((disableDataPrefetch_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            disableDataPrefetch_buf = valueDeserializer.readBoolean()
        }
        const disableDataPrefetch_result : boolean | undefined = disableDataPrefetch_buf
        let value : DropOptions = ({disableDataPrefetch: disableDataPrefetch_result} as DropOptions)
        return value
    }
}
export class EdgeEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: EdgeEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_alwaysEnabled  = value.alwaysEnabled
        valueSerializer.writeBoolean(value_alwaysEnabled)
        const value_effectEdge  = value.effectEdge
        let value_effectEdge_type : int32 = RuntimeType.UNDEFINED
        value_effectEdge_type = runtimeType(value_effectEdge)
        valueSerializer.writeInt8((value_effectEdge_type).toChar())
        if ((value_effectEdge_type) != (RuntimeType.UNDEFINED)) {
            const value_effectEdge_value  = value_effectEdge!
            valueSerializer.writeNumber(value_effectEdge_value)
        }
    }
    public static read(buffer: DeserializerBase): EdgeEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alwaysEnabled_result : boolean = valueDeserializer.readBoolean()
        const effectEdge_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let effectEdge_buf : number | undefined
        if ((effectEdge_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            effectEdge_buf = (valueDeserializer.readNumber() as number)
        }
        const effectEdge_result : number | undefined = effectEdge_buf
        let value : EdgeEffectOptions = ({alwaysEnabled: alwaysEnabled_result, effectEdge: effectEdge_result} as EdgeEffectOptions)
        return value
    }
}
export class ExpectedFrameRateRange_serializer {
    public static write(buffer: SerializerBase, value: ExpectedFrameRateRange): void {
        let valueSerializer : SerializerBase = buffer
        const value_min  = value.min
        valueSerializer.writeNumber(value_min)
        const value_max  = value.max
        valueSerializer.writeNumber(value_max)
        const value_expected  = value.expected
        valueSerializer.writeNumber(value_expected)
    }
    public static read(buffer: DeserializerBase): ExpectedFrameRateRange {
        let valueDeserializer : DeserializerBase = buffer
        const min_result : number = (valueDeserializer.readNumber() as number)
        const max_result : number = (valueDeserializer.readNumber() as number)
        const expected_result : number = (valueDeserializer.readNumber() as number)
        let value : ExpectedFrameRateRange = ({min: min_result, max: max_result, expected: expected_result} as ExpectedFrameRateRange)
        return value
    }
}
export class FocusMovement_serializer {
    public static write(buffer: SerializerBase, value: FocusMovement): void {
        let valueSerializer : SerializerBase = buffer
        const value_forward  = value.forward
        let value_forward_type : int32 = RuntimeType.UNDEFINED
        value_forward_type = runtimeType(value_forward)
        valueSerializer.writeInt8((value_forward_type).toChar())
        if ((value_forward_type) != (RuntimeType.UNDEFINED)) {
            const value_forward_value  = value_forward!
            valueSerializer.writeString(value_forward_value)
        }
        const value_backward  = value.backward
        let value_backward_type : int32 = RuntimeType.UNDEFINED
        value_backward_type = runtimeType(value_backward)
        valueSerializer.writeInt8((value_backward_type).toChar())
        if ((value_backward_type) != (RuntimeType.UNDEFINED)) {
            const value_backward_value  = value_backward!
            valueSerializer.writeString(value_backward_value)
        }
        const value_up  = value.up
        let value_up_type : int32 = RuntimeType.UNDEFINED
        value_up_type = runtimeType(value_up)
        valueSerializer.writeInt8((value_up_type).toChar())
        if ((value_up_type) != (RuntimeType.UNDEFINED)) {
            const value_up_value  = value_up!
            valueSerializer.writeString(value_up_value)
        }
        const value_down  = value.down
        let value_down_type : int32 = RuntimeType.UNDEFINED
        value_down_type = runtimeType(value_down)
        valueSerializer.writeInt8((value_down_type).toChar())
        if ((value_down_type) != (RuntimeType.UNDEFINED)) {
            const value_down_value  = value_down!
            valueSerializer.writeString(value_down_value)
        }
        const value_left  = value.left
        let value_left_type : int32 = RuntimeType.UNDEFINED
        value_left_type = runtimeType(value_left)
        valueSerializer.writeInt8((value_left_type).toChar())
        if ((value_left_type) != (RuntimeType.UNDEFINED)) {
            const value_left_value  = value_left!
            valueSerializer.writeString(value_left_value)
        }
        const value_right  = value.right
        let value_right_type : int32 = RuntimeType.UNDEFINED
        value_right_type = runtimeType(value_right)
        valueSerializer.writeInt8((value_right_type).toChar())
        if ((value_right_type) != (RuntimeType.UNDEFINED)) {
            const value_right_value  = value_right!
            valueSerializer.writeString(value_right_value)
        }
    }
    public static read(buffer: DeserializerBase): FocusMovement {
        let valueDeserializer : DeserializerBase = buffer
        const forward_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let forward_buf : string | undefined
        if ((forward_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            forward_buf = (valueDeserializer.readString() as string)
        }
        const forward_result : string | undefined = forward_buf
        const backward_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backward_buf : string | undefined
        if ((backward_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backward_buf = (valueDeserializer.readString() as string)
        }
        const backward_result : string | undefined = backward_buf
        const up_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let up_buf : string | undefined
        if ((up_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            up_buf = (valueDeserializer.readString() as string)
        }
        const up_result : string | undefined = up_buf
        const down_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let down_buf : string | undefined
        if ((down_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            down_buf = (valueDeserializer.readString() as string)
        }
        const down_result : string | undefined = down_buf
        const left_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let left_buf : string | undefined
        if ((left_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            left_buf = (valueDeserializer.readString() as string)
        }
        const left_result : string | undefined = left_buf
        const right_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let right_buf : string | undefined
        if ((right_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            right_buf = (valueDeserializer.readString() as string)
        }
        const right_result : string | undefined = right_buf
        let value : FocusMovement = ({forward: forward_result, backward: backward_result, up: up_result, down: down_result, left: left_result, right: right_result} as FocusMovement)
        return value
    }
}
export class ForegroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_radius  = value.radius
        valueSerializer.writeNumber(value_radius)
    }
    public static read(buffer: DeserializerBase): ForegroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radius_result : number = (valueDeserializer.readNumber() as number)
        let value : ForegroundEffectOptions = ({radius: radius_result} as ForegroundEffectOptions)
        return value
    }
}
export class GeometryTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: GeometryTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_follow  = value.follow
        let value_follow_type : int32 = RuntimeType.UNDEFINED
        value_follow_type = runtimeType(value_follow)
        valueSerializer.writeInt8((value_follow_type).toChar())
        if ((value_follow_type) != (RuntimeType.UNDEFINED)) {
            const value_follow_value  = value_follow!
            valueSerializer.writeBoolean(value_follow_value)
        }
        const value_hierarchyStrategy  = value.hierarchyStrategy
        let value_hierarchyStrategy_type : int32 = RuntimeType.UNDEFINED
        value_hierarchyStrategy_type = runtimeType(value_hierarchyStrategy)
        valueSerializer.writeInt8((value_hierarchyStrategy_type).toChar())
        if ((value_hierarchyStrategy_type) != (RuntimeType.UNDEFINED)) {
            const value_hierarchyStrategy_value  = (value_hierarchyStrategy as TransitionHierarchyStrategy)
            valueSerializer.writeInt32(TypeChecker.TransitionHierarchyStrategy_ToNumeric(value_hierarchyStrategy_value))
        }
    }
    public static read(buffer: DeserializerBase): GeometryTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const follow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let follow_buf : boolean | undefined
        if ((follow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            follow_buf = valueDeserializer.readBoolean()
        }
        const follow_result : boolean | undefined = follow_buf
        const hierarchyStrategy_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hierarchyStrategy_buf : TransitionHierarchyStrategy | undefined
        if ((hierarchyStrategy_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            hierarchyStrategy_buf = TypeChecker.TransitionHierarchyStrategy_FromNumeric(valueDeserializer.readInt32())
        }
        const hierarchyStrategy_result : TransitionHierarchyStrategy | undefined = hierarchyStrategy_buf
        let value : GeometryTransitionOptions = ({follow: follow_result, hierarchyStrategy: hierarchyStrategy_result} as GeometryTransitionOptions)
        return value
    }
}
export class InputCounterOptions_serializer {
    public static write(buffer: SerializerBase, value: InputCounterOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_thresholdPercentage  = value.thresholdPercentage
        let value_thresholdPercentage_type : int32 = RuntimeType.UNDEFINED
        value_thresholdPercentage_type = runtimeType(value_thresholdPercentage)
        valueSerializer.writeInt8((value_thresholdPercentage_type).toChar())
        if ((value_thresholdPercentage_type) != (RuntimeType.UNDEFINED)) {
            const value_thresholdPercentage_value  = value_thresholdPercentage!
            valueSerializer.writeNumber(value_thresholdPercentage_value)
        }
        const value_highlightBorder  = value.highlightBorder
        let value_highlightBorder_type : int32 = RuntimeType.UNDEFINED
        value_highlightBorder_type = runtimeType(value_highlightBorder)
        valueSerializer.writeInt8((value_highlightBorder_type).toChar())
        if ((value_highlightBorder_type) != (RuntimeType.UNDEFINED)) {
            const value_highlightBorder_value  = value_highlightBorder!
            valueSerializer.writeBoolean(value_highlightBorder_value)
        }
    }
    public static read(buffer: DeserializerBase): InputCounterOptions {
        let valueDeserializer : DeserializerBase = buffer
        const thresholdPercentage_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let thresholdPercentage_buf : number | undefined
        if ((thresholdPercentage_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            thresholdPercentage_buf = (valueDeserializer.readNumber() as number)
        }
        const thresholdPercentage_result : number | undefined = thresholdPercentage_buf
        const highlightBorder_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let highlightBorder_buf : boolean | undefined
        if ((highlightBorder_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            highlightBorder_buf = valueDeserializer.readBoolean()
        }
        const highlightBorder_result : boolean | undefined = highlightBorder_buf
        let value : InputCounterOptions = ({thresholdPercentage: thresholdPercentage_result, highlightBorder: highlightBorder_result} as InputCounterOptions)
        return value
    }
}
export class InvertOptions_serializer {
    public static write(buffer: SerializerBase, value: InvertOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_low  = value.low
        valueSerializer.writeNumber(value_low)
        const value_high  = value.high
        valueSerializer.writeNumber(value_high)
        const value_threshold  = value.threshold
        valueSerializer.writeNumber(value_threshold)
        const value_thresholdRange  = value.thresholdRange
        valueSerializer.writeNumber(value_thresholdRange)
    }
    public static read(buffer: DeserializerBase): InvertOptions {
        let valueDeserializer : DeserializerBase = buffer
        const low_result : number = (valueDeserializer.readNumber() as number)
        const high_result : number = (valueDeserializer.readNumber() as number)
        const threshold_result : number = (valueDeserializer.readNumber() as number)
        const thresholdRange_result : number = (valueDeserializer.readNumber() as number)
        let value : InvertOptions = ({low: low_result, high: high_result, threshold: threshold_result, thresholdRange: thresholdRange_result} as InvertOptions)
        return value
    }
}
export class ItemDragInfo_serializer {
    public static write(buffer: SerializerBase, value: ItemDragInfo): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
    }
    public static read(buffer: DeserializerBase): ItemDragInfo {
        let valueDeserializer : DeserializerBase = buffer
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        let value : ItemDragInfo = ({x: x_result, y: y_result} as ItemDragInfo)
        return value
    }
}
export class KeyEvent_serializer {
    public static write(buffer: SerializerBase, value: KeyEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): KeyEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return KeyEventInternal.fromPtr(ptr)
    }
}
export class LinearGradientBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_fractionStops  = value.fractionStops
        valueSerializer.writeInt32((value_fractionStops.length).toInt())
        for (let value_fractionStops_counter_i = 0; value_fractionStops_counter_i < value_fractionStops.length; value_fractionStops_counter_i++) {
            const value_fractionStops_element : FractionStop = value_fractionStops[value_fractionStops_counter_i]
            const value_fractionStops_element_0  = value_fractionStops_element[0]
            valueSerializer.writeNumber(value_fractionStops_element_0)
            const value_fractionStops_element_1  = value_fractionStops_element[1]
            valueSerializer.writeNumber(value_fractionStops_element_1)
        }
        const value_direction  = value.direction
        valueSerializer.writeInt32(TypeChecker.GradientDirection_ToNumeric(value_direction))
    }
    public static read(buffer: DeserializerBase): LinearGradientBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fractionStops_buf_length : int32 = valueDeserializer.readInt32()
        let fractionStops_buf : Array<FractionStop> = new Array<FractionStop>(fractionStops_buf_length)
        for (let fractionStops_buf_i = 0; fractionStops_buf_i < fractionStops_buf_length; fractionStops_buf_i++) {
            const fractionStops_buf_buf_value0 : number = (valueDeserializer.readNumber() as number)
            const fractionStops_buf_buf_value1 : number = (valueDeserializer.readNumber() as number)
            fractionStops_buf[fractionStops_buf_i] = ([fractionStops_buf_buf_value0, fractionStops_buf_buf_value1] as FractionStop)
        }
        const fractionStops_result : Array<FractionStop> = fractionStops_buf
        const direction_result : GradientDirection = TypeChecker.GradientDirection_FromNumeric(valueDeserializer.readInt32())
        let value : LinearGradientBlurOptions = ({fractionStops: fractionStops_result, direction: direction_result} as LinearGradientBlurOptions)
        return value
    }
}
export class LinearGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_angle  = value.angle
        let value_angle_type : int32 = RuntimeType.UNDEFINED
        value_angle_type = runtimeType(value_angle)
        valueSerializer.writeInt8((value_angle_type).toChar())
        if ((value_angle_type) != (RuntimeType.UNDEFINED)) {
            const value_angle_value  = value_angle!
            let value_angle_value_type : int32 = RuntimeType.UNDEFINED
            value_angle_value_type = runtimeType(value_angle_value)
            if (RuntimeType.NUMBER == value_angle_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_angle_value_0  = value_angle_value as number
                valueSerializer.writeNumber(value_angle_value_0)
            }
            else if (RuntimeType.STRING == value_angle_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_angle_value_1  = value_angle_value as string
                valueSerializer.writeString(value_angle_value_1)
            }
        }
        const value_direction  = value.direction
        let value_direction_type : int32 = RuntimeType.UNDEFINED
        value_direction_type = runtimeType(value_direction)
        valueSerializer.writeInt8((value_direction_type).toChar())
        if ((value_direction_type) != (RuntimeType.UNDEFINED)) {
            const value_direction_value  = (value_direction as GradientDirection)
            valueSerializer.writeInt32(TypeChecker.GradientDirection_ToNumeric(value_direction_value))
        }
        const value_colors  = value.colors
        valueSerializer.writeInt32((value_colors.length).toInt())
        for (let value_colors_counter_i = 0; value_colors_counter_i < value_colors.length; value_colors_counter_i++) {
            const value_colors_element : [ ResourceColor, number ] = value_colors[value_colors_counter_i]
            const value_colors_element_0  = value_colors_element[0]
            let value_colors_element_0_type : int32 = RuntimeType.UNDEFINED
            value_colors_element_0_type = runtimeType(value_colors_element_0)
            if (TypeChecker.isColor(value_colors_element_0)) {
                valueSerializer.writeInt8((0).toChar())
                const value_colors_element_0_0  = value_colors_element_0 as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_colors_element_0_0))
            }
            else if (RuntimeType.NUMBER == value_colors_element_0_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_colors_element_0_1  = value_colors_element_0 as number
                valueSerializer.writeNumber(value_colors_element_0_1)
            }
            else if (RuntimeType.STRING == value_colors_element_0_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_colors_element_0_2  = value_colors_element_0 as string
                valueSerializer.writeString(value_colors_element_0_2)
            }
            else if (RuntimeType.OBJECT == value_colors_element_0_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_colors_element_0_3  = value_colors_element_0 as Resource
                Resource_serializer.write(valueSerializer, value_colors_element_0_3)
            }
            const value_colors_element_1  = value_colors_element[1]
            valueSerializer.writeNumber(value_colors_element_1)
        }
        const value_repeating  = value.repeating
        let value_repeating_type : int32 = RuntimeType.UNDEFINED
        value_repeating_type = runtimeType(value_repeating)
        valueSerializer.writeInt8((value_repeating_type).toChar())
        if ((value_repeating_type) != (RuntimeType.UNDEFINED)) {
            const value_repeating_value  = value_repeating!
            valueSerializer.writeBoolean(value_repeating_value)
        }
    }
    public static read(buffer: DeserializerBase): LinearGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const angle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let angle_buf : number | string | undefined
        if ((angle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const angle_buf__selector : int32 = valueDeserializer.readInt8()
            let angle_buf_ : number | string | undefined
            if (angle_buf__selector == (0).toChar()) {
                angle_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (angle_buf__selector == (1).toChar()) {
                angle_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for angle_buf_ has to be chosen through deserialisation.")
            }
            angle_buf = (angle_buf_ as number | string)
        }
        const angle_result : number | string | undefined = angle_buf
        const direction_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let direction_buf : GradientDirection | undefined
        if ((direction_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            direction_buf = TypeChecker.GradientDirection_FromNumeric(valueDeserializer.readInt32())
        }
        const direction_result : GradientDirection | undefined = direction_buf
        const colors_buf_length : int32 = valueDeserializer.readInt32()
        let colors_buf : Array<[ ResourceColor, number ]> = new Array<[ ResourceColor, number ]>(colors_buf_length)
        for (let colors_buf_i = 0; colors_buf_i < colors_buf_length; colors_buf_i++) {
            const colors_buf_buf_value0_buf_selector : int32 = valueDeserializer.readInt8()
            let colors_buf_buf_value0_buf : Color | number | string | Resource | undefined
            if (colors_buf_buf_value0_buf_selector == (0).toChar()) {
                colors_buf_buf_value0_buf = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (colors_buf_buf_value0_buf_selector == (1).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readNumber() as number)
            }
            else if (colors_buf_buf_value0_buf_selector == (2).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readString() as string)
            }
            else if (colors_buf_buf_value0_buf_selector == (3).toChar()) {
                colors_buf_buf_value0_buf = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for colors_buf_buf_value0_buf has to be chosen through deserialisation.")
            }
            const colors_buf_buf_value0 : ResourceColor = (colors_buf_buf_value0_buf as Color | number | string | Resource)
            const colors_buf_buf_value1 : number = (valueDeserializer.readNumber() as number)
            colors_buf[colors_buf_i] = ([colors_buf_buf_value0, colors_buf_buf_value1] as [ ResourceColor, number ])
        }
        const colors_result : Array<[ ResourceColor, number ]> = colors_buf
        const repeating_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeating_buf : boolean | undefined
        if ((repeating_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            repeating_buf = valueDeserializer.readBoolean()
        }
        const repeating_result : boolean | undefined = repeating_buf
        let value : LinearGradientOptions = ({angle: angle_result, direction: direction_result, colors: colors_result, repeating: repeating_result} as LinearGradientOptions)
        return value
    }
}
export class LocalizedHorizontalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedHorizontalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const value_anchor  = value.anchor
        valueSerializer.writeString(value_anchor)
        const value_align  = value.align
        valueSerializer.writeInt32(TypeChecker.HorizontalAlign_ToNumeric(value_align))
    }
    public static read(buffer: DeserializerBase): LocalizedHorizontalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchor_result : string = (valueDeserializer.readString() as string)
        const align_result : HorizontalAlign = TypeChecker.HorizontalAlign_FromNumeric(valueDeserializer.readInt32())
        let value : LocalizedHorizontalAlignParam = ({anchor: anchor_result, align: align_result} as LocalizedHorizontalAlignParam)
        return value
    }
}
export class LocalizedVerticalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedVerticalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const value_anchor  = value.anchor
        valueSerializer.writeString(value_anchor)
        const value_align  = value.align
        valueSerializer.writeInt32(TypeChecker.VerticalAlign_ToNumeric(value_align))
    }
    public static read(buffer: DeserializerBase): LocalizedVerticalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchor_result : string = (valueDeserializer.readString() as string)
        const align_result : VerticalAlign = TypeChecker.VerticalAlign_FromNumeric(valueDeserializer.readInt32())
        let value : LocalizedVerticalAlignParam = ({anchor: anchor_result, align: align_result} as LocalizedVerticalAlignParam)
        return value
    }
}
export class Measurable_serializer {
    public static write(buffer: SerializerBase, value: Measurable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Measurable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MeasurableInternal.fromPtr(ptr)
    }
}
export class MeasureResult_serializer {
    public static write(buffer: SerializerBase, value: MeasureResult): void {
        let valueSerializer : SerializerBase = buffer
        const value_width  = value.width
        valueSerializer.writeNumber(value_width)
        const value_height  = value.height
        valueSerializer.writeNumber(value_height)
    }
    public static read(buffer: DeserializerBase): MeasureResult {
        let valueDeserializer : DeserializerBase = buffer
        const width_result : number = (valueDeserializer.readNumber() as number)
        const height_result : number = (valueDeserializer.readNumber() as number)
        let value : MeasureResult = ({width: width_result, height: height_result} as MeasureResult)
        return value
    }
}
export class MotionBlurAnchor_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurAnchor): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
    }
    public static read(buffer: DeserializerBase): MotionBlurAnchor {
        let valueDeserializer : DeserializerBase = buffer
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        let value : MotionBlurAnchor = ({x: x_result, y: y_result} as MotionBlurAnchor)
        return value
    }
}
export class MotionBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_radius  = value.radius
        valueSerializer.writeNumber(value_radius)
        const value_anchor  = value.anchor
        MotionBlurAnchor_serializer.write(valueSerializer, value_anchor)
    }
    public static read(buffer: DeserializerBase): MotionBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radius_result : number = (valueDeserializer.readNumber() as number)
        const anchor_result : MotionBlurAnchor = MotionBlurAnchor_serializer.read(valueDeserializer)
        let value : MotionBlurOptions = ({radius: radius_result, anchor: anchor_result} as MotionBlurOptions)
        return value
    }
}
export class MotionPathOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionPathOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_path  = value.path
        valueSerializer.writeString(value_path)
        const value_from  = value.from
        let value_from_type : int32 = RuntimeType.UNDEFINED
        value_from_type = runtimeType(value_from)
        valueSerializer.writeInt8((value_from_type).toChar())
        if ((value_from_type) != (RuntimeType.UNDEFINED)) {
            const value_from_value  = value_from!
            valueSerializer.writeNumber(value_from_value)
        }
        const value_to  = value.to
        let value_to_type : int32 = RuntimeType.UNDEFINED
        value_to_type = runtimeType(value_to)
        valueSerializer.writeInt8((value_to_type).toChar())
        if ((value_to_type) != (RuntimeType.UNDEFINED)) {
            const value_to_value  = value_to!
            valueSerializer.writeNumber(value_to_value)
        }
        const value_rotatable  = value.rotatable
        let value_rotatable_type : int32 = RuntimeType.UNDEFINED
        value_rotatable_type = runtimeType(value_rotatable)
        valueSerializer.writeInt8((value_rotatable_type).toChar())
        if ((value_rotatable_type) != (RuntimeType.UNDEFINED)) {
            const value_rotatable_value  = value_rotatable!
            valueSerializer.writeBoolean(value_rotatable_value)
        }
    }
    public static read(buffer: DeserializerBase): MotionPathOptions {
        let valueDeserializer : DeserializerBase = buffer
        const path_result : string = (valueDeserializer.readString() as string)
        const from_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let from_buf : number | undefined
        if ((from_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            from_buf = (valueDeserializer.readNumber() as number)
        }
        const from_result : number | undefined = from_buf
        const to_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let to_buf : number | undefined
        if ((to_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            to_buf = (valueDeserializer.readNumber() as number)
        }
        const to_result : number | undefined = to_buf
        const rotatable_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rotatable_buf : boolean | undefined
        if ((rotatable_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            rotatable_buf = valueDeserializer.readBoolean()
        }
        const rotatable_result : boolean | undefined = rotatable_buf
        let value : MotionPathOptions = ({path: path_result, from: from_result, to: to_result, rotatable: rotatable_result} as MotionPathOptions)
        return value
    }
}
export class OverlayOffset_serializer {
    public static write(buffer: SerializerBase, value: OverlayOffset): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        let value_x_type : int32 = RuntimeType.UNDEFINED
        value_x_type = runtimeType(value_x)
        valueSerializer.writeInt8((value_x_type).toChar())
        if ((value_x_type) != (RuntimeType.UNDEFINED)) {
            const value_x_value  = value_x!
            valueSerializer.writeNumber(value_x_value)
        }
        const value_y  = value.y
        let value_y_type : int32 = RuntimeType.UNDEFINED
        value_y_type = runtimeType(value_y)
        valueSerializer.writeInt8((value_y_type).toChar())
        if ((value_y_type) != (RuntimeType.UNDEFINED)) {
            const value_y_value  = value_y!
            valueSerializer.writeNumber(value_y_value)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOffset {
        let valueDeserializer : DeserializerBase = buffer
        const x_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let x_buf : number | undefined
        if ((x_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            x_buf = (valueDeserializer.readNumber() as number)
        }
        const x_result : number | undefined = x_buf
        const y_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let y_buf : number | undefined
        if ((y_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            y_buf = (valueDeserializer.readNumber() as number)
        }
        const y_result : number | undefined = y_buf
        let value : OverlayOffset = ({x: x_result, y: y_result} as OverlayOffset)
        return value
    }
}
export class PixelRoundPolicy_serializer {
    public static write(buffer: SerializerBase, value: PixelRoundPolicy): void {
        let valueSerializer : SerializerBase = buffer
        const value_start  = value.start
        let value_start_type : int32 = RuntimeType.UNDEFINED
        value_start_type = runtimeType(value_start)
        valueSerializer.writeInt8((value_start_type).toChar())
        if ((value_start_type) != (RuntimeType.UNDEFINED)) {
            const value_start_value  = (value_start as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(TypeChecker.PixelRoundCalcPolicy_ToNumeric(value_start_value))
        }
        const value_top  = value.top
        let value_top_type : int32 = RuntimeType.UNDEFINED
        value_top_type = runtimeType(value_top)
        valueSerializer.writeInt8((value_top_type).toChar())
        if ((value_top_type) != (RuntimeType.UNDEFINED)) {
            const value_top_value  = (value_top as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(TypeChecker.PixelRoundCalcPolicy_ToNumeric(value_top_value))
        }
        const value_end  = value.end
        let value_end_type : int32 = RuntimeType.UNDEFINED
        value_end_type = runtimeType(value_end)
        valueSerializer.writeInt8((value_end_type).toChar())
        if ((value_end_type) != (RuntimeType.UNDEFINED)) {
            const value_end_value  = (value_end as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(TypeChecker.PixelRoundCalcPolicy_ToNumeric(value_end_value))
        }
        const value_bottom  = value.bottom
        let value_bottom_type : int32 = RuntimeType.UNDEFINED
        value_bottom_type = runtimeType(value_bottom)
        valueSerializer.writeInt8((value_bottom_type).toChar())
        if ((value_bottom_type) != (RuntimeType.UNDEFINED)) {
            const value_bottom_value  = (value_bottom as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(TypeChecker.PixelRoundCalcPolicy_ToNumeric(value_bottom_value))
        }
    }
    public static read(buffer: DeserializerBase): PixelRoundPolicy {
        let valueDeserializer : DeserializerBase = buffer
        const start_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let start_buf : PixelRoundCalcPolicy | undefined
        if ((start_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            start_buf = TypeChecker.PixelRoundCalcPolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const start_result : PixelRoundCalcPolicy | undefined = start_buf
        const top_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let top_buf : PixelRoundCalcPolicy | undefined
        if ((top_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            top_buf = TypeChecker.PixelRoundCalcPolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const top_result : PixelRoundCalcPolicy | undefined = top_buf
        const end_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let end_buf : PixelRoundCalcPolicy | undefined
        if ((end_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            end_buf = TypeChecker.PixelRoundCalcPolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const end_result : PixelRoundCalcPolicy | undefined = end_buf
        const bottom_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottom_buf : PixelRoundCalcPolicy | undefined
        if ((bottom_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            bottom_buf = TypeChecker.PixelRoundCalcPolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const bottom_result : PixelRoundCalcPolicy | undefined = bottom_buf
        let value : PixelRoundPolicy = ({start: start_result, top: top_result, end: end_result, bottom: bottom_result} as PixelRoundPolicy)
        return value
    }
}
export class PopupButton_serializer {
    public static write(buffer: SerializerBase, value: PopupButton): void {
        let valueSerializer : SerializerBase = buffer
        const value_value  = value.value
        valueSerializer.writeString(value_value)
        const value_action  = value.action
        valueSerializer.holdAndWriteCallback(value_action)
    }
    public static read(buffer: DeserializerBase): PopupButton {
        let valueDeserializer : DeserializerBase = buffer
        const value_result : string = (valueDeserializer.readString() as string)
        const action_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const action_buf_call : KPointer = valueDeserializer.readPointer()
        const action_buf_callSync : KPointer = valueDeserializer.readPointer()
        const action_result : VoidCallback = ():void => { 
    const action_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    action_buf_argsSerializer.writeInt32(action_buf_resource.resourceId);
    action_buf_argsSerializer.writePointer(action_buf_call);
    action_buf_argsSerializer.writePointer(action_buf_callSync);
    InteropNativeModule._CallCallback(-2038961969, action_buf_argsSerializer.asBuffer(), action_buf_argsSerializer.length());
    action_buf_argsSerializer.release();
    return; }
        let value : PopupButton = ({value: value_result, action: action_result} as PopupButton)
        return value
    }
}
export class PreviewConfiguration_serializer {
    public static write(buffer: SerializerBase, value: PreviewConfiguration): void {
        let valueSerializer : SerializerBase = buffer
        const value_onlyForLifting  = value.onlyForLifting
        let value_onlyForLifting_type : int32 = RuntimeType.UNDEFINED
        value_onlyForLifting_type = runtimeType(value_onlyForLifting)
        valueSerializer.writeInt8((value_onlyForLifting_type).toChar())
        if ((value_onlyForLifting_type) != (RuntimeType.UNDEFINED)) {
            const value_onlyForLifting_value  = value_onlyForLifting!
            valueSerializer.writeBoolean(value_onlyForLifting_value)
        }
        const value_delayCreating  = value.delayCreating
        let value_delayCreating_type : int32 = RuntimeType.UNDEFINED
        value_delayCreating_type = runtimeType(value_delayCreating)
        valueSerializer.writeInt8((value_delayCreating_type).toChar())
        if ((value_delayCreating_type) != (RuntimeType.UNDEFINED)) {
            const value_delayCreating_value  = value_delayCreating!
            valueSerializer.writeBoolean(value_delayCreating_value)
        }
    }
    public static read(buffer: DeserializerBase): PreviewConfiguration {
        let valueDeserializer : DeserializerBase = buffer
        const onlyForLifting_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onlyForLifting_buf : boolean | undefined
        if ((onlyForLifting_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            onlyForLifting_buf = valueDeserializer.readBoolean()
        }
        const onlyForLifting_result : boolean | undefined = onlyForLifting_buf
        const delayCreating_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delayCreating_buf : boolean | undefined
        if ((delayCreating_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            delayCreating_buf = valueDeserializer.readBoolean()
        }
        const delayCreating_result : boolean | undefined = delayCreating_buf
        let value : PreviewConfiguration = ({onlyForLifting: onlyForLifting_result, delayCreating: delayCreating_result} as PreviewConfiguration)
        return value
    }
}
export class RotateOptions_serializer {
    public static write(buffer: SerializerBase, value: RotateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        let value_x_type : int32 = RuntimeType.UNDEFINED
        value_x_type = runtimeType(value_x)
        valueSerializer.writeInt8((value_x_type).toChar())
        if ((value_x_type) != (RuntimeType.UNDEFINED)) {
            const value_x_value  = value_x!
            valueSerializer.writeNumber(value_x_value)
        }
        const value_y  = value.y
        let value_y_type : int32 = RuntimeType.UNDEFINED
        value_y_type = runtimeType(value_y)
        valueSerializer.writeInt8((value_y_type).toChar())
        if ((value_y_type) != (RuntimeType.UNDEFINED)) {
            const value_y_value  = value_y!
            valueSerializer.writeNumber(value_y_value)
        }
        const value_z  = value.z
        let value_z_type : int32 = RuntimeType.UNDEFINED
        value_z_type = runtimeType(value_z)
        valueSerializer.writeInt8((value_z_type).toChar())
        if ((value_z_type) != (RuntimeType.UNDEFINED)) {
            const value_z_value  = value_z!
            valueSerializer.writeNumber(value_z_value)
        }
        const value_centerX  = value.centerX
        let value_centerX_type : int32 = RuntimeType.UNDEFINED
        value_centerX_type = runtimeType(value_centerX)
        valueSerializer.writeInt8((value_centerX_type).toChar())
        if ((value_centerX_type) != (RuntimeType.UNDEFINED)) {
            const value_centerX_value  = value_centerX!
            let value_centerX_value_type : int32 = RuntimeType.UNDEFINED
            value_centerX_value_type = runtimeType(value_centerX_value)
            if (RuntimeType.NUMBER == value_centerX_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_centerX_value_0  = value_centerX_value as number
                valueSerializer.writeNumber(value_centerX_value_0)
            }
            else if (RuntimeType.STRING == value_centerX_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_centerX_value_1  = value_centerX_value as string
                valueSerializer.writeString(value_centerX_value_1)
            }
        }
        const value_centerY  = value.centerY
        let value_centerY_type : int32 = RuntimeType.UNDEFINED
        value_centerY_type = runtimeType(value_centerY)
        valueSerializer.writeInt8((value_centerY_type).toChar())
        if ((value_centerY_type) != (RuntimeType.UNDEFINED)) {
            const value_centerY_value  = value_centerY!
            let value_centerY_value_type : int32 = RuntimeType.UNDEFINED
            value_centerY_value_type = runtimeType(value_centerY_value)
            if (RuntimeType.NUMBER == value_centerY_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_centerY_value_0  = value_centerY_value as number
                valueSerializer.writeNumber(value_centerY_value_0)
            }
            else if (RuntimeType.STRING == value_centerY_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_centerY_value_1  = value_centerY_value as string
                valueSerializer.writeString(value_centerY_value_1)
            }
        }
        const value_centerZ  = value.centerZ
        let value_centerZ_type : int32 = RuntimeType.UNDEFINED
        value_centerZ_type = runtimeType(value_centerZ)
        valueSerializer.writeInt8((value_centerZ_type).toChar())
        if ((value_centerZ_type) != (RuntimeType.UNDEFINED)) {
            const value_centerZ_value  = value_centerZ!
            valueSerializer.writeNumber(value_centerZ_value)
        }
        const value_perspective  = value.perspective
        let value_perspective_type : int32 = RuntimeType.UNDEFINED
        value_perspective_type = runtimeType(value_perspective)
        valueSerializer.writeInt8((value_perspective_type).toChar())
        if ((value_perspective_type) != (RuntimeType.UNDEFINED)) {
            const value_perspective_value  = value_perspective!
            valueSerializer.writeNumber(value_perspective_value)
        }
        const value_angle  = value.angle
        let value_angle_type : int32 = RuntimeType.UNDEFINED
        value_angle_type = runtimeType(value_angle)
        if (RuntimeType.NUMBER == value_angle_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_angle_0  = value_angle as number
            valueSerializer.writeNumber(value_angle_0)
        }
        else if (RuntimeType.STRING == value_angle_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_angle_1  = value_angle as string
            valueSerializer.writeString(value_angle_1)
        }
    }
    public static read(buffer: DeserializerBase): RotateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const x_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let x_buf : number | undefined
        if ((x_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            x_buf = (valueDeserializer.readNumber() as number)
        }
        const x_result : number | undefined = x_buf
        const y_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let y_buf : number | undefined
        if ((y_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            y_buf = (valueDeserializer.readNumber() as number)
        }
        const y_result : number | undefined = y_buf
        const z_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let z_buf : number | undefined
        if ((z_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            z_buf = (valueDeserializer.readNumber() as number)
        }
        const z_result : number | undefined = z_buf
        const centerX_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerX_buf : number | string | undefined
        if ((centerX_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const centerX_buf__selector : int32 = valueDeserializer.readInt8()
            let centerX_buf_ : number | string | undefined
            if (centerX_buf__selector == (0).toChar()) {
                centerX_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (centerX_buf__selector == (1).toChar()) {
                centerX_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for centerX_buf_ has to be chosen through deserialisation.")
            }
            centerX_buf = (centerX_buf_ as number | string)
        }
        const centerX_result : number | string | undefined = centerX_buf
        const centerY_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerY_buf : number | string | undefined
        if ((centerY_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const centerY_buf__selector : int32 = valueDeserializer.readInt8()
            let centerY_buf_ : number | string | undefined
            if (centerY_buf__selector == (0).toChar()) {
                centerY_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (centerY_buf__selector == (1).toChar()) {
                centerY_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for centerY_buf_ has to be chosen through deserialisation.")
            }
            centerY_buf = (centerY_buf_ as number | string)
        }
        const centerY_result : number | string | undefined = centerY_buf
        const centerZ_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerZ_buf : number | undefined
        if ((centerZ_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            centerZ_buf = (valueDeserializer.readNumber() as number)
        }
        const centerZ_result : number | undefined = centerZ_buf
        const perspective_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let perspective_buf : number | undefined
        if ((perspective_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            perspective_buf = (valueDeserializer.readNumber() as number)
        }
        const perspective_result : number | undefined = perspective_buf
        const angle_buf_selector : int32 = valueDeserializer.readInt8()
        let angle_buf : number | string | undefined
        if (angle_buf_selector == (0).toChar()) {
            angle_buf = (valueDeserializer.readNumber() as number)
        }
        else if (angle_buf_selector == (1).toChar()) {
            angle_buf = (valueDeserializer.readString() as string)
        }
        else {
            throw new Error("One of the branches for angle_buf has to be chosen through deserialisation.")
        }
        const angle_result : number | string = (angle_buf as number | string)
        let value : RotateOptions = ({x: x_result, y: y_result, z: z_result, centerX: centerX_result, centerY: centerY_result, centerZ: centerZ_result, perspective: perspective_result, angle: angle_result} as RotateOptions)
        return value
    }
}
export class ScaleOptions_serializer {
    public static write(buffer: SerializerBase, value: ScaleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        let value_x_type : int32 = RuntimeType.UNDEFINED
        value_x_type = runtimeType(value_x)
        valueSerializer.writeInt8((value_x_type).toChar())
        if ((value_x_type) != (RuntimeType.UNDEFINED)) {
            const value_x_value  = value_x!
            valueSerializer.writeNumber(value_x_value)
        }
        const value_y  = value.y
        let value_y_type : int32 = RuntimeType.UNDEFINED
        value_y_type = runtimeType(value_y)
        valueSerializer.writeInt8((value_y_type).toChar())
        if ((value_y_type) != (RuntimeType.UNDEFINED)) {
            const value_y_value  = value_y!
            valueSerializer.writeNumber(value_y_value)
        }
        const value_z  = value.z
        let value_z_type : int32 = RuntimeType.UNDEFINED
        value_z_type = runtimeType(value_z)
        valueSerializer.writeInt8((value_z_type).toChar())
        if ((value_z_type) != (RuntimeType.UNDEFINED)) {
            const value_z_value  = value_z!
            valueSerializer.writeNumber(value_z_value)
        }
        const value_centerX  = value.centerX
        let value_centerX_type : int32 = RuntimeType.UNDEFINED
        value_centerX_type = runtimeType(value_centerX)
        valueSerializer.writeInt8((value_centerX_type).toChar())
        if ((value_centerX_type) != (RuntimeType.UNDEFINED)) {
            const value_centerX_value  = value_centerX!
            let value_centerX_value_type : int32 = RuntimeType.UNDEFINED
            value_centerX_value_type = runtimeType(value_centerX_value)
            if (RuntimeType.NUMBER == value_centerX_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_centerX_value_0  = value_centerX_value as number
                valueSerializer.writeNumber(value_centerX_value_0)
            }
            else if (RuntimeType.STRING == value_centerX_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_centerX_value_1  = value_centerX_value as string
                valueSerializer.writeString(value_centerX_value_1)
            }
        }
        const value_centerY  = value.centerY
        let value_centerY_type : int32 = RuntimeType.UNDEFINED
        value_centerY_type = runtimeType(value_centerY)
        valueSerializer.writeInt8((value_centerY_type).toChar())
        if ((value_centerY_type) != (RuntimeType.UNDEFINED)) {
            const value_centerY_value  = value_centerY!
            let value_centerY_value_type : int32 = RuntimeType.UNDEFINED
            value_centerY_value_type = runtimeType(value_centerY_value)
            if (RuntimeType.NUMBER == value_centerY_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_centerY_value_0  = value_centerY_value as number
                valueSerializer.writeNumber(value_centerY_value_0)
            }
            else if (RuntimeType.STRING == value_centerY_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_centerY_value_1  = value_centerY_value as string
                valueSerializer.writeString(value_centerY_value_1)
            }
        }
    }
    public static read(buffer: DeserializerBase): ScaleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const x_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let x_buf : number | undefined
        if ((x_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            x_buf = (valueDeserializer.readNumber() as number)
        }
        const x_result : number | undefined = x_buf
        const y_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let y_buf : number | undefined
        if ((y_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            y_buf = (valueDeserializer.readNumber() as number)
        }
        const y_result : number | undefined = y_buf
        const z_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let z_buf : number | undefined
        if ((z_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            z_buf = (valueDeserializer.readNumber() as number)
        }
        const z_result : number | undefined = z_buf
        const centerX_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerX_buf : number | string | undefined
        if ((centerX_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const centerX_buf__selector : int32 = valueDeserializer.readInt8()
            let centerX_buf_ : number | string | undefined
            if (centerX_buf__selector == (0).toChar()) {
                centerX_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (centerX_buf__selector == (1).toChar()) {
                centerX_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for centerX_buf_ has to be chosen through deserialisation.")
            }
            centerX_buf = (centerX_buf_ as number | string)
        }
        const centerX_result : number | string | undefined = centerX_buf
        const centerY_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerY_buf : number | string | undefined
        if ((centerY_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const centerY_buf__selector : int32 = valueDeserializer.readInt8()
            let centerY_buf_ : number | string | undefined
            if (centerY_buf__selector == (0).toChar()) {
                centerY_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (centerY_buf__selector == (1).toChar()) {
                centerY_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for centerY_buf_ has to be chosen through deserialisation.")
            }
            centerY_buf = (centerY_buf_ as number | string)
        }
        const centerY_result : number | string | undefined = centerY_buf
        let value : ScaleOptions = ({x: x_result, y: y_result, z: z_result, centerX: centerX_result, centerY: centerY_result} as ScaleOptions)
        return value
    }
}
export class SelectionOptions_serializer {
    public static write(buffer: SerializerBase, value: SelectionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_menuPolicy  = value.menuPolicy
        let value_menuPolicy_type : int32 = RuntimeType.UNDEFINED
        value_menuPolicy_type = runtimeType(value_menuPolicy)
        valueSerializer.writeInt8((value_menuPolicy_type).toChar())
        if ((value_menuPolicy_type) != (RuntimeType.UNDEFINED)) {
            const value_menuPolicy_value  = (value_menuPolicy as MenuPolicy)
            valueSerializer.writeInt32(TypeChecker.MenuPolicy_ToNumeric(value_menuPolicy_value))
        }
    }
    public static read(buffer: DeserializerBase): SelectionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const menuPolicy_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let menuPolicy_buf : MenuPolicy | undefined
        if ((menuPolicy_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            menuPolicy_buf = TypeChecker.MenuPolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const menuPolicy_result : MenuPolicy | undefined = menuPolicy_buf
        let value : SelectionOptions = ({menuPolicy: menuPolicy_result} as SelectionOptions)
        return value
    }
}
export class SheetDismiss_serializer {
    public static write(buffer: SerializerBase, value: SheetDismiss): void {
        let valueSerializer : SerializerBase = buffer
        const value_dismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(value_dismiss)
    }
    public static read(buffer: DeserializerBase): SheetDismiss {
        let valueDeserializer : DeserializerBase = buffer
        const dismiss_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismiss_buf_call : KPointer = valueDeserializer.readPointer()
        const dismiss_buf_callSync : KPointer = valueDeserializer.readPointer()
        const dismiss_result : VoidCallback = ():void => { 
    const dismiss_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    dismiss_buf_argsSerializer.writeInt32(dismiss_buf_resource.resourceId);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_call);
    dismiss_buf_argsSerializer.writePointer(dismiss_buf_callSync);
    InteropNativeModule._CallCallback(-2038961969, dismiss_buf_argsSerializer.asBuffer(), dismiss_buf_argsSerializer.length());
    dismiss_buf_argsSerializer.release();
    return; }
        let value : SheetDismiss = ({dismiss: dismiss_result} as SheetDismiss)
        return value
    }
}
export class SpringBackAction_serializer {
    public static write(buffer: SerializerBase, value: SpringBackAction): void {
        let valueSerializer : SerializerBase = buffer
        const value_springBack  = value.springBack
        valueSerializer.holdAndWriteCallback(value_springBack)
    }
    public static read(buffer: DeserializerBase): SpringBackAction {
        let valueDeserializer : DeserializerBase = buffer
        const springBack_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const springBack_buf_call : KPointer = valueDeserializer.readPointer()
        const springBack_buf_callSync : KPointer = valueDeserializer.readPointer()
        const springBack_result : VoidCallback = ():void => { 
    const springBack_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    springBack_buf_argsSerializer.writeInt32(springBack_buf_resource.resourceId);
    springBack_buf_argsSerializer.writePointer(springBack_buf_call);
    springBack_buf_argsSerializer.writePointer(springBack_buf_callSync);
    InteropNativeModule._CallCallback(-2038961969, springBack_buf_argsSerializer.asBuffer(), springBack_buf_argsSerializer.length());
    springBack_buf_argsSerializer.release();
    return; }
        let value : SpringBackAction = ({springBack: springBack_result} as SpringBackAction)
        return value
    }
}
export class SystemAdaptiveOptions_serializer {
    public static write(buffer: SerializerBase, value: SystemAdaptiveOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_disableSystemAdaptation  = value.disableSystemAdaptation
        let value_disableSystemAdaptation_type : int32 = RuntimeType.UNDEFINED
        value_disableSystemAdaptation_type = runtimeType(value_disableSystemAdaptation)
        valueSerializer.writeInt8((value_disableSystemAdaptation_type).toChar())
        if ((value_disableSystemAdaptation_type) != (RuntimeType.UNDEFINED)) {
            const value_disableSystemAdaptation_value  = value_disableSystemAdaptation!
            valueSerializer.writeBoolean(value_disableSystemAdaptation_value)
        }
    }
    public static read(buffer: DeserializerBase): SystemAdaptiveOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableSystemAdaptation_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disableSystemAdaptation_buf : boolean | undefined
        if ((disableSystemAdaptation_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            disableSystemAdaptation_buf = valueDeserializer.readBoolean()
        }
        const disableSystemAdaptation_result : boolean | undefined = disableSystemAdaptation_buf
        let value : SystemAdaptiveOptions = ({disableSystemAdaptation: disableSystemAdaptation_result} as SystemAdaptiveOptions)
        return value
    }
}
export class TextContentControllerOptions_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            valueSerializer.writeNumber(value_offset_value)
        }
    }
    public static read(buffer: DeserializerBase): TextContentControllerOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : number | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = (valueDeserializer.readNumber() as number)
        }
        const offset_result : number | undefined = offset_buf
        let value : TextContentControllerOptions = ({offset: offset_result} as TextContentControllerOptions)
        return value
    }
}
export class TouchObject_serializer {
    public static write(buffer: SerializerBase, value: TouchObject): void {
        let valueSerializer : SerializerBase = buffer
        const value_type  = value.type
        valueSerializer.writeInt32(TypeChecker.TouchType_ToNumeric(value_type))
        const value_id  = value.id
        valueSerializer.writeNumber(value_id)
        const value_displayX  = value.displayX
        valueSerializer.writeNumber(value_displayX)
        const value_displayY  = value.displayY
        valueSerializer.writeNumber(value_displayY)
        const value_windowX  = value.windowX
        valueSerializer.writeNumber(value_windowX)
        const value_windowY  = value.windowY
        valueSerializer.writeNumber(value_windowY)
        const value_x  = value.x
        valueSerializer.writeNumber(value_x)
        const value_y  = value.y
        valueSerializer.writeNumber(value_y)
        const value_hand  = value.hand
        let value_hand_type : int32 = RuntimeType.UNDEFINED
        value_hand_type = runtimeType(value_hand)
        valueSerializer.writeInt8((value_hand_type).toChar())
        if ((value_hand_type) != (RuntimeType.UNDEFINED)) {
            const value_hand_value  = (value_hand as InteractionHand)
            valueSerializer.writeInt32(TypeChecker.InteractionHand_ToNumeric(value_hand_value))
        }
        const value_pressedTime  = value.pressedTime
        let value_pressedTime_type : int32 = RuntimeType.UNDEFINED
        value_pressedTime_type = runtimeType(value_pressedTime)
        valueSerializer.writeInt8((value_pressedTime_type).toChar())
        if ((value_pressedTime_type) != (RuntimeType.UNDEFINED)) {
            const value_pressedTime_value  = value_pressedTime!
            valueSerializer.writeNumber(value_pressedTime_value)
        }
        const value_pressure  = value.pressure
        let value_pressure_type : int32 = RuntimeType.UNDEFINED
        value_pressure_type = runtimeType(value_pressure)
        valueSerializer.writeInt8((value_pressure_type).toChar())
        if ((value_pressure_type) != (RuntimeType.UNDEFINED)) {
            const value_pressure_value  = value_pressure!
            valueSerializer.writeNumber(value_pressure_value)
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            valueSerializer.writeNumber(value_width_value)
        }
        const value_height  = value.height
        let value_height_type : int32 = RuntimeType.UNDEFINED
        value_height_type = runtimeType(value_height)
        valueSerializer.writeInt8((value_height_type).toChar())
        if ((value_height_type) != (RuntimeType.UNDEFINED)) {
            const value_height_value  = value_height!
            valueSerializer.writeNumber(value_height_value)
        }
    }
    public static read(buffer: DeserializerBase): TouchObject {
        let valueDeserializer : DeserializerBase = buffer
        const type_result : TouchType = TypeChecker.TouchType_FromNumeric(valueDeserializer.readInt32())
        const id_result : number = (valueDeserializer.readNumber() as number)
        const displayX_result : number = (valueDeserializer.readNumber() as number)
        const displayY_result : number = (valueDeserializer.readNumber() as number)
        const windowX_result : number = (valueDeserializer.readNumber() as number)
        const windowY_result : number = (valueDeserializer.readNumber() as number)
        const x_result : number = (valueDeserializer.readNumber() as number)
        const y_result : number = (valueDeserializer.readNumber() as number)
        const hand_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hand_buf : InteractionHand | undefined
        if ((hand_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            hand_buf = TypeChecker.InteractionHand_FromNumeric(valueDeserializer.readInt32())
        }
        const hand_result : InteractionHand | undefined = hand_buf
        const pressedTime_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pressedTime_buf : number | undefined
        if ((pressedTime_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            pressedTime_buf = (valueDeserializer.readNumber() as number)
        }
        const pressedTime_result : number | undefined = pressedTime_buf
        const pressure_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pressure_buf : number | undefined
        if ((pressure_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            pressure_buf = (valueDeserializer.readNumber() as number)
        }
        const pressure_result : number | undefined = pressure_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : number | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            width_buf = (valueDeserializer.readNumber() as number)
        }
        const width_result : number | undefined = width_buf
        const height_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let height_buf : number | undefined
        if ((height_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            height_buf = (valueDeserializer.readNumber() as number)
        }
        const height_result : number | undefined = height_buf
        let value : TouchObject = ({type: type_result, id: id_result, displayX: displayX_result, displayY: displayY_result, windowX: windowX_result, windowY: windowY_result, x: x_result, y: y_result, hand: hand_result, pressedTime: pressedTime_result, pressure: pressure_result, width: width_result, height: height_result} as TouchObject)
        return value
    }
}
export class TouchResult_serializer {
    public static write(buffer: SerializerBase, value: TouchResult): void {
        let valueSerializer : SerializerBase = buffer
        const value_strategy  = value.strategy
        valueSerializer.writeInt32(TypeChecker.TouchTestStrategy_ToNumeric(value_strategy))
        const value_id  = value.id
        let value_id_type : int32 = RuntimeType.UNDEFINED
        value_id_type = runtimeType(value_id)
        valueSerializer.writeInt8((value_id_type).toChar())
        if ((value_id_type) != (RuntimeType.UNDEFINED)) {
            const value_id_value  = value_id!
            valueSerializer.writeString(value_id_value)
        }
    }
    public static read(buffer: DeserializerBase): TouchResult {
        let valueDeserializer : DeserializerBase = buffer
        const strategy_result : TouchTestStrategy = TypeChecker.TouchTestStrategy_FromNumeric(valueDeserializer.readInt32())
        const id_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let id_buf : string | undefined
        if ((id_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            id_buf = (valueDeserializer.readString() as string)
        }
        const id_result : string | undefined = id_buf
        let value : TouchResult = ({strategy: strategy_result, id: id_result} as TouchResult)
        return value
    }
}
export class TranslateOptions_serializer {
    public static write(buffer: SerializerBase, value: TranslateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        let value_x_type : int32 = RuntimeType.UNDEFINED
        value_x_type = runtimeType(value_x)
        valueSerializer.writeInt8((value_x_type).toChar())
        if ((value_x_type) != (RuntimeType.UNDEFINED)) {
            const value_x_value  = value_x!
            let value_x_value_type : int32 = RuntimeType.UNDEFINED
            value_x_value_type = runtimeType(value_x_value)
            if (RuntimeType.NUMBER == value_x_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_x_value_0  = value_x_value as number
                valueSerializer.writeNumber(value_x_value_0)
            }
            else if (RuntimeType.STRING == value_x_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_x_value_1  = value_x_value as string
                valueSerializer.writeString(value_x_value_1)
            }
        }
        const value_y  = value.y
        let value_y_type : int32 = RuntimeType.UNDEFINED
        value_y_type = runtimeType(value_y)
        valueSerializer.writeInt8((value_y_type).toChar())
        if ((value_y_type) != (RuntimeType.UNDEFINED)) {
            const value_y_value  = value_y!
            let value_y_value_type : int32 = RuntimeType.UNDEFINED
            value_y_value_type = runtimeType(value_y_value)
            if (RuntimeType.NUMBER == value_y_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_y_value_0  = value_y_value as number
                valueSerializer.writeNumber(value_y_value_0)
            }
            else if (RuntimeType.STRING == value_y_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_y_value_1  = value_y_value as string
                valueSerializer.writeString(value_y_value_1)
            }
        }
        const value_z  = value.z
        let value_z_type : int32 = RuntimeType.UNDEFINED
        value_z_type = runtimeType(value_z)
        valueSerializer.writeInt8((value_z_type).toChar())
        if ((value_z_type) != (RuntimeType.UNDEFINED)) {
            const value_z_value  = value_z!
            let value_z_value_type : int32 = RuntimeType.UNDEFINED
            value_z_value_type = runtimeType(value_z_value)
            if (RuntimeType.NUMBER == value_z_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_z_value_0  = value_z_value as number
                valueSerializer.writeNumber(value_z_value_0)
            }
            else if (RuntimeType.STRING == value_z_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_z_value_1  = value_z_value as string
                valueSerializer.writeString(value_z_value_1)
            }
        }
    }
    public static read(buffer: DeserializerBase): TranslateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const x_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let x_buf : number | string | undefined
        if ((x_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const x_buf__selector : int32 = valueDeserializer.readInt8()
            let x_buf_ : number | string | undefined
            if (x_buf__selector == (0).toChar()) {
                x_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (x_buf__selector == (1).toChar()) {
                x_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for x_buf_ has to be chosen through deserialisation.")
            }
            x_buf = (x_buf_ as number | string)
        }
        const x_result : number | string | undefined = x_buf
        const y_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let y_buf : number | string | undefined
        if ((y_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const y_buf__selector : int32 = valueDeserializer.readInt8()
            let y_buf_ : number | string | undefined
            if (y_buf__selector == (0).toChar()) {
                y_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (y_buf__selector == (1).toChar()) {
                y_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for y_buf_ has to be chosen through deserialisation.")
            }
            y_buf = (y_buf_ as number | string)
        }
        const y_result : number | string | undefined = y_buf
        const z_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let z_buf : number | string | undefined
        if ((z_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const z_buf__selector : int32 = valueDeserializer.readInt8()
            let z_buf_ : number | string | undefined
            if (z_buf__selector == (0).toChar()) {
                z_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (z_buf__selector == (1).toChar()) {
                z_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for z_buf_ has to be chosen through deserialisation.")
            }
            z_buf = (z_buf_ as number | string)
        }
        const z_result : number | string | undefined = z_buf
        let value : TranslateOptions = ({x: x_result, y: y_result, z: z_result} as TranslateOptions)
        return value
    }
}
export class VisibleAreaEventOptions_serializer {
    public static write(buffer: SerializerBase, value: VisibleAreaEventOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_ratios  = value.ratios
        valueSerializer.writeInt32((value_ratios.length).toInt())
        for (let value_ratios_counter_i = 0; value_ratios_counter_i < value_ratios.length; value_ratios_counter_i++) {
            const value_ratios_element : number = value_ratios[value_ratios_counter_i]
            valueSerializer.writeNumber(value_ratios_element)
        }
        const value_expectedUpdateInterval  = value.expectedUpdateInterval
        let value_expectedUpdateInterval_type : int32 = RuntimeType.UNDEFINED
        value_expectedUpdateInterval_type = runtimeType(value_expectedUpdateInterval)
        valueSerializer.writeInt8((value_expectedUpdateInterval_type).toChar())
        if ((value_expectedUpdateInterval_type) != (RuntimeType.UNDEFINED)) {
            const value_expectedUpdateInterval_value  = value_expectedUpdateInterval!
            valueSerializer.writeNumber(value_expectedUpdateInterval_value)
        }
    }
    public static read(buffer: DeserializerBase): VisibleAreaEventOptions {
        let valueDeserializer : DeserializerBase = buffer
        const ratios_buf_length : int32 = valueDeserializer.readInt32()
        let ratios_buf : Array<number> = new Array<number>(ratios_buf_length)
        for (let ratios_buf_i = 0; ratios_buf_i < ratios_buf_length; ratios_buf_i++) {
            ratios_buf[ratios_buf_i] = (valueDeserializer.readNumber() as number)
        }
        const ratios_result : Array<number> = ratios_buf
        const expectedUpdateInterval_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let expectedUpdateInterval_buf : number | undefined
        if ((expectedUpdateInterval_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            expectedUpdateInterval_buf = (valueDeserializer.readNumber() as number)
        }
        const expectedUpdateInterval_result : number | undefined = expectedUpdateInterval_buf
        let value : VisibleAreaEventOptions = ({ratios: ratios_result, expectedUpdateInterval: expectedUpdateInterval_result} as VisibleAreaEventOptions)
        return value
    }
}
export class AnimateParam_serializer {
    public static write(buffer: SerializerBase, value: AnimateParam): void {
        let valueSerializer : SerializerBase = buffer
        const value_duration  = value.duration
        let value_duration_type : int32 = RuntimeType.UNDEFINED
        value_duration_type = runtimeType(value_duration)
        valueSerializer.writeInt8((value_duration_type).toChar())
        if ((value_duration_type) != (RuntimeType.UNDEFINED)) {
            const value_duration_value  = value_duration!
            valueSerializer.writeNumber(value_duration_value)
        }
        const value_tempo  = value.tempo
        let value_tempo_type : int32 = RuntimeType.UNDEFINED
        value_tempo_type = runtimeType(value_tempo)
        valueSerializer.writeInt8((value_tempo_type).toChar())
        if ((value_tempo_type) != (RuntimeType.UNDEFINED)) {
            const value_tempo_value  = value_tempo!
            valueSerializer.writeNumber(value_tempo_value)
        }
        const value_curve  = value.curve
        let value_curve_type : int32 = RuntimeType.UNDEFINED
        value_curve_type = runtimeType(value_curve)
        valueSerializer.writeInt8((value_curve_type).toChar())
        if ((value_curve_type) != (RuntimeType.UNDEFINED)) {
            const value_curve_value  = value_curve!
            let value_curve_value_type : int32 = RuntimeType.UNDEFINED
            value_curve_value_type = runtimeType(value_curve_value)
            if (TypeChecker.iscurves_Curve(value_curve_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_curve_value_0  = value_curve_value as curves.Curve
                valueSerializer.writeInt32(TypeChecker.curves_Curve_ToNumeric(value_curve_value_0))
            }
            else if (RuntimeType.STRING == value_curve_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_curve_value_1  = value_curve_value as string
                valueSerializer.writeString(value_curve_value_1)
            }
            else if (RuntimeType.OBJECT == value_curve_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_curve_value_2  = value_curve_value as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, value_curve_value_2)
            }
        }
        const value_delay  = value.delay
        let value_delay_type : int32 = RuntimeType.UNDEFINED
        value_delay_type = runtimeType(value_delay)
        valueSerializer.writeInt8((value_delay_type).toChar())
        if ((value_delay_type) != (RuntimeType.UNDEFINED)) {
            const value_delay_value  = value_delay!
            valueSerializer.writeNumber(value_delay_value)
        }
        const value_iterations  = value.iterations
        let value_iterations_type : int32 = RuntimeType.UNDEFINED
        value_iterations_type = runtimeType(value_iterations)
        valueSerializer.writeInt8((value_iterations_type).toChar())
        if ((value_iterations_type) != (RuntimeType.UNDEFINED)) {
            const value_iterations_value  = value_iterations!
            valueSerializer.writeNumber(value_iterations_value)
        }
        const value_playMode  = value.playMode
        let value_playMode_type : int32 = RuntimeType.UNDEFINED
        value_playMode_type = runtimeType(value_playMode)
        valueSerializer.writeInt8((value_playMode_type).toChar())
        if ((value_playMode_type) != (RuntimeType.UNDEFINED)) {
            const value_playMode_value  = (value_playMode as PlayMode)
            valueSerializer.writeInt32(TypeChecker.PlayMode_ToNumeric(value_playMode_value))
        }
        const value_onFinish  = value.onFinish
        let value_onFinish_type : int32 = RuntimeType.UNDEFINED
        value_onFinish_type = runtimeType(value_onFinish)
        valueSerializer.writeInt8((value_onFinish_type).toChar())
        if ((value_onFinish_type) != (RuntimeType.UNDEFINED)) {
            const value_onFinish_value  = value_onFinish!
            valueSerializer.holdAndWriteCallback(value_onFinish_value)
        }
        const value_finishCallbackType  = value.finishCallbackType
        let value_finishCallbackType_type : int32 = RuntimeType.UNDEFINED
        value_finishCallbackType_type = runtimeType(value_finishCallbackType)
        valueSerializer.writeInt8((value_finishCallbackType_type).toChar())
        if ((value_finishCallbackType_type) != (RuntimeType.UNDEFINED)) {
            const value_finishCallbackType_value  = (value_finishCallbackType as FinishCallbackType)
            valueSerializer.writeInt32(TypeChecker.FinishCallbackType_ToNumeric(value_finishCallbackType_value))
        }
        const value_expectedFrameRateRange  = value.expectedFrameRateRange
        let value_expectedFrameRateRange_type : int32 = RuntimeType.UNDEFINED
        value_expectedFrameRateRange_type = runtimeType(value_expectedFrameRateRange)
        valueSerializer.writeInt8((value_expectedFrameRateRange_type).toChar())
        if ((value_expectedFrameRateRange_type) != (RuntimeType.UNDEFINED)) {
            const value_expectedFrameRateRange_value  = value_expectedFrameRateRange!
            ExpectedFrameRateRange_serializer.write(valueSerializer, value_expectedFrameRateRange_value)
        }
    }
    public static read(buffer: DeserializerBase): AnimateParam {
        let valueDeserializer : DeserializerBase = buffer
        const duration_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let duration_buf : number | undefined
        if ((duration_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            duration_buf = (valueDeserializer.readNumber() as number)
        }
        const duration_result : number | undefined = duration_buf
        const tempo_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let tempo_buf : number | undefined
        if ((tempo_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            tempo_buf = (valueDeserializer.readNumber() as number)
        }
        const tempo_result : number | undefined = tempo_buf
        const curve_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curve_buf : curves.Curve | string | curves.ICurve | undefined
        if ((curve_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const curve_buf__selector : int32 = valueDeserializer.readInt8()
            let curve_buf_ : curves.Curve | string | curves.ICurve | undefined
            if (curve_buf__selector == (0).toChar()) {
                curve_buf_ = TypeChecker.curves_Curve_FromNumeric(valueDeserializer.readInt32())
            }
            else if (curve_buf__selector == (1).toChar()) {
                curve_buf_ = (valueDeserializer.readString() as string)
            }
            else if (curve_buf__selector == (2).toChar()) {
                curve_buf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            }
            else {
                throw new Error("One of the branches for curve_buf_ has to be chosen through deserialisation.")
            }
            curve_buf = (curve_buf_ as curves.Curve | string | curves.ICurve)
        }
        const curve_result : curves.Curve | string | curves.ICurve | undefined = curve_buf
        const delay_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delay_buf : number | undefined
        if ((delay_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            delay_buf = (valueDeserializer.readNumber() as number)
        }
        const delay_result : number | undefined = delay_buf
        const iterations_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let iterations_buf : number | undefined
        if ((iterations_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            iterations_buf = (valueDeserializer.readNumber() as number)
        }
        const iterations_result : number | undefined = iterations_buf
        const playMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let playMode_buf : PlayMode | undefined
        if ((playMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            playMode_buf = TypeChecker.PlayMode_FromNumeric(valueDeserializer.readInt32())
        }
        const playMode_result : PlayMode | undefined = playMode_buf
        const onFinish_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onFinish_buf : (() => void) | undefined
        if ((onFinish_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onFinish_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onFinish_buf__call : KPointer = valueDeserializer.readPointer()
            const onFinish_buf__callSync : KPointer = valueDeserializer.readPointer()
            onFinish_buf = ():void => { 
    const onFinish_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onFinish_buf__argsSerializer.writeInt32(onFinish_buf__resource.resourceId);
    onFinish_buf__argsSerializer.writePointer(onFinish_buf__call);
    onFinish_buf__argsSerializer.writePointer(onFinish_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onFinish_buf__argsSerializer.asBuffer(), onFinish_buf__argsSerializer.length());
    onFinish_buf__argsSerializer.release();
    return; }
        }
        const onFinish_result : (() => void) | undefined = onFinish_buf
        const finishCallbackType_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let finishCallbackType_buf : FinishCallbackType | undefined
        if ((finishCallbackType_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            finishCallbackType_buf = TypeChecker.FinishCallbackType_FromNumeric(valueDeserializer.readInt32())
        }
        const finishCallbackType_result : FinishCallbackType | undefined = finishCallbackType_buf
        const expectedFrameRateRange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let expectedFrameRateRange_buf : ExpectedFrameRateRange | undefined
        if ((expectedFrameRateRange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            expectedFrameRateRange_buf = ExpectedFrameRateRange_serializer.read(valueDeserializer)
        }
        const expectedFrameRateRange_result : ExpectedFrameRateRange | undefined = expectedFrameRateRange_buf
        let value : AnimateParam = ({duration: duration_result, tempo: tempo_result, curve: curve_result, delay: delay_result, iterations: iterations_result, playMode: playMode_result, onFinish: onFinish_result, finishCallbackType: finishCallbackType_result, expectedFrameRateRange: expectedFrameRateRange_result} as AnimateParam)
        return value
    }
}
export class BackgroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_colorMode  = value.colorMode
        let value_colorMode_type : int32 = RuntimeType.UNDEFINED
        value_colorMode_type = runtimeType(value_colorMode)
        valueSerializer.writeInt8((value_colorMode_type).toChar())
        if ((value_colorMode_type) != (RuntimeType.UNDEFINED)) {
            const value_colorMode_value  = (value_colorMode as ThemeColorMode)
            valueSerializer.writeInt32(TypeChecker.ThemeColorMode_ToNumeric(value_colorMode_value))
        }
        const value_adaptiveColor  = value.adaptiveColor
        let value_adaptiveColor_type : int32 = RuntimeType.UNDEFINED
        value_adaptiveColor_type = runtimeType(value_adaptiveColor)
        valueSerializer.writeInt8((value_adaptiveColor_type).toChar())
        if ((value_adaptiveColor_type) != (RuntimeType.UNDEFINED)) {
            const value_adaptiveColor_value  = (value_adaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(TypeChecker.AdaptiveColor_ToNumeric(value_adaptiveColor_value))
        }
        const value_scale  = value.scale
        let value_scale_type : int32 = RuntimeType.UNDEFINED
        value_scale_type = runtimeType(value_scale)
        valueSerializer.writeInt8((value_scale_type).toChar())
        if ((value_scale_type) != (RuntimeType.UNDEFINED)) {
            const value_scale_value  = value_scale!
            valueSerializer.writeNumber(value_scale_value)
        }
        const value_blurOptions  = value.blurOptions
        let value_blurOptions_type : int32 = RuntimeType.UNDEFINED
        value_blurOptions_type = runtimeType(value_blurOptions)
        valueSerializer.writeInt8((value_blurOptions_type).toChar())
        if ((value_blurOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_blurOptions_value  = value_blurOptions!
            BlurOptions_serializer.write(valueSerializer, value_blurOptions_value)
        }
        const value_policy  = value.policy
        let value_policy_type : int32 = RuntimeType.UNDEFINED
        value_policy_type = runtimeType(value_policy)
        valueSerializer.writeInt8((value_policy_type).toChar())
        if ((value_policy_type) != (RuntimeType.UNDEFINED)) {
            const value_policy_value  = (value_policy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(TypeChecker.BlurStyleActivePolicy_ToNumeric(value_policy_value))
        }
        const value_inactiveColor  = value.inactiveColor
        let value_inactiveColor_type : int32 = RuntimeType.UNDEFINED
        value_inactiveColor_type = runtimeType(value_inactiveColor)
        valueSerializer.writeInt8((value_inactiveColor_type).toChar())
        if ((value_inactiveColor_type) != (RuntimeType.UNDEFINED)) {
            const value_inactiveColor_value  = value_inactiveColor!
            let value_inactiveColor_value_type : int32 = RuntimeType.UNDEFINED
            value_inactiveColor_value_type = runtimeType(value_inactiveColor_value)
            if (TypeChecker.isColor(value_inactiveColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_inactiveColor_value_0  = value_inactiveColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_inactiveColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_inactiveColor_value_1  = value_inactiveColor_value as number
                valueSerializer.writeNumber(value_inactiveColor_value_1)
            }
            else if (RuntimeType.STRING == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_inactiveColor_value_2  = value_inactiveColor_value as string
                valueSerializer.writeString(value_inactiveColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_inactiveColor_value_3  = value_inactiveColor_value as Resource
                Resource_serializer.write(valueSerializer, value_inactiveColor_value_3)
            }
        }
    }
    public static read(buffer: DeserializerBase): BackgroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorMode_buf : ThemeColorMode | undefined
        if ((colorMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            colorMode_buf = TypeChecker.ThemeColorMode_FromNumeric(valueDeserializer.readInt32())
        }
        const colorMode_result : ThemeColorMode | undefined = colorMode_buf
        const adaptiveColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColor_buf : AdaptiveColor | undefined
        if ((adaptiveColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            adaptiveColor_buf = TypeChecker.AdaptiveColor_FromNumeric(valueDeserializer.readInt32())
        }
        const adaptiveColor_result : AdaptiveColor | undefined = adaptiveColor_buf
        const scale_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scale_buf : number | undefined
        if ((scale_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            scale_buf = (valueDeserializer.readNumber() as number)
        }
        const scale_result : number | undefined = scale_buf
        const blurOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptions_buf : BlurOptions | undefined
        if ((blurOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            blurOptions_buf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptions_result : BlurOptions | undefined = blurOptions_buf
        const policy_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let policy_buf : BlurStyleActivePolicy | undefined
        if ((policy_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            policy_buf = TypeChecker.BlurStyleActivePolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const policy_result : BlurStyleActivePolicy | undefined = policy_buf
        const inactiveColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let inactiveColor_buf : ResourceColor | undefined
        if ((inactiveColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const inactiveColor_buf__selector : int32 = valueDeserializer.readInt8()
            let inactiveColor_buf_ : Color | number | string | Resource | undefined
            if (inactiveColor_buf__selector == (0).toChar()) {
                inactiveColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (inactiveColor_buf__selector == (1).toChar()) {
                inactiveColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (inactiveColor_buf__selector == (2).toChar()) {
                inactiveColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (inactiveColor_buf__selector == (3).toChar()) {
                inactiveColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for inactiveColor_buf_ has to be chosen through deserialisation.")
            }
            inactiveColor_buf = (inactiveColor_buf_ as Color | number | string | Resource)
        }
        const inactiveColor_result : ResourceColor | undefined = inactiveColor_buf
        let value : BackgroundBlurStyleOptions = ({colorMode: colorMode_result, adaptiveColor: adaptiveColor_result, scale: scale_result, blurOptions: blurOptions_result, policy: policy_result, inactiveColor: inactiveColor_result} as BackgroundBlurStyleOptions)
        return value
    }
}
export class BackgroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_radius  = value.radius
        valueSerializer.writeNumber(value_radius)
        const value_saturation  = value.saturation
        let value_saturation_type : int32 = RuntimeType.UNDEFINED
        value_saturation_type = runtimeType(value_saturation)
        valueSerializer.writeInt8((value_saturation_type).toChar())
        if ((value_saturation_type) != (RuntimeType.UNDEFINED)) {
            const value_saturation_value  = value_saturation!
            valueSerializer.writeNumber(value_saturation_value)
        }
        const value_brightness  = value.brightness
        let value_brightness_type : int32 = RuntimeType.UNDEFINED
        value_brightness_type = runtimeType(value_brightness)
        valueSerializer.writeInt8((value_brightness_type).toChar())
        if ((value_brightness_type) != (RuntimeType.UNDEFINED)) {
            const value_brightness_value  = value_brightness!
            valueSerializer.writeNumber(value_brightness_value)
        }
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.NUMBER == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as number
                valueSerializer.writeNumber(value_color_value_1)
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as string
                valueSerializer.writeString(value_color_value_2)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_3)
            }
        }
        const value_adaptiveColor  = value.adaptiveColor
        let value_adaptiveColor_type : int32 = RuntimeType.UNDEFINED
        value_adaptiveColor_type = runtimeType(value_adaptiveColor)
        valueSerializer.writeInt8((value_adaptiveColor_type).toChar())
        if ((value_adaptiveColor_type) != (RuntimeType.UNDEFINED)) {
            const value_adaptiveColor_value  = (value_adaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(TypeChecker.AdaptiveColor_ToNumeric(value_adaptiveColor_value))
        }
        const value_blurOptions  = value.blurOptions
        let value_blurOptions_type : int32 = RuntimeType.UNDEFINED
        value_blurOptions_type = runtimeType(value_blurOptions)
        valueSerializer.writeInt8((value_blurOptions_type).toChar())
        if ((value_blurOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_blurOptions_value  = value_blurOptions!
            BlurOptions_serializer.write(valueSerializer, value_blurOptions_value)
        }
        const value_policy  = value.policy
        let value_policy_type : int32 = RuntimeType.UNDEFINED
        value_policy_type = runtimeType(value_policy)
        valueSerializer.writeInt8((value_policy_type).toChar())
        if ((value_policy_type) != (RuntimeType.UNDEFINED)) {
            const value_policy_value  = (value_policy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(TypeChecker.BlurStyleActivePolicy_ToNumeric(value_policy_value))
        }
        const value_inactiveColor  = value.inactiveColor
        let value_inactiveColor_type : int32 = RuntimeType.UNDEFINED
        value_inactiveColor_type = runtimeType(value_inactiveColor)
        valueSerializer.writeInt8((value_inactiveColor_type).toChar())
        if ((value_inactiveColor_type) != (RuntimeType.UNDEFINED)) {
            const value_inactiveColor_value  = value_inactiveColor!
            let value_inactiveColor_value_type : int32 = RuntimeType.UNDEFINED
            value_inactiveColor_value_type = runtimeType(value_inactiveColor_value)
            if (TypeChecker.isColor(value_inactiveColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_inactiveColor_value_0  = value_inactiveColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_inactiveColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_inactiveColor_value_1  = value_inactiveColor_value as number
                valueSerializer.writeNumber(value_inactiveColor_value_1)
            }
            else if (RuntimeType.STRING == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_inactiveColor_value_2  = value_inactiveColor_value as string
                valueSerializer.writeString(value_inactiveColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_inactiveColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_inactiveColor_value_3  = value_inactiveColor_value as Resource
                Resource_serializer.write(valueSerializer, value_inactiveColor_value_3)
            }
        }
    }
    public static read(buffer: DeserializerBase): BackgroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radius_result : number = (valueDeserializer.readNumber() as number)
        const saturation_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let saturation_buf : number | undefined
        if ((saturation_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            saturation_buf = (valueDeserializer.readNumber() as number)
        }
        const saturation_result : number | undefined = saturation_buf
        const brightness_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let brightness_buf : number | undefined
        if ((brightness_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            brightness_buf = (valueDeserializer.readNumber() as number)
        }
        const brightness_result : number | undefined = brightness_buf
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : ResourceColor | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | number | string | Resource | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | number | string | Resource)
        }
        const color_result : ResourceColor | undefined = color_buf
        const adaptiveColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColor_buf : AdaptiveColor | undefined
        if ((adaptiveColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            adaptiveColor_buf = TypeChecker.AdaptiveColor_FromNumeric(valueDeserializer.readInt32())
        }
        const adaptiveColor_result : AdaptiveColor | undefined = adaptiveColor_buf
        const blurOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptions_buf : BlurOptions | undefined
        if ((blurOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            blurOptions_buf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptions_result : BlurOptions | undefined = blurOptions_buf
        const policy_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let policy_buf : BlurStyleActivePolicy | undefined
        if ((policy_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            policy_buf = TypeChecker.BlurStyleActivePolicy_FromNumeric(valueDeserializer.readInt32())
        }
        const policy_result : BlurStyleActivePolicy | undefined = policy_buf
        const inactiveColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let inactiveColor_buf : ResourceColor | undefined
        if ((inactiveColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const inactiveColor_buf__selector : int32 = valueDeserializer.readInt8()
            let inactiveColor_buf_ : Color | number | string | Resource | undefined
            if (inactiveColor_buf__selector == (0).toChar()) {
                inactiveColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (inactiveColor_buf__selector == (1).toChar()) {
                inactiveColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (inactiveColor_buf__selector == (2).toChar()) {
                inactiveColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (inactiveColor_buf__selector == (3).toChar()) {
                inactiveColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for inactiveColor_buf_ has to be chosen through deserialisation.")
            }
            inactiveColor_buf = (inactiveColor_buf_ as Color | number | string | Resource)
        }
        const inactiveColor_result : ResourceColor | undefined = inactiveColor_buf
        let value : BackgroundEffectOptions = ({radius: radius_result, saturation: saturation_result, brightness: brightness_result, color: color_result, adaptiveColor: adaptiveColor_result, blurOptions: blurOptions_result, policy: policy_result, inactiveColor: inactiveColor_result} as BackgroundEffectOptions)
        return value
    }
}
export class DragPreviewOptions_serializer {
    public static write(buffer: SerializerBase, value: DragPreviewOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_mode  = value.mode
        let value_mode_type : int32 = RuntimeType.UNDEFINED
        value_mode_type = runtimeType(value_mode)
        valueSerializer.writeInt8((value_mode_type).toChar())
        if ((value_mode_type) != (RuntimeType.UNDEFINED)) {
            const value_mode_value  = value_mode!
            let value_mode_value_type : int32 = RuntimeType.UNDEFINED
            value_mode_value_type = runtimeType(value_mode_value)
            if (TypeChecker.isDragPreviewMode(value_mode_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_mode_value_0  = value_mode_value as DragPreviewMode
                valueSerializer.writeInt32(TypeChecker.DragPreviewMode_ToNumeric(value_mode_value_0))
            }
            else if (RuntimeType.OBJECT == value_mode_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_mode_value_1  = value_mode_value as Array<DragPreviewMode>
                valueSerializer.writeInt32((value_mode_value_1.length).toInt())
                for (let value_mode_value_1_counter_i = 0; value_mode_value_1_counter_i < value_mode_value_1.length; value_mode_value_1_counter_i++) {
                    const value_mode_value_1_element : DragPreviewMode = value_mode_value_1[value_mode_value_1_counter_i]
                    valueSerializer.writeInt32(TypeChecker.DragPreviewMode_ToNumeric(value_mode_value_1_element))
                }
            }
        }
        const value_numberBadge  = value.numberBadge
        let value_numberBadge_type : int32 = RuntimeType.UNDEFINED
        value_numberBadge_type = runtimeType(value_numberBadge)
        valueSerializer.writeInt8((value_numberBadge_type).toChar())
        if ((value_numberBadge_type) != (RuntimeType.UNDEFINED)) {
            const value_numberBadge_value  = value_numberBadge!
            let value_numberBadge_value_type : int32 = RuntimeType.UNDEFINED
            value_numberBadge_value_type = runtimeType(value_numberBadge_value)
            if (RuntimeType.BOOLEAN == value_numberBadge_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_numberBadge_value_0  = value_numberBadge_value as boolean
                valueSerializer.writeBoolean(value_numberBadge_value_0)
            }
            else if (RuntimeType.NUMBER == value_numberBadge_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_numberBadge_value_1  = value_numberBadge_value as number
                valueSerializer.writeNumber(value_numberBadge_value_1)
            }
        }
        const value_sizeChangeEffect  = value.sizeChangeEffect
        let value_sizeChangeEffect_type : int32 = RuntimeType.UNDEFINED
        value_sizeChangeEffect_type = runtimeType(value_sizeChangeEffect)
        valueSerializer.writeInt8((value_sizeChangeEffect_type).toChar())
        if ((value_sizeChangeEffect_type) != (RuntimeType.UNDEFINED)) {
            const value_sizeChangeEffect_value  = (value_sizeChangeEffect as DraggingSizeChangeEffect)
            valueSerializer.writeInt32(TypeChecker.DraggingSizeChangeEffect_ToNumeric(value_sizeChangeEffect_value))
        }
    }
    public static read(buffer: DeserializerBase): DragPreviewOptions {
        let valueDeserializer : DeserializerBase = buffer
        const mode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let mode_buf : DragPreviewMode | Array<DragPreviewMode> | undefined
        if ((mode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const mode_buf__selector : int32 = valueDeserializer.readInt8()
            let mode_buf_ : DragPreviewMode | Array<DragPreviewMode> | undefined
            if (mode_buf__selector == (0).toChar()) {
                mode_buf_ = TypeChecker.DragPreviewMode_FromNumeric(valueDeserializer.readInt32())
            }
            else if (mode_buf__selector == (1).toChar()) {
                const mode_buf__u_length : int32 = valueDeserializer.readInt32()
                let mode_buf__u : Array<DragPreviewMode> = new Array<DragPreviewMode>(mode_buf__u_length)
                for (let mode_buf__u_i = 0; mode_buf__u_i < mode_buf__u_length; mode_buf__u_i++) {
                    mode_buf__u[mode_buf__u_i] = TypeChecker.DragPreviewMode_FromNumeric(valueDeserializer.readInt32())
                }
                mode_buf_ = mode_buf__u
            }
            else {
                throw new Error("One of the branches for mode_buf_ has to be chosen through deserialisation.")
            }
            mode_buf = (mode_buf_ as DragPreviewMode | Array<DragPreviewMode>)
        }
        const mode_result : DragPreviewMode | Array<DragPreviewMode> | undefined = mode_buf
        const numberBadge_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let numberBadge_buf : boolean | number | undefined
        if ((numberBadge_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const numberBadge_buf__selector : int32 = valueDeserializer.readInt8()
            let numberBadge_buf_ : boolean | number | undefined
            if (numberBadge_buf__selector == (0).toChar()) {
                numberBadge_buf_ = valueDeserializer.readBoolean()
            }
            else if (numberBadge_buf__selector == (1).toChar()) {
                numberBadge_buf_ = (valueDeserializer.readNumber() as number)
            }
            else {
                throw new Error("One of the branches for numberBadge_buf_ has to be chosen through deserialisation.")
            }
            numberBadge_buf = (numberBadge_buf_ as boolean | number)
        }
        const numberBadge_result : boolean | number | undefined = numberBadge_buf
        const sizeChangeEffect_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let sizeChangeEffect_buf : DraggingSizeChangeEffect | undefined
        if ((sizeChangeEffect_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            sizeChangeEffect_buf = TypeChecker.DraggingSizeChangeEffect_FromNumeric(valueDeserializer.readInt32())
        }
        const sizeChangeEffect_result : DraggingSizeChangeEffect | undefined = sizeChangeEffect_buf
        let value : DragPreviewOptions = ({mode: mode_result, numberBadge: numberBadge_result, sizeChangeEffect: sizeChangeEffect_result} as DragPreviewOptions)
        return value
    }
}
export class FadingEdgeOptions_serializer {
    public static write(buffer: SerializerBase, value: FadingEdgeOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_fadingEdgeLength  = value.fadingEdgeLength
        let value_fadingEdgeLength_type : int32 = RuntimeType.UNDEFINED
        value_fadingEdgeLength_type = runtimeType(value_fadingEdgeLength)
        valueSerializer.writeInt8((value_fadingEdgeLength_type).toChar())
        if ((value_fadingEdgeLength_type) != (RuntimeType.UNDEFINED)) {
            const value_fadingEdgeLength_value  = value_fadingEdgeLength!
            LengthMetrics_serializer.write(valueSerializer, value_fadingEdgeLength_value)
        }
    }
    public static read(buffer: DeserializerBase): FadingEdgeOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fadingEdgeLength_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fadingEdgeLength_buf : LengthMetrics | undefined
        if ((fadingEdgeLength_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            fadingEdgeLength_buf = (LengthMetrics_serializer.read(valueDeserializer) as LengthMetrics)
        }
        const fadingEdgeLength_result : LengthMetrics | undefined = fadingEdgeLength_buf
        let value : FadingEdgeOptions = ({fadingEdgeLength: fadingEdgeLength_result} as FadingEdgeOptions)
        return value
    }
}
export class ForegroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_colorMode  = value.colorMode
        let value_colorMode_type : int32 = RuntimeType.UNDEFINED
        value_colorMode_type = runtimeType(value_colorMode)
        valueSerializer.writeInt8((value_colorMode_type).toChar())
        if ((value_colorMode_type) != (RuntimeType.UNDEFINED)) {
            const value_colorMode_value  = (value_colorMode as ThemeColorMode)
            valueSerializer.writeInt32(TypeChecker.ThemeColorMode_ToNumeric(value_colorMode_value))
        }
        const value_adaptiveColor  = value.adaptiveColor
        let value_adaptiveColor_type : int32 = RuntimeType.UNDEFINED
        value_adaptiveColor_type = runtimeType(value_adaptiveColor)
        valueSerializer.writeInt8((value_adaptiveColor_type).toChar())
        if ((value_adaptiveColor_type) != (RuntimeType.UNDEFINED)) {
            const value_adaptiveColor_value  = (value_adaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(TypeChecker.AdaptiveColor_ToNumeric(value_adaptiveColor_value))
        }
        const value_scale  = value.scale
        let value_scale_type : int32 = RuntimeType.UNDEFINED
        value_scale_type = runtimeType(value_scale)
        valueSerializer.writeInt8((value_scale_type).toChar())
        if ((value_scale_type) != (RuntimeType.UNDEFINED)) {
            const value_scale_value  = value_scale!
            valueSerializer.writeNumber(value_scale_value)
        }
        const value_blurOptions  = value.blurOptions
        let value_blurOptions_type : int32 = RuntimeType.UNDEFINED
        value_blurOptions_type = runtimeType(value_blurOptions)
        valueSerializer.writeInt8((value_blurOptions_type).toChar())
        if ((value_blurOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_blurOptions_value  = value_blurOptions!
            BlurOptions_serializer.write(valueSerializer, value_blurOptions_value)
        }
    }
    public static read(buffer: DeserializerBase): ForegroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorMode_buf : ThemeColorMode | undefined
        if ((colorMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            colorMode_buf = TypeChecker.ThemeColorMode_FromNumeric(valueDeserializer.readInt32())
        }
        const colorMode_result : ThemeColorMode | undefined = colorMode_buf
        const adaptiveColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColor_buf : AdaptiveColor | undefined
        if ((adaptiveColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            adaptiveColor_buf = TypeChecker.AdaptiveColor_FromNumeric(valueDeserializer.readInt32())
        }
        const adaptiveColor_result : AdaptiveColor | undefined = adaptiveColor_buf
        const scale_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scale_buf : number | undefined
        if ((scale_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            scale_buf = (valueDeserializer.readNumber() as number)
        }
        const scale_result : number | undefined = scale_buf
        const blurOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptions_buf : BlurOptions | undefined
        if ((blurOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            blurOptions_buf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptions_result : BlurOptions | undefined = blurOptions_buf
        let value : ForegroundBlurStyleOptions = ({colorMode: colorMode_result, adaptiveColor: adaptiveColor_result, scale: scale_result, blurOptions: blurOptions_result} as ForegroundBlurStyleOptions)
        return value
    }
}
export class HistoricalPoint_serializer {
    public static write(buffer: SerializerBase, value: HistoricalPoint): void {
        let valueSerializer : SerializerBase = buffer
        const value_touchObject  = value.touchObject
        TouchObject_serializer.write(valueSerializer, value_touchObject)
        const value_size  = value.size
        valueSerializer.writeNumber(value_size)
        const value_force  = value.force
        valueSerializer.writeNumber(value_force)
        const value_timestamp  = value.timestamp
        valueSerializer.writeNumber(value_timestamp)
    }
    public static read(buffer: DeserializerBase): HistoricalPoint {
        let valueDeserializer : DeserializerBase = buffer
        const touchObject_result : TouchObject = TouchObject_serializer.read(valueDeserializer)
        const size_result : number = (valueDeserializer.readNumber() as number)
        const force_result : number = (valueDeserializer.readNumber() as number)
        const timestamp_result : number = (valueDeserializer.readNumber() as number)
        let value : HistoricalPoint = ({touchObject: touchObject_result, size: size_result, force: force_result, timestamp: timestamp_result} as HistoricalPoint)
        return value
    }
}
export class Layoutable_serializer {
    public static write(buffer: SerializerBase, value: Layoutable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Layoutable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutableInternal.fromPtr(ptr)
    }
}
export class LightSource_serializer {
    public static write(buffer: SerializerBase, value: LightSource): void {
        let valueSerializer : SerializerBase = buffer
        const value_positionX  = value.positionX
        let value_positionX_type : int32 = RuntimeType.UNDEFINED
        value_positionX_type = runtimeType(value_positionX)
        if (RuntimeType.STRING == value_positionX_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_positionX_0  = value_positionX as string
            valueSerializer.writeString(value_positionX_0)
        }
        else if (RuntimeType.NUMBER == value_positionX_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_positionX_1  = value_positionX as number
            valueSerializer.writeNumber(value_positionX_1)
        }
        else if (RuntimeType.OBJECT == value_positionX_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_positionX_2  = value_positionX as Resource
            Resource_serializer.write(valueSerializer, value_positionX_2)
        }
        const value_positionY  = value.positionY
        let value_positionY_type : int32 = RuntimeType.UNDEFINED
        value_positionY_type = runtimeType(value_positionY)
        if (RuntimeType.STRING == value_positionY_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_positionY_0  = value_positionY as string
            valueSerializer.writeString(value_positionY_0)
        }
        else if (RuntimeType.NUMBER == value_positionY_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_positionY_1  = value_positionY as number
            valueSerializer.writeNumber(value_positionY_1)
        }
        else if (RuntimeType.OBJECT == value_positionY_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_positionY_2  = value_positionY as Resource
            Resource_serializer.write(valueSerializer, value_positionY_2)
        }
        const value_positionZ  = value.positionZ
        let value_positionZ_type : int32 = RuntimeType.UNDEFINED
        value_positionZ_type = runtimeType(value_positionZ)
        if (RuntimeType.STRING == value_positionZ_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_positionZ_0  = value_positionZ as string
            valueSerializer.writeString(value_positionZ_0)
        }
        else if (RuntimeType.NUMBER == value_positionZ_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_positionZ_1  = value_positionZ as number
            valueSerializer.writeNumber(value_positionZ_1)
        }
        else if (RuntimeType.OBJECT == value_positionZ_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_positionZ_2  = value_positionZ as Resource
            Resource_serializer.write(valueSerializer, value_positionZ_2)
        }
        const value_intensity  = value.intensity
        valueSerializer.writeNumber(value_intensity)
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.NUMBER == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as number
                valueSerializer.writeNumber(value_color_value_1)
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as string
                valueSerializer.writeString(value_color_value_2)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_3)
            }
        }
    }
    public static read(buffer: DeserializerBase): LightSource {
        let valueDeserializer : DeserializerBase = buffer
        const positionX_buf_selector : int32 = valueDeserializer.readInt8()
        let positionX_buf : string | number | Resource | undefined
        if (positionX_buf_selector == (0).toChar()) {
            positionX_buf = (valueDeserializer.readString() as string)
        }
        else if (positionX_buf_selector == (1).toChar()) {
            positionX_buf = (valueDeserializer.readNumber() as number)
        }
        else if (positionX_buf_selector == (2).toChar()) {
            positionX_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for positionX_buf has to be chosen through deserialisation.")
        }
        const positionX_result : Dimension = (positionX_buf as string | number | Resource)
        const positionY_buf_selector : int32 = valueDeserializer.readInt8()
        let positionY_buf : string | number | Resource | undefined
        if (positionY_buf_selector == (0).toChar()) {
            positionY_buf = (valueDeserializer.readString() as string)
        }
        else if (positionY_buf_selector == (1).toChar()) {
            positionY_buf = (valueDeserializer.readNumber() as number)
        }
        else if (positionY_buf_selector == (2).toChar()) {
            positionY_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for positionY_buf has to be chosen through deserialisation.")
        }
        const positionY_result : Dimension = (positionY_buf as string | number | Resource)
        const positionZ_buf_selector : int32 = valueDeserializer.readInt8()
        let positionZ_buf : string | number | Resource | undefined
        if (positionZ_buf_selector == (0).toChar()) {
            positionZ_buf = (valueDeserializer.readString() as string)
        }
        else if (positionZ_buf_selector == (1).toChar()) {
            positionZ_buf = (valueDeserializer.readNumber() as number)
        }
        else if (positionZ_buf_selector == (2).toChar()) {
            positionZ_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for positionZ_buf has to be chosen through deserialisation.")
        }
        const positionZ_result : Dimension = (positionZ_buf as string | number | Resource)
        const intensity_result : number = (valueDeserializer.readNumber() as number)
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : ResourceColor | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | number | string | Resource | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | number | string | Resource)
        }
        const color_result : ResourceColor | undefined = color_buf
        let value : LightSource = ({positionX: positionX_result, positionY: positionY_result, positionZ: positionZ_result, intensity: intensity_result, color: color_result} as LightSource)
        return value
    }
}
export class LocalizedAlignRuleOptions_serializer {
    public static write(buffer: SerializerBase, value: LocalizedAlignRuleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_start  = value.start
        let value_start_type : int32 = RuntimeType.UNDEFINED
        value_start_type = runtimeType(value_start)
        valueSerializer.writeInt8((value_start_type).toChar())
        if ((value_start_type) != (RuntimeType.UNDEFINED)) {
            const value_start_value  = value_start!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, value_start_value)
        }
        const value_end  = value.end
        let value_end_type : int32 = RuntimeType.UNDEFINED
        value_end_type = runtimeType(value_end)
        valueSerializer.writeInt8((value_end_type).toChar())
        if ((value_end_type) != (RuntimeType.UNDEFINED)) {
            const value_end_value  = value_end!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, value_end_value)
        }
        const value_middle  = value.middle
        let value_middle_type : int32 = RuntimeType.UNDEFINED
        value_middle_type = runtimeType(value_middle)
        valueSerializer.writeInt8((value_middle_type).toChar())
        if ((value_middle_type) != (RuntimeType.UNDEFINED)) {
            const value_middle_value  = value_middle!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, value_middle_value)
        }
        const value_top  = value.top
        let value_top_type : int32 = RuntimeType.UNDEFINED
        value_top_type = runtimeType(value_top)
        valueSerializer.writeInt8((value_top_type).toChar())
        if ((value_top_type) != (RuntimeType.UNDEFINED)) {
            const value_top_value  = value_top!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, value_top_value)
        }
        const value_bottom  = value.bottom
        let value_bottom_type : int32 = RuntimeType.UNDEFINED
        value_bottom_type = runtimeType(value_bottom)
        valueSerializer.writeInt8((value_bottom_type).toChar())
        if ((value_bottom_type) != (RuntimeType.UNDEFINED)) {
            const value_bottom_value  = value_bottom!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, value_bottom_value)
        }
        const value_center  = value.center
        let value_center_type : int32 = RuntimeType.UNDEFINED
        value_center_type = runtimeType(value_center)
        valueSerializer.writeInt8((value_center_type).toChar())
        if ((value_center_type) != (RuntimeType.UNDEFINED)) {
            const value_center_value  = value_center!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, value_center_value)
        }
        const value_bias  = value.bias
        let value_bias_type : int32 = RuntimeType.UNDEFINED
        value_bias_type = runtimeType(value_bias)
        valueSerializer.writeInt8((value_bias_type).toChar())
        if ((value_bias_type) != (RuntimeType.UNDEFINED)) {
            const value_bias_value  = value_bias!
            Bias_serializer.write(valueSerializer, value_bias_value)
        }
    }
    public static read(buffer: DeserializerBase): LocalizedAlignRuleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const start_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let start_buf : LocalizedHorizontalAlignParam | undefined
        if ((start_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            start_buf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const start_result : LocalizedHorizontalAlignParam | undefined = start_buf
        const end_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let end_buf : LocalizedHorizontalAlignParam | undefined
        if ((end_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            end_buf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const end_result : LocalizedHorizontalAlignParam | undefined = end_buf
        const middle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let middle_buf : LocalizedHorizontalAlignParam | undefined
        if ((middle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            middle_buf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const middle_result : LocalizedHorizontalAlignParam | undefined = middle_buf
        const top_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let top_buf : LocalizedVerticalAlignParam | undefined
        if ((top_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            top_buf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const top_result : LocalizedVerticalAlignParam | undefined = top_buf
        const bottom_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottom_buf : LocalizedVerticalAlignParam | undefined
        if ((bottom_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            bottom_buf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const bottom_result : LocalizedVerticalAlignParam | undefined = bottom_buf
        const center_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let center_buf : LocalizedVerticalAlignParam | undefined
        if ((center_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            center_buf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const center_result : LocalizedVerticalAlignParam | undefined = center_buf
        const bias_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bias_buf : Bias | undefined
        if ((bias_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            bias_buf = Bias_serializer.read(valueDeserializer)
        }
        const bias_result : Bias | undefined = bias_buf
        let value : LocalizedAlignRuleOptions = ({start: start_result, end: end_result, middle: middle_result, top: top_result, bottom: bottom_result, center: center_result, bias: bias_result} as LocalizedAlignRuleOptions)
        return value
    }
}
export class MenuElement_serializer {
    public static write(buffer: SerializerBase, value: MenuElement): void {
        let valueSerializer : SerializerBase = buffer
        const value_value  = value.value
        let value_value_type : int32 = RuntimeType.UNDEFINED
        value_value_type = runtimeType(value_value)
        if (RuntimeType.STRING == value_value_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_value_0  = value_value as string
            valueSerializer.writeString(value_value_0)
        }
        else if (RuntimeType.OBJECT == value_value_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_value_1  = value_value as Resource
            Resource_serializer.write(valueSerializer, value_value_1)
        }
        const value_icon  = value.icon
        let value_icon_type : int32 = RuntimeType.UNDEFINED
        value_icon_type = runtimeType(value_icon)
        valueSerializer.writeInt8((value_icon_type).toChar())
        if ((value_icon_type) != (RuntimeType.UNDEFINED)) {
            const value_icon_value  = value_icon!
            let value_icon_value_type : int32 = RuntimeType.UNDEFINED
            value_icon_value_type = runtimeType(value_icon_value)
            if (RuntimeType.STRING == value_icon_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_icon_value_0  = value_icon_value as string
                valueSerializer.writeString(value_icon_value_0)
            }
            else if (RuntimeType.OBJECT == value_icon_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_icon_value_1  = value_icon_value as Resource
                Resource_serializer.write(valueSerializer, value_icon_value_1)
            }
        }
        const value_symbolIcon  = value.symbolIcon
        let value_symbolIcon_type : int32 = RuntimeType.UNDEFINED
        value_symbolIcon_type = runtimeType(value_symbolIcon)
        valueSerializer.writeInt8((value_symbolIcon_type).toChar())
        if ((value_symbolIcon_type) != (RuntimeType.UNDEFINED)) {
            const value_symbolIcon_value  = value_symbolIcon!
            SymbolGlyphModifier_serializer.write(valueSerializer, value_symbolIcon_value)
        }
        const value_enabled  = value.enabled
        let value_enabled_type : int32 = RuntimeType.UNDEFINED
        value_enabled_type = runtimeType(value_enabled)
        valueSerializer.writeInt8((value_enabled_type).toChar())
        if ((value_enabled_type) != (RuntimeType.UNDEFINED)) {
            const value_enabled_value  = value_enabled!
            valueSerializer.writeBoolean(value_enabled_value)
        }
        const value_action  = value.action
        valueSerializer.holdAndWriteCallback(value_action)
    }
    public static read(buffer: DeserializerBase): MenuElement {
        let valueDeserializer : DeserializerBase = buffer
        const value_buf_selector : int32 = valueDeserializer.readInt8()
        let value_buf : string | Resource | undefined
        if (value_buf_selector == (0).toChar()) {
            value_buf = (valueDeserializer.readString() as string)
        }
        else if (value_buf_selector == (1).toChar()) {
            value_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for value_buf has to be chosen through deserialisation.")
        }
        const value_result : ResourceStr = (value_buf as string | Resource)
        const icon_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let icon_buf : ResourceStr | undefined
        if ((icon_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const icon_buf__selector : int32 = valueDeserializer.readInt8()
            let icon_buf_ : string | Resource | undefined
            if (icon_buf__selector == (0).toChar()) {
                icon_buf_ = (valueDeserializer.readString() as string)
            }
            else if (icon_buf__selector == (1).toChar()) {
                icon_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for icon_buf_ has to be chosen through deserialisation.")
            }
            icon_buf = (icon_buf_ as string | Resource)
        }
        const icon_result : ResourceStr | undefined = icon_buf
        const symbolIcon_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let symbolIcon_buf : SymbolGlyphModifier | undefined
        if ((symbolIcon_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            symbolIcon_buf = SymbolGlyphModifier_serializer.read(valueDeserializer)
        }
        const symbolIcon_result : SymbolGlyphModifier | undefined = symbolIcon_buf
        const enabled_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enabled_buf : boolean | undefined
        if ((enabled_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enabled_buf = valueDeserializer.readBoolean()
        }
        const enabled_result : boolean | undefined = enabled_buf
        const action_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const action_buf_call : KPointer = valueDeserializer.readPointer()
        const action_buf_callSync : KPointer = valueDeserializer.readPointer()
        const action_result : (() => void) = ():void => { 
    const action_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    action_buf_argsSerializer.writeInt32(action_buf_resource.resourceId);
    action_buf_argsSerializer.writePointer(action_buf_call);
    action_buf_argsSerializer.writePointer(action_buf_callSync);
    InteropNativeModule._CallCallback(-1867723152, action_buf_argsSerializer.asBuffer(), action_buf_argsSerializer.length());
    action_buf_argsSerializer.release();
    return; }
        let value : MenuElement = ({value: value_result, icon: icon_result, symbolIcon: symbolIcon_result, enabled: enabled_result, action: action_result} as MenuElement)
        return value
    }
}
export class OverlayOptions_serializer {
    public static write(buffer: SerializerBase, value: OverlayOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_align  = value.align
        let value_align_type : int32 = RuntimeType.UNDEFINED
        value_align_type = runtimeType(value_align)
        valueSerializer.writeInt8((value_align_type).toChar())
        if ((value_align_type) != (RuntimeType.UNDEFINED)) {
            const value_align_value  = (value_align as Alignment)
            valueSerializer.writeInt32(TypeChecker.Alignment_ToNumeric(value_align_value))
        }
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            OverlayOffset_serializer.write(valueSerializer, value_offset_value)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOptions {
        let valueDeserializer : DeserializerBase = buffer
        const align_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let align_buf : Alignment | undefined
        if ((align_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            align_buf = TypeChecker.Alignment_FromNumeric(valueDeserializer.readInt32())
        }
        const align_result : Alignment | undefined = align_buf
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : OverlayOffset | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = OverlayOffset_serializer.read(valueDeserializer)
        }
        const offset_result : OverlayOffset | undefined = offset_buf
        let value : OverlayOptions = ({align: align_result, offset: offset_result} as OverlayOptions)
        return value
    }
}
export class PopupMaskType_serializer {
    public static write(buffer: SerializerBase, value: PopupMaskType): void {
        let valueSerializer : SerializerBase = buffer
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        if (TypeChecker.isColor(value_color)) {
            valueSerializer.writeInt8((0).toChar())
            const value_color_0  = value_color as Color
            valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_0))
        }
        else if (RuntimeType.NUMBER == value_color_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_color_1  = value_color as number
            valueSerializer.writeNumber(value_color_1)
        }
        else if (RuntimeType.STRING == value_color_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_color_2  = value_color as string
            valueSerializer.writeString(value_color_2)
        }
        else if (RuntimeType.OBJECT == value_color_type) {
            valueSerializer.writeInt8((3).toChar())
            const value_color_3  = value_color as Resource
            Resource_serializer.write(valueSerializer, value_color_3)
        }
    }
    public static read(buffer: DeserializerBase): PopupMaskType {
        let valueDeserializer : DeserializerBase = buffer
        const color_buf_selector : int32 = valueDeserializer.readInt8()
        let color_buf : Color | number | string | Resource | undefined
        if (color_buf_selector == (0).toChar()) {
            color_buf = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
        }
        else if (color_buf_selector == (1).toChar()) {
            color_buf = (valueDeserializer.readNumber() as number)
        }
        else if (color_buf_selector == (2).toChar()) {
            color_buf = (valueDeserializer.readString() as string)
        }
        else if (color_buf_selector == (3).toChar()) {
            color_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for color_buf has to be chosen through deserialisation.")
        }
        const color_result : ResourceColor = (color_buf as Color | number | string | Resource)
        let value : PopupMaskType = ({color: color_result} as PopupMaskType)
        return value
    }
}
export class ReuseOptions_serializer {
    public static write(buffer: SerializerBase, value: ReuseOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_reuseId  = value.reuseId
        let value_reuseId_type : int32 = RuntimeType.UNDEFINED
        value_reuseId_type = runtimeType(value_reuseId)
        valueSerializer.writeInt8((value_reuseId_type).toChar())
        if ((value_reuseId_type) != (RuntimeType.UNDEFINED)) {
            const value_reuseId_value  = value_reuseId!
            valueSerializer.holdAndWriteCallback(value_reuseId_value)
        }
    }
    public static read(buffer: DeserializerBase): ReuseOptions {
        let valueDeserializer : DeserializerBase = buffer
        const reuseId_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let reuseId_buf : ReuseIdCallback | undefined
        if ((reuseId_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const reuseId_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const reuseId_buf__call : KPointer = valueDeserializer.readPointer()
            const reuseId_buf__callSync : KPointer = valueDeserializer.readPointer()
            reuseId_buf = ():string => { 
    const reuseId_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    reuseId_buf__argsSerializer.writeInt32(reuseId_buf__resource.resourceId);
    reuseId_buf__argsSerializer.writePointer(reuseId_buf__call);
    reuseId_buf__argsSerializer.writePointer(reuseId_buf__callSync);
    let reuseId_buf__continuationValue : string | undefined;
    const reuseId_buf__continuationCallback : ((breakpoints: string) => void) = (value: string):void => {     reuseId_buf__continuationValue = value; }
    reuseId_buf__argsSerializer.holdAndWriteCallback(reuseId_buf__continuationCallback);
    InteropNativeModule._CallCallback(1110529154, reuseId_buf__argsSerializer.asBuffer(), reuseId_buf__argsSerializer.length());
    reuseId_buf__argsSerializer.release();
    return (reuseId_buf__continuationValue as string); }
        }
        const reuseId_result : ReuseIdCallback | undefined = reuseId_buf
        let value : ReuseOptions = ({reuseId: reuseId_result} as ReuseOptions)
        return value
    }
}
export class ShadowOptions_serializer {
    public static write(buffer: SerializerBase, value: ShadowOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        if (RuntimeType.NUMBER == value_radius_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_radius_0  = value_radius as number
            valueSerializer.writeNumber(value_radius_0)
        }
        else if (RuntimeType.OBJECT == value_radius_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_radius_1  = value_radius as Resource
            Resource_serializer.write(valueSerializer, value_radius_1)
        }
        const value_type  = value.type
        let value_type_type : int32 = RuntimeType.UNDEFINED
        value_type_type = runtimeType(value_type)
        valueSerializer.writeInt8((value_type_type).toChar())
        if ((value_type_type) != (RuntimeType.UNDEFINED)) {
            const value_type_value  = (value_type as ShadowType)
            valueSerializer.writeInt32(TypeChecker.ShadowType_ToNumeric(value_type_value))
        }
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as string
                valueSerializer.writeString(value_color_value_1)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_2)
            }
            else if (TypeChecker.isColoringStrategy(value_color_value)) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as ColoringStrategy
                valueSerializer.writeInt32(TypeChecker.ColoringStrategy_ToNumeric(value_color_value_3))
            }
        }
        const value_offsetX  = value.offsetX
        let value_offsetX_type : int32 = RuntimeType.UNDEFINED
        value_offsetX_type = runtimeType(value_offsetX)
        valueSerializer.writeInt8((value_offsetX_type).toChar())
        if ((value_offsetX_type) != (RuntimeType.UNDEFINED)) {
            const value_offsetX_value  = value_offsetX!
            let value_offsetX_value_type : int32 = RuntimeType.UNDEFINED
            value_offsetX_value_type = runtimeType(value_offsetX_value)
            if (RuntimeType.NUMBER == value_offsetX_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_offsetX_value_0  = value_offsetX_value as number
                valueSerializer.writeNumber(value_offsetX_value_0)
            }
            else if (RuntimeType.OBJECT == value_offsetX_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_offsetX_value_1  = value_offsetX_value as Resource
                Resource_serializer.write(valueSerializer, value_offsetX_value_1)
            }
        }
        const value_offsetY  = value.offsetY
        let value_offsetY_type : int32 = RuntimeType.UNDEFINED
        value_offsetY_type = runtimeType(value_offsetY)
        valueSerializer.writeInt8((value_offsetY_type).toChar())
        if ((value_offsetY_type) != (RuntimeType.UNDEFINED)) {
            const value_offsetY_value  = value_offsetY!
            let value_offsetY_value_type : int32 = RuntimeType.UNDEFINED
            value_offsetY_value_type = runtimeType(value_offsetY_value)
            if (RuntimeType.NUMBER == value_offsetY_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_offsetY_value_0  = value_offsetY_value as number
                valueSerializer.writeNumber(value_offsetY_value_0)
            }
            else if (RuntimeType.OBJECT == value_offsetY_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_offsetY_value_1  = value_offsetY_value as Resource
                Resource_serializer.write(valueSerializer, value_offsetY_value_1)
            }
        }
        const value_fill  = value.fill
        let value_fill_type : int32 = RuntimeType.UNDEFINED
        value_fill_type = runtimeType(value_fill)
        valueSerializer.writeInt8((value_fill_type).toChar())
        if ((value_fill_type) != (RuntimeType.UNDEFINED)) {
            const value_fill_value  = value_fill!
            valueSerializer.writeBoolean(value_fill_value)
        }
    }
    public static read(buffer: DeserializerBase): ShadowOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radius_buf_selector : int32 = valueDeserializer.readInt8()
        let radius_buf : number | Resource | undefined
        if (radius_buf_selector == (0).toChar()) {
            radius_buf = (valueDeserializer.readNumber() as number)
        }
        else if (radius_buf_selector == (1).toChar()) {
            radius_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for radius_buf has to be chosen through deserialisation.")
        }
        const radius_result : number | Resource = (radius_buf as number | Resource)
        const type_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let type_buf : ShadowType | undefined
        if ((type_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            type_buf = TypeChecker.ShadowType_FromNumeric(valueDeserializer.readInt32())
        }
        const type_result : ShadowType | undefined = type_buf
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : Color | string | Resource | ColoringStrategy | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | string | Resource | ColoringStrategy | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = TypeChecker.ColoringStrategy_FromNumeric(valueDeserializer.readInt32())
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | string | Resource | ColoringStrategy)
        }
        const color_result : Color | string | Resource | ColoringStrategy | undefined = color_buf
        const offsetX_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetX_buf : number | Resource | undefined
        if ((offsetX_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const offsetX_buf__selector : int32 = valueDeserializer.readInt8()
            let offsetX_buf_ : number | Resource | undefined
            if (offsetX_buf__selector == (0).toChar()) {
                offsetX_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (offsetX_buf__selector == (1).toChar()) {
                offsetX_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for offsetX_buf_ has to be chosen through deserialisation.")
            }
            offsetX_buf = (offsetX_buf_ as number | Resource)
        }
        const offsetX_result : number | Resource | undefined = offsetX_buf
        const offsetY_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetY_buf : number | Resource | undefined
        if ((offsetY_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const offsetY_buf__selector : int32 = valueDeserializer.readInt8()
            let offsetY_buf_ : number | Resource | undefined
            if (offsetY_buf__selector == (0).toChar()) {
                offsetY_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (offsetY_buf__selector == (1).toChar()) {
                offsetY_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for offsetY_buf_ has to be chosen through deserialisation.")
            }
            offsetY_buf = (offsetY_buf_ as number | Resource)
        }
        const offsetY_result : number | Resource | undefined = offsetY_buf
        const fill_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fill_buf : boolean | undefined
        if ((fill_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            fill_buf = valueDeserializer.readBoolean()
        }
        const fill_result : boolean | undefined = fill_buf
        let value : ShadowOptions = ({radius: radius_result, type: type_result, color: color_result, offsetX: offsetX_result, offsetY: offsetY_result, fill: fill_result} as ShadowOptions)
        return value
    }
}
export class sharedTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: sharedTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_duration  = value.duration
        let value_duration_type : int32 = RuntimeType.UNDEFINED
        value_duration_type = runtimeType(value_duration)
        valueSerializer.writeInt8((value_duration_type).toChar())
        if ((value_duration_type) != (RuntimeType.UNDEFINED)) {
            const value_duration_value  = value_duration!
            valueSerializer.writeNumber(value_duration_value)
        }
        const value_curve  = value.curve
        let value_curve_type : int32 = RuntimeType.UNDEFINED
        value_curve_type = runtimeType(value_curve)
        valueSerializer.writeInt8((value_curve_type).toChar())
        if ((value_curve_type) != (RuntimeType.UNDEFINED)) {
            const value_curve_value  = value_curve!
            let value_curve_value_type : int32 = RuntimeType.UNDEFINED
            value_curve_value_type = runtimeType(value_curve_value)
            if (TypeChecker.iscurves_Curve(value_curve_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_curve_value_0  = value_curve_value as curves.Curve
                valueSerializer.writeInt32(TypeChecker.curves_Curve_ToNumeric(value_curve_value_0))
            }
            else if (RuntimeType.STRING == value_curve_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_curve_value_1  = value_curve_value as string
                valueSerializer.writeString(value_curve_value_1)
            }
            else if (RuntimeType.OBJECT == value_curve_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_curve_value_2  = value_curve_value as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, value_curve_value_2)
            }
        }
        const value_delay  = value.delay
        let value_delay_type : int32 = RuntimeType.UNDEFINED
        value_delay_type = runtimeType(value_delay)
        valueSerializer.writeInt8((value_delay_type).toChar())
        if ((value_delay_type) != (RuntimeType.UNDEFINED)) {
            const value_delay_value  = value_delay!
            valueSerializer.writeNumber(value_delay_value)
        }
        const value_motionPath  = value.motionPath
        let value_motionPath_type : int32 = RuntimeType.UNDEFINED
        value_motionPath_type = runtimeType(value_motionPath)
        valueSerializer.writeInt8((value_motionPath_type).toChar())
        if ((value_motionPath_type) != (RuntimeType.UNDEFINED)) {
            const value_motionPath_value  = value_motionPath!
            MotionPathOptions_serializer.write(valueSerializer, value_motionPath_value)
        }
        const value_zIndex  = value.zIndex
        let value_zIndex_type : int32 = RuntimeType.UNDEFINED
        value_zIndex_type = runtimeType(value_zIndex)
        valueSerializer.writeInt8((value_zIndex_type).toChar())
        if ((value_zIndex_type) != (RuntimeType.UNDEFINED)) {
            const value_zIndex_value  = value_zIndex!
            valueSerializer.writeNumber(value_zIndex_value)
        }
        const value_type  = value.type
        let value_type_type : int32 = RuntimeType.UNDEFINED
        value_type_type = runtimeType(value_type)
        valueSerializer.writeInt8((value_type_type).toChar())
        if ((value_type_type) != (RuntimeType.UNDEFINED)) {
            const value_type_value  = (value_type as SharedTransitionEffectType)
            valueSerializer.writeInt32(TypeChecker.SharedTransitionEffectType_ToNumeric(value_type_value))
        }
    }
    public static read(buffer: DeserializerBase): sharedTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const duration_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let duration_buf : number | undefined
        if ((duration_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            duration_buf = (valueDeserializer.readNumber() as number)
        }
        const duration_result : number | undefined = duration_buf
        const curve_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curve_buf : curves.Curve | string | curves.ICurve | undefined
        if ((curve_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const curve_buf__selector : int32 = valueDeserializer.readInt8()
            let curve_buf_ : curves.Curve | string | curves.ICurve | undefined
            if (curve_buf__selector == (0).toChar()) {
                curve_buf_ = TypeChecker.curves_Curve_FromNumeric(valueDeserializer.readInt32())
            }
            else if (curve_buf__selector == (1).toChar()) {
                curve_buf_ = (valueDeserializer.readString() as string)
            }
            else if (curve_buf__selector == (2).toChar()) {
                curve_buf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            }
            else {
                throw new Error("One of the branches for curve_buf_ has to be chosen through deserialisation.")
            }
            curve_buf = (curve_buf_ as curves.Curve | string | curves.ICurve)
        }
        const curve_result : curves.Curve | string | curves.ICurve | undefined = curve_buf
        const delay_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delay_buf : number | undefined
        if ((delay_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            delay_buf = (valueDeserializer.readNumber() as number)
        }
        const delay_result : number | undefined = delay_buf
        const motionPath_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let motionPath_buf : MotionPathOptions | undefined
        if ((motionPath_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            motionPath_buf = MotionPathOptions_serializer.read(valueDeserializer)
        }
        const motionPath_result : MotionPathOptions | undefined = motionPath_buf
        const zIndex_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let zIndex_buf : number | undefined
        if ((zIndex_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            zIndex_buf = (valueDeserializer.readNumber() as number)
        }
        const zIndex_result : number | undefined = zIndex_buf
        const type_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let type_buf : SharedTransitionEffectType | undefined
        if ((type_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            type_buf = TypeChecker.SharedTransitionEffectType_FromNumeric(valueDeserializer.readInt32())
        }
        const type_result : SharedTransitionEffectType | undefined = type_buf
        let value : sharedTransitionOptions = ({duration: duration_result, curve: curve_result, delay: delay_result, motionPath: motionPath_result, zIndex: zIndex_result, type: type_result} as sharedTransitionOptions)
        return value
    }
}
export class SheetTitleOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetTitleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_title  = value.title
        let value_title_type : int32 = RuntimeType.UNDEFINED
        value_title_type = runtimeType(value_title)
        if (RuntimeType.STRING == value_title_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_title_0  = value_title as string
            valueSerializer.writeString(value_title_0)
        }
        else if (RuntimeType.OBJECT == value_title_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_title_1  = value_title as Resource
            Resource_serializer.write(valueSerializer, value_title_1)
        }
        const value_subtitle  = value.subtitle
        let value_subtitle_type : int32 = RuntimeType.UNDEFINED
        value_subtitle_type = runtimeType(value_subtitle)
        valueSerializer.writeInt8((value_subtitle_type).toChar())
        if ((value_subtitle_type) != (RuntimeType.UNDEFINED)) {
            const value_subtitle_value  = value_subtitle!
            let value_subtitle_value_type : int32 = RuntimeType.UNDEFINED
            value_subtitle_value_type = runtimeType(value_subtitle_value)
            if (RuntimeType.STRING == value_subtitle_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_subtitle_value_0  = value_subtitle_value as string
                valueSerializer.writeString(value_subtitle_value_0)
            }
            else if (RuntimeType.OBJECT == value_subtitle_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_subtitle_value_1  = value_subtitle_value as Resource
                Resource_serializer.write(valueSerializer, value_subtitle_value_1)
            }
        }
    }
    public static read(buffer: DeserializerBase): SheetTitleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const title_buf_selector : int32 = valueDeserializer.readInt8()
        let title_buf : string | Resource | undefined
        if (title_buf_selector == (0).toChar()) {
            title_buf = (valueDeserializer.readString() as string)
        }
        else if (title_buf_selector == (1).toChar()) {
            title_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for title_buf has to be chosen through deserialisation.")
        }
        const title_result : ResourceStr = (title_buf as string | Resource)
        const subtitle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let subtitle_buf : ResourceStr | undefined
        if ((subtitle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const subtitle_buf__selector : int32 = valueDeserializer.readInt8()
            let subtitle_buf_ : string | Resource | undefined
            if (subtitle_buf__selector == (0).toChar()) {
                subtitle_buf_ = (valueDeserializer.readString() as string)
            }
            else if (subtitle_buf__selector == (1).toChar()) {
                subtitle_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for subtitle_buf_ has to be chosen through deserialisation.")
            }
            subtitle_buf = (subtitle_buf_ as string | Resource)
        }
        const subtitle_result : ResourceStr | undefined = subtitle_buf
        let value : SheetTitleOptions = ({title: title_result, subtitle: subtitle_result} as SheetTitleOptions)
        return value
    }
}
export class TerminationInfo_serializer {
    public static write(buffer: SerializerBase, value: TerminationInfo): void {
        let valueSerializer : SerializerBase = buffer
        const value_code  = value.code
        valueSerializer.writeNumber(value_code)
        const value_want  = value.want
        let value_want_type : int32 = RuntimeType.UNDEFINED
        value_want_type = runtimeType(value_want)
        valueSerializer.writeInt8((value_want_type).toChar())
        if ((value_want_type) != (RuntimeType.UNDEFINED)) {
            const value_want_value  = value_want!
            Want_serializer.write(valueSerializer, value_want_value)
        }
    }
    public static read(buffer: DeserializerBase): TerminationInfo {
        let valueDeserializer : DeserializerBase = buffer
        const code_result : number = (valueDeserializer.readNumber() as number)
        const want_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let want_buf : Want | undefined
        if ((want_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            want_buf = Want_serializer.read(valueDeserializer)
        }
        const want_result : Want | undefined = want_buf
        let value : TerminationInfo = ({code: code_result, want: want_result} as TerminationInfo)
        return value
    }
}
export class TextDecorationOptions_serializer {
    public static write(buffer: SerializerBase, value: TextDecorationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_type  = value.type
        valueSerializer.writeInt32(TypeChecker.TextDecorationType_ToNumeric(value_type))
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.NUMBER == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as number
                valueSerializer.writeNumber(value_color_value_1)
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as string
                valueSerializer.writeString(value_color_value_2)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_3)
            }
        }
        const value_style  = value.style
        let value_style_type : int32 = RuntimeType.UNDEFINED
        value_style_type = runtimeType(value_style)
        valueSerializer.writeInt8((value_style_type).toChar())
        if ((value_style_type) != (RuntimeType.UNDEFINED)) {
            const value_style_value  = (value_style as TextDecorationStyle)
            valueSerializer.writeInt32(TypeChecker.TextDecorationStyle_ToNumeric(value_style_value))
        }
    }
    public static read(buffer: DeserializerBase): TextDecorationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const type_result : TextDecorationType = TypeChecker.TextDecorationType_FromNumeric(valueDeserializer.readInt32())
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : ResourceColor | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | number | string | Resource | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | number | string | Resource)
        }
        const color_result : ResourceColor | undefined = color_buf
        const style_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let style_buf : TextDecorationStyle | undefined
        if ((style_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            style_buf = TypeChecker.TextDecorationStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const style_result : TextDecorationStyle | undefined = style_buf
        let value : TextDecorationOptions = ({type: type_result, color: color_result, style: style_result} as TextDecorationOptions)
        return value
    }
}
export class DividerStyle_serializer {
    public static write(buffer: SerializerBase, value: DividerStyle): void {
        let valueSerializer : SerializerBase = buffer
        const value_strokeWidth  = value.strokeWidth
        let value_strokeWidth_type : int32 = RuntimeType.UNDEFINED
        value_strokeWidth_type = runtimeType(value_strokeWidth)
        if (RuntimeType.STRING == value_strokeWidth_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_strokeWidth_0  = value_strokeWidth as string
            valueSerializer.writeString(value_strokeWidth_0)
        }
        else if (RuntimeType.NUMBER == value_strokeWidth_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_strokeWidth_1  = value_strokeWidth as number
            valueSerializer.writeNumber(value_strokeWidth_1)
        }
        else if (RuntimeType.OBJECT == value_strokeWidth_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_strokeWidth_2  = value_strokeWidth as Resource
            Resource_serializer.write(valueSerializer, value_strokeWidth_2)
        }
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.NUMBER == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as number
                valueSerializer.writeNumber(value_color_value_1)
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as string
                valueSerializer.writeString(value_color_value_2)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_3)
            }
        }
        const value_startMargin  = value.startMargin
        let value_startMargin_type : int32 = RuntimeType.UNDEFINED
        value_startMargin_type = runtimeType(value_startMargin)
        valueSerializer.writeInt8((value_startMargin_type).toChar())
        if ((value_startMargin_type) != (RuntimeType.UNDEFINED)) {
            const value_startMargin_value  = value_startMargin!
            let value_startMargin_value_type : int32 = RuntimeType.UNDEFINED
            value_startMargin_value_type = runtimeType(value_startMargin_value)
            if (RuntimeType.STRING == value_startMargin_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_startMargin_value_0  = value_startMargin_value as string
                valueSerializer.writeString(value_startMargin_value_0)
            }
            else if (RuntimeType.NUMBER == value_startMargin_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_startMargin_value_1  = value_startMargin_value as number
                valueSerializer.writeNumber(value_startMargin_value_1)
            }
            else if (RuntimeType.OBJECT == value_startMargin_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_startMargin_value_2  = value_startMargin_value as Resource
                Resource_serializer.write(valueSerializer, value_startMargin_value_2)
            }
        }
        const value_endMargin  = value.endMargin
        let value_endMargin_type : int32 = RuntimeType.UNDEFINED
        value_endMargin_type = runtimeType(value_endMargin)
        valueSerializer.writeInt8((value_endMargin_type).toChar())
        if ((value_endMargin_type) != (RuntimeType.UNDEFINED)) {
            const value_endMargin_value  = value_endMargin!
            let value_endMargin_value_type : int32 = RuntimeType.UNDEFINED
            value_endMargin_value_type = runtimeType(value_endMargin_value)
            if (RuntimeType.STRING == value_endMargin_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_endMargin_value_0  = value_endMargin_value as string
                valueSerializer.writeString(value_endMargin_value_0)
            }
            else if (RuntimeType.NUMBER == value_endMargin_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_endMargin_value_1  = value_endMargin_value as number
                valueSerializer.writeNumber(value_endMargin_value_1)
            }
            else if (RuntimeType.OBJECT == value_endMargin_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_endMargin_value_2  = value_endMargin_value as Resource
                Resource_serializer.write(valueSerializer, value_endMargin_value_2)
            }
        }
    }
    public static read(buffer: DeserializerBase): DividerStyle {
        let valueDeserializer : DeserializerBase = buffer
        const strokeWidth_buf_selector : int32 = valueDeserializer.readInt8()
        let strokeWidth_buf : string | number | Resource | undefined
        if (strokeWidth_buf_selector == (0).toChar()) {
            strokeWidth_buf = (valueDeserializer.readString() as string)
        }
        else if (strokeWidth_buf_selector == (1).toChar()) {
            strokeWidth_buf = (valueDeserializer.readNumber() as number)
        }
        else if (strokeWidth_buf_selector == (2).toChar()) {
            strokeWidth_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for strokeWidth_buf has to be chosen through deserialisation.")
        }
        const strokeWidth_result : Length = (strokeWidth_buf as string | number | Resource)
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : ResourceColor | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | number | string | Resource | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | number | string | Resource)
        }
        const color_result : ResourceColor | undefined = color_buf
        const startMargin_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startMargin_buf : Length | undefined
        if ((startMargin_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const startMargin_buf__selector : int32 = valueDeserializer.readInt8()
            let startMargin_buf_ : string | number | Resource | undefined
            if (startMargin_buf__selector == (0).toChar()) {
                startMargin_buf_ = (valueDeserializer.readString() as string)
            }
            else if (startMargin_buf__selector == (1).toChar()) {
                startMargin_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (startMargin_buf__selector == (2).toChar()) {
                startMargin_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for startMargin_buf_ has to be chosen through deserialisation.")
            }
            startMargin_buf = (startMargin_buf_ as string | number | Resource)
        }
        const startMargin_result : Length | undefined = startMargin_buf
        const endMargin_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endMargin_buf : Length | undefined
        if ((endMargin_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const endMargin_buf__selector : int32 = valueDeserializer.readInt8()
            let endMargin_buf_ : string | number | Resource | undefined
            if (endMargin_buf__selector == (0).toChar()) {
                endMargin_buf_ = (valueDeserializer.readString() as string)
            }
            else if (endMargin_buf__selector == (1).toChar()) {
                endMargin_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (endMargin_buf__selector == (2).toChar()) {
                endMargin_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for endMargin_buf_ has to be chosen through deserialisation.")
            }
            endMargin_buf = (endMargin_buf_ as string | number | Resource)
        }
        const endMargin_result : Length | undefined = endMargin_buf
        let value : DividerStyle = ({strokeWidth: strokeWidth_result, color: color_result, startMargin: startMargin_result, endMargin: endMargin_result} as DividerStyle)
        return value
    }
}
export class PixelStretchEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: PixelStretchEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_top  = value.top
        let value_top_type : int32 = RuntimeType.UNDEFINED
        value_top_type = runtimeType(value_top)
        valueSerializer.writeInt8((value_top_type).toChar())
        if ((value_top_type) != (RuntimeType.UNDEFINED)) {
            const value_top_value  = value_top!
            let value_top_value_type : int32 = RuntimeType.UNDEFINED
            value_top_value_type = runtimeType(value_top_value)
            if (RuntimeType.STRING == value_top_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_top_value_0  = value_top_value as string
                valueSerializer.writeString(value_top_value_0)
            }
            else if (RuntimeType.NUMBER == value_top_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_top_value_1  = value_top_value as number
                valueSerializer.writeNumber(value_top_value_1)
            }
            else if (RuntimeType.OBJECT == value_top_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_top_value_2  = value_top_value as Resource
                Resource_serializer.write(valueSerializer, value_top_value_2)
            }
        }
        const value_bottom  = value.bottom
        let value_bottom_type : int32 = RuntimeType.UNDEFINED
        value_bottom_type = runtimeType(value_bottom)
        valueSerializer.writeInt8((value_bottom_type).toChar())
        if ((value_bottom_type) != (RuntimeType.UNDEFINED)) {
            const value_bottom_value  = value_bottom!
            let value_bottom_value_type : int32 = RuntimeType.UNDEFINED
            value_bottom_value_type = runtimeType(value_bottom_value)
            if (RuntimeType.STRING == value_bottom_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_bottom_value_0  = value_bottom_value as string
                valueSerializer.writeString(value_bottom_value_0)
            }
            else if (RuntimeType.NUMBER == value_bottom_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_bottom_value_1  = value_bottom_value as number
                valueSerializer.writeNumber(value_bottom_value_1)
            }
            else if (RuntimeType.OBJECT == value_bottom_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_bottom_value_2  = value_bottom_value as Resource
                Resource_serializer.write(valueSerializer, value_bottom_value_2)
            }
        }
        const value_left  = value.left
        let value_left_type : int32 = RuntimeType.UNDEFINED
        value_left_type = runtimeType(value_left)
        valueSerializer.writeInt8((value_left_type).toChar())
        if ((value_left_type) != (RuntimeType.UNDEFINED)) {
            const value_left_value  = value_left!
            let value_left_value_type : int32 = RuntimeType.UNDEFINED
            value_left_value_type = runtimeType(value_left_value)
            if (RuntimeType.STRING == value_left_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_left_value_0  = value_left_value as string
                valueSerializer.writeString(value_left_value_0)
            }
            else if (RuntimeType.NUMBER == value_left_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_left_value_1  = value_left_value as number
                valueSerializer.writeNumber(value_left_value_1)
            }
            else if (RuntimeType.OBJECT == value_left_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_left_value_2  = value_left_value as Resource
                Resource_serializer.write(valueSerializer, value_left_value_2)
            }
        }
        const value_right  = value.right
        let value_right_type : int32 = RuntimeType.UNDEFINED
        value_right_type = runtimeType(value_right)
        valueSerializer.writeInt8((value_right_type).toChar())
        if ((value_right_type) != (RuntimeType.UNDEFINED)) {
            const value_right_value  = value_right!
            let value_right_value_type : int32 = RuntimeType.UNDEFINED
            value_right_value_type = runtimeType(value_right_value)
            if (RuntimeType.STRING == value_right_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_right_value_0  = value_right_value as string
                valueSerializer.writeString(value_right_value_0)
            }
            else if (RuntimeType.NUMBER == value_right_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_right_value_1  = value_right_value as number
                valueSerializer.writeNumber(value_right_value_1)
            }
            else if (RuntimeType.OBJECT == value_right_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_right_value_2  = value_right_value as Resource
                Resource_serializer.write(valueSerializer, value_right_value_2)
            }
        }
    }
    public static read(buffer: DeserializerBase): PixelStretchEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const top_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let top_buf : Length | undefined
        if ((top_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const top_buf__selector : int32 = valueDeserializer.readInt8()
            let top_buf_ : string | number | Resource | undefined
            if (top_buf__selector == (0).toChar()) {
                top_buf_ = (valueDeserializer.readString() as string)
            }
            else if (top_buf__selector == (1).toChar()) {
                top_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (top_buf__selector == (2).toChar()) {
                top_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for top_buf_ has to be chosen through deserialisation.")
            }
            top_buf = (top_buf_ as string | number | Resource)
        }
        const top_result : Length | undefined = top_buf
        const bottom_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottom_buf : Length | undefined
        if ((bottom_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const bottom_buf__selector : int32 = valueDeserializer.readInt8()
            let bottom_buf_ : string | number | Resource | undefined
            if (bottom_buf__selector == (0).toChar()) {
                bottom_buf_ = (valueDeserializer.readString() as string)
            }
            else if (bottom_buf__selector == (1).toChar()) {
                bottom_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (bottom_buf__selector == (2).toChar()) {
                bottom_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for bottom_buf_ has to be chosen through deserialisation.")
            }
            bottom_buf = (bottom_buf_ as string | number | Resource)
        }
        const bottom_result : Length | undefined = bottom_buf
        const left_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let left_buf : Length | undefined
        if ((left_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const left_buf__selector : int32 = valueDeserializer.readInt8()
            let left_buf_ : string | number | Resource | undefined
            if (left_buf__selector == (0).toChar()) {
                left_buf_ = (valueDeserializer.readString() as string)
            }
            else if (left_buf__selector == (1).toChar()) {
                left_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (left_buf__selector == (2).toChar()) {
                left_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for left_buf_ has to be chosen through deserialisation.")
            }
            left_buf = (left_buf_ as string | number | Resource)
        }
        const left_result : Length | undefined = left_buf
        const right_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let right_buf : Length | undefined
        if ((right_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const right_buf__selector : int32 = valueDeserializer.readInt8()
            let right_buf_ : string | number | Resource | undefined
            if (right_buf__selector == (0).toChar()) {
                right_buf_ = (valueDeserializer.readString() as string)
            }
            else if (right_buf__selector == (1).toChar()) {
                right_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (right_buf__selector == (2).toChar()) {
                right_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for right_buf_ has to be chosen through deserialisation.")
            }
            right_buf = (right_buf_ as string | number | Resource)
        }
        const right_result : Length | undefined = right_buf
        let value : PixelStretchEffectOptions = ({top: top_result, bottom: bottom_result, left: left_result, right: right_result} as PixelStretchEffectOptions)
        return value
    }
}
export class PointLightStyle_serializer {
    public static write(buffer: SerializerBase, value: PointLightStyle): void {
        let valueSerializer : SerializerBase = buffer
        const value_lightSource  = value.lightSource
        let value_lightSource_type : int32 = RuntimeType.UNDEFINED
        value_lightSource_type = runtimeType(value_lightSource)
        valueSerializer.writeInt8((value_lightSource_type).toChar())
        if ((value_lightSource_type) != (RuntimeType.UNDEFINED)) {
            const value_lightSource_value  = value_lightSource!
            LightSource_serializer.write(valueSerializer, value_lightSource_value)
        }
        const value_illuminated  = value.illuminated
        let value_illuminated_type : int32 = RuntimeType.UNDEFINED
        value_illuminated_type = runtimeType(value_illuminated)
        valueSerializer.writeInt8((value_illuminated_type).toChar())
        if ((value_illuminated_type) != (RuntimeType.UNDEFINED)) {
            const value_illuminated_value  = (value_illuminated as IlluminatedType)
            valueSerializer.writeInt32(TypeChecker.IlluminatedType_ToNumeric(value_illuminated_value))
        }
        const value_bloom  = value.bloom
        let value_bloom_type : int32 = RuntimeType.UNDEFINED
        value_bloom_type = runtimeType(value_bloom)
        valueSerializer.writeInt8((value_bloom_type).toChar())
        if ((value_bloom_type) != (RuntimeType.UNDEFINED)) {
            const value_bloom_value  = value_bloom!
            valueSerializer.writeNumber(value_bloom_value)
        }
    }
    public static read(buffer: DeserializerBase): PointLightStyle {
        let valueDeserializer : DeserializerBase = buffer
        const lightSource_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let lightSource_buf : LightSource | undefined
        if ((lightSource_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            lightSource_buf = LightSource_serializer.read(valueDeserializer)
        }
        const lightSource_result : LightSource | undefined = lightSource_buf
        const illuminated_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let illuminated_buf : IlluminatedType | undefined
        if ((illuminated_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            illuminated_buf = TypeChecker.IlluminatedType_FromNumeric(valueDeserializer.readInt32())
        }
        const illuminated_result : IlluminatedType | undefined = illuminated_buf
        const bloom_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bloom_buf : number | undefined
        if ((bloom_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            bloom_buf = (valueDeserializer.readNumber() as number)
        }
        const bloom_result : number | undefined = bloom_buf
        let value : PointLightStyle = ({lightSource: lightSource_result, illuminated: illuminated_result, bloom: bloom_result} as PointLightStyle)
        return value
    }
}
export class RadialGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: RadialGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_center  = value.center
        const value_center_0  = value_center[0]
        let value_center_0_type : int32 = RuntimeType.UNDEFINED
        value_center_0_type = runtimeType(value_center_0)
        if (RuntimeType.STRING == value_center_0_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_center_0_0  = value_center_0 as string
            valueSerializer.writeString(value_center_0_0)
        }
        else if (RuntimeType.NUMBER == value_center_0_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_center_0_1  = value_center_0 as number
            valueSerializer.writeNumber(value_center_0_1)
        }
        else if (RuntimeType.OBJECT == value_center_0_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_center_0_2  = value_center_0 as Resource
            Resource_serializer.write(valueSerializer, value_center_0_2)
        }
        const value_center_1  = value_center[1]
        let value_center_1_type : int32 = RuntimeType.UNDEFINED
        value_center_1_type = runtimeType(value_center_1)
        if (RuntimeType.STRING == value_center_1_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_center_1_0  = value_center_1 as string
            valueSerializer.writeString(value_center_1_0)
        }
        else if (RuntimeType.NUMBER == value_center_1_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_center_1_1  = value_center_1 as number
            valueSerializer.writeNumber(value_center_1_1)
        }
        else if (RuntimeType.OBJECT == value_center_1_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_center_1_2  = value_center_1 as Resource
            Resource_serializer.write(valueSerializer, value_center_1_2)
        }
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        if (RuntimeType.STRING == value_radius_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_radius_0  = value_radius as string
            valueSerializer.writeString(value_radius_0)
        }
        else if (RuntimeType.NUMBER == value_radius_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_radius_1  = value_radius as number
            valueSerializer.writeNumber(value_radius_1)
        }
        else if (RuntimeType.OBJECT == value_radius_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_radius_2  = value_radius as Resource
            Resource_serializer.write(valueSerializer, value_radius_2)
        }
        const value_colors  = value.colors
        valueSerializer.writeInt32((value_colors.length).toInt())
        for (let value_colors_counter_i = 0; value_colors_counter_i < value_colors.length; value_colors_counter_i++) {
            const value_colors_element : [ ResourceColor, number ] = value_colors[value_colors_counter_i]
            const value_colors_element_0  = value_colors_element[0]
            let value_colors_element_0_type : int32 = RuntimeType.UNDEFINED
            value_colors_element_0_type = runtimeType(value_colors_element_0)
            if (TypeChecker.isColor(value_colors_element_0)) {
                valueSerializer.writeInt8((0).toChar())
                const value_colors_element_0_0  = value_colors_element_0 as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_colors_element_0_0))
            }
            else if (RuntimeType.NUMBER == value_colors_element_0_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_colors_element_0_1  = value_colors_element_0 as number
                valueSerializer.writeNumber(value_colors_element_0_1)
            }
            else if (RuntimeType.STRING == value_colors_element_0_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_colors_element_0_2  = value_colors_element_0 as string
                valueSerializer.writeString(value_colors_element_0_2)
            }
            else if (RuntimeType.OBJECT == value_colors_element_0_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_colors_element_0_3  = value_colors_element_0 as Resource
                Resource_serializer.write(valueSerializer, value_colors_element_0_3)
            }
            const value_colors_element_1  = value_colors_element[1]
            valueSerializer.writeNumber(value_colors_element_1)
        }
        const value_repeating  = value.repeating
        let value_repeating_type : int32 = RuntimeType.UNDEFINED
        value_repeating_type = runtimeType(value_repeating)
        valueSerializer.writeInt8((value_repeating_type).toChar())
        if ((value_repeating_type) != (RuntimeType.UNDEFINED)) {
            const value_repeating_value  = value_repeating!
            valueSerializer.writeBoolean(value_repeating_value)
        }
    }
    public static read(buffer: DeserializerBase): RadialGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const center_buf_value0_buf_selector : int32 = valueDeserializer.readInt8()
        let center_buf_value0_buf : string | number | Resource | undefined
        if (center_buf_value0_buf_selector == (0).toChar()) {
            center_buf_value0_buf = (valueDeserializer.readString() as string)
        }
        else if (center_buf_value0_buf_selector == (1).toChar()) {
            center_buf_value0_buf = (valueDeserializer.readNumber() as number)
        }
        else if (center_buf_value0_buf_selector == (2).toChar()) {
            center_buf_value0_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for center_buf_value0_buf has to be chosen through deserialisation.")
        }
        const center_buf_value0 : Length = (center_buf_value0_buf as string | number | Resource)
        const center_buf_value1_buf_selector : int32 = valueDeserializer.readInt8()
        let center_buf_value1_buf : string | number | Resource | undefined
        if (center_buf_value1_buf_selector == (0).toChar()) {
            center_buf_value1_buf = (valueDeserializer.readString() as string)
        }
        else if (center_buf_value1_buf_selector == (1).toChar()) {
            center_buf_value1_buf = (valueDeserializer.readNumber() as number)
        }
        else if (center_buf_value1_buf_selector == (2).toChar()) {
            center_buf_value1_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for center_buf_value1_buf has to be chosen through deserialisation.")
        }
        const center_buf_value1 : Length = (center_buf_value1_buf as string | number | Resource)
        const center_result : [ Length, Length ] = ([center_buf_value0, center_buf_value1] as [ Length, Length ])
        const radius_buf_selector : int32 = valueDeserializer.readInt8()
        let radius_buf : string | number | Resource | undefined
        if (radius_buf_selector == (0).toChar()) {
            radius_buf = (valueDeserializer.readString() as string)
        }
        else if (radius_buf_selector == (1).toChar()) {
            radius_buf = (valueDeserializer.readNumber() as number)
        }
        else if (radius_buf_selector == (2).toChar()) {
            radius_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for radius_buf has to be chosen through deserialisation.")
        }
        const radius_result : Length = (radius_buf as string | number | Resource)
        const colors_buf_length : int32 = valueDeserializer.readInt32()
        let colors_buf : Array<[ ResourceColor, number ]> = new Array<[ ResourceColor, number ]>(colors_buf_length)
        for (let colors_buf_i = 0; colors_buf_i < colors_buf_length; colors_buf_i++) {
            const colors_buf_buf_value0_buf_selector : int32 = valueDeserializer.readInt8()
            let colors_buf_buf_value0_buf : Color | number | string | Resource | undefined
            if (colors_buf_buf_value0_buf_selector == (0).toChar()) {
                colors_buf_buf_value0_buf = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (colors_buf_buf_value0_buf_selector == (1).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readNumber() as number)
            }
            else if (colors_buf_buf_value0_buf_selector == (2).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readString() as string)
            }
            else if (colors_buf_buf_value0_buf_selector == (3).toChar()) {
                colors_buf_buf_value0_buf = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for colors_buf_buf_value0_buf has to be chosen through deserialisation.")
            }
            const colors_buf_buf_value0 : ResourceColor = (colors_buf_buf_value0_buf as Color | number | string | Resource)
            const colors_buf_buf_value1 : number = (valueDeserializer.readNumber() as number)
            colors_buf[colors_buf_i] = ([colors_buf_buf_value0, colors_buf_buf_value1] as [ ResourceColor, number ])
        }
        const colors_result : Array<[ ResourceColor, number ]> = colors_buf
        const repeating_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeating_buf : boolean | undefined
        if ((repeating_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            repeating_buf = valueDeserializer.readBoolean()
        }
        const repeating_result : boolean | undefined = repeating_buf
        let value : RadialGradientOptions = ({center: center_result, radius: radius_result, colors: colors_result, repeating: repeating_result} as RadialGradientOptions)
        return value
    }
}
export class Rectangle_serializer {
    public static write(buffer: SerializerBase, value: Rectangle): void {
        let valueSerializer : SerializerBase = buffer
        const value_x  = value.x
        let value_x_type : int32 = RuntimeType.UNDEFINED
        value_x_type = runtimeType(value_x)
        valueSerializer.writeInt8((value_x_type).toChar())
        if ((value_x_type) != (RuntimeType.UNDEFINED)) {
            const value_x_value  = value_x!
            let value_x_value_type : int32 = RuntimeType.UNDEFINED
            value_x_value_type = runtimeType(value_x_value)
            if (RuntimeType.STRING == value_x_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_x_value_0  = value_x_value as string
                valueSerializer.writeString(value_x_value_0)
            }
            else if (RuntimeType.NUMBER == value_x_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_x_value_1  = value_x_value as number
                valueSerializer.writeNumber(value_x_value_1)
            }
            else if (RuntimeType.OBJECT == value_x_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_x_value_2  = value_x_value as Resource
                Resource_serializer.write(valueSerializer, value_x_value_2)
            }
        }
        const value_y  = value.y
        let value_y_type : int32 = RuntimeType.UNDEFINED
        value_y_type = runtimeType(value_y)
        valueSerializer.writeInt8((value_y_type).toChar())
        if ((value_y_type) != (RuntimeType.UNDEFINED)) {
            const value_y_value  = value_y!
            let value_y_value_type : int32 = RuntimeType.UNDEFINED
            value_y_value_type = runtimeType(value_y_value)
            if (RuntimeType.STRING == value_y_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_y_value_0  = value_y_value as string
                valueSerializer.writeString(value_y_value_0)
            }
            else if (RuntimeType.NUMBER == value_y_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_y_value_1  = value_y_value as number
                valueSerializer.writeNumber(value_y_value_1)
            }
            else if (RuntimeType.OBJECT == value_y_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_y_value_2  = value_y_value as Resource
                Resource_serializer.write(valueSerializer, value_y_value_2)
            }
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if (RuntimeType.STRING == value_width_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as string
                valueSerializer.writeString(value_width_value_0)
            }
            else if (RuntimeType.NUMBER == value_width_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as number
                valueSerializer.writeNumber(value_width_value_1)
            }
            else if (RuntimeType.OBJECT == value_width_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as Resource
                Resource_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_height  = value.height
        let value_height_type : int32 = RuntimeType.UNDEFINED
        value_height_type = runtimeType(value_height)
        valueSerializer.writeInt8((value_height_type).toChar())
        if ((value_height_type) != (RuntimeType.UNDEFINED)) {
            const value_height_value  = value_height!
            let value_height_value_type : int32 = RuntimeType.UNDEFINED
            value_height_value_type = runtimeType(value_height_value)
            if (RuntimeType.STRING == value_height_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_height_value_0  = value_height_value as string
                valueSerializer.writeString(value_height_value_0)
            }
            else if (RuntimeType.NUMBER == value_height_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_height_value_1  = value_height_value as number
                valueSerializer.writeNumber(value_height_value_1)
            }
            else if (RuntimeType.OBJECT == value_height_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_height_value_2  = value_height_value as Resource
                Resource_serializer.write(valueSerializer, value_height_value_2)
            }
        }
    }
    public static read(buffer: DeserializerBase): Rectangle {
        let valueDeserializer : DeserializerBase = buffer
        const x_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let x_buf : Length | undefined
        if ((x_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const x_buf__selector : int32 = valueDeserializer.readInt8()
            let x_buf_ : string | number | Resource | undefined
            if (x_buf__selector == (0).toChar()) {
                x_buf_ = (valueDeserializer.readString() as string)
            }
            else if (x_buf__selector == (1).toChar()) {
                x_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (x_buf__selector == (2).toChar()) {
                x_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for x_buf_ has to be chosen through deserialisation.")
            }
            x_buf = (x_buf_ as string | number | Resource)
        }
        const x_result : Length | undefined = x_buf
        const y_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let y_buf : Length | undefined
        if ((y_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const y_buf__selector : int32 = valueDeserializer.readInt8()
            let y_buf_ : string | number | Resource | undefined
            if (y_buf__selector == (0).toChar()) {
                y_buf_ = (valueDeserializer.readString() as string)
            }
            else if (y_buf__selector == (1).toChar()) {
                y_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (y_buf__selector == (2).toChar()) {
                y_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for y_buf_ has to be chosen through deserialisation.")
            }
            y_buf = (y_buf_ as string | number | Resource)
        }
        const y_result : Length | undefined = y_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Length | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : string | number | Resource | undefined
            if (width_buf__selector == (0).toChar()) {
                width_buf_ = (valueDeserializer.readString() as string)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as string | number | Resource)
        }
        const width_result : Length | undefined = width_buf
        const height_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let height_buf : Length | undefined
        if ((height_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const height_buf__selector : int32 = valueDeserializer.readInt8()
            let height_buf_ : string | number | Resource | undefined
            if (height_buf__selector == (0).toChar()) {
                height_buf_ = (valueDeserializer.readString() as string)
            }
            else if (height_buf__selector == (1).toChar()) {
                height_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (height_buf__selector == (2).toChar()) {
                height_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for height_buf_ has to be chosen through deserialisation.")
            }
            height_buf = (height_buf_ as string | number | Resource)
        }
        const height_result : Length | undefined = height_buf
        let value : Rectangle = ({x: x_result, y: y_result, width: width_result, height: height_result} as Rectangle)
        return value
    }
}
export class SweepGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: SweepGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_center  = value.center
        const value_center_0  = value_center[0]
        let value_center_0_type : int32 = RuntimeType.UNDEFINED
        value_center_0_type = runtimeType(value_center_0)
        if (RuntimeType.STRING == value_center_0_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_center_0_0  = value_center_0 as string
            valueSerializer.writeString(value_center_0_0)
        }
        else if (RuntimeType.NUMBER == value_center_0_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_center_0_1  = value_center_0 as number
            valueSerializer.writeNumber(value_center_0_1)
        }
        else if (RuntimeType.OBJECT == value_center_0_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_center_0_2  = value_center_0 as Resource
            Resource_serializer.write(valueSerializer, value_center_0_2)
        }
        const value_center_1  = value_center[1]
        let value_center_1_type : int32 = RuntimeType.UNDEFINED
        value_center_1_type = runtimeType(value_center_1)
        if (RuntimeType.STRING == value_center_1_type) {
            valueSerializer.writeInt8((0).toChar())
            const value_center_1_0  = value_center_1 as string
            valueSerializer.writeString(value_center_1_0)
        }
        else if (RuntimeType.NUMBER == value_center_1_type) {
            valueSerializer.writeInt8((1).toChar())
            const value_center_1_1  = value_center_1 as number
            valueSerializer.writeNumber(value_center_1_1)
        }
        else if (RuntimeType.OBJECT == value_center_1_type) {
            valueSerializer.writeInt8((2).toChar())
            const value_center_1_2  = value_center_1 as Resource
            Resource_serializer.write(valueSerializer, value_center_1_2)
        }
        const value_start  = value.start
        let value_start_type : int32 = RuntimeType.UNDEFINED
        value_start_type = runtimeType(value_start)
        valueSerializer.writeInt8((value_start_type).toChar())
        if ((value_start_type) != (RuntimeType.UNDEFINED)) {
            const value_start_value  = value_start!
            let value_start_value_type : int32 = RuntimeType.UNDEFINED
            value_start_value_type = runtimeType(value_start_value)
            if (RuntimeType.NUMBER == value_start_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_start_value_0  = value_start_value as number
                valueSerializer.writeNumber(value_start_value_0)
            }
            else if (RuntimeType.STRING == value_start_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_start_value_1  = value_start_value as string
                valueSerializer.writeString(value_start_value_1)
            }
        }
        const value_end  = value.end
        let value_end_type : int32 = RuntimeType.UNDEFINED
        value_end_type = runtimeType(value_end)
        valueSerializer.writeInt8((value_end_type).toChar())
        if ((value_end_type) != (RuntimeType.UNDEFINED)) {
            const value_end_value  = value_end!
            let value_end_value_type : int32 = RuntimeType.UNDEFINED
            value_end_value_type = runtimeType(value_end_value)
            if (RuntimeType.NUMBER == value_end_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_end_value_0  = value_end_value as number
                valueSerializer.writeNumber(value_end_value_0)
            }
            else if (RuntimeType.STRING == value_end_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_end_value_1  = value_end_value as string
                valueSerializer.writeString(value_end_value_1)
            }
        }
        const value_rotation  = value.rotation
        let value_rotation_type : int32 = RuntimeType.UNDEFINED
        value_rotation_type = runtimeType(value_rotation)
        valueSerializer.writeInt8((value_rotation_type).toChar())
        if ((value_rotation_type) != (RuntimeType.UNDEFINED)) {
            const value_rotation_value  = value_rotation!
            let value_rotation_value_type : int32 = RuntimeType.UNDEFINED
            value_rotation_value_type = runtimeType(value_rotation_value)
            if (RuntimeType.NUMBER == value_rotation_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_rotation_value_0  = value_rotation_value as number
                valueSerializer.writeNumber(value_rotation_value_0)
            }
            else if (RuntimeType.STRING == value_rotation_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_rotation_value_1  = value_rotation_value as string
                valueSerializer.writeString(value_rotation_value_1)
            }
        }
        const value_colors  = value.colors
        valueSerializer.writeInt32((value_colors.length).toInt())
        for (let value_colors_counter_i = 0; value_colors_counter_i < value_colors.length; value_colors_counter_i++) {
            const value_colors_element : [ ResourceColor, number ] = value_colors[value_colors_counter_i]
            const value_colors_element_0  = value_colors_element[0]
            let value_colors_element_0_type : int32 = RuntimeType.UNDEFINED
            value_colors_element_0_type = runtimeType(value_colors_element_0)
            if (TypeChecker.isColor(value_colors_element_0)) {
                valueSerializer.writeInt8((0).toChar())
                const value_colors_element_0_0  = value_colors_element_0 as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_colors_element_0_0))
            }
            else if (RuntimeType.NUMBER == value_colors_element_0_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_colors_element_0_1  = value_colors_element_0 as number
                valueSerializer.writeNumber(value_colors_element_0_1)
            }
            else if (RuntimeType.STRING == value_colors_element_0_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_colors_element_0_2  = value_colors_element_0 as string
                valueSerializer.writeString(value_colors_element_0_2)
            }
            else if (RuntimeType.OBJECT == value_colors_element_0_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_colors_element_0_3  = value_colors_element_0 as Resource
                Resource_serializer.write(valueSerializer, value_colors_element_0_3)
            }
            const value_colors_element_1  = value_colors_element[1]
            valueSerializer.writeNumber(value_colors_element_1)
        }
        const value_repeating  = value.repeating
        let value_repeating_type : int32 = RuntimeType.UNDEFINED
        value_repeating_type = runtimeType(value_repeating)
        valueSerializer.writeInt8((value_repeating_type).toChar())
        if ((value_repeating_type) != (RuntimeType.UNDEFINED)) {
            const value_repeating_value  = value_repeating!
            valueSerializer.writeBoolean(value_repeating_value)
        }
    }
    public static read(buffer: DeserializerBase): SweepGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const center_buf_value0_buf_selector : int32 = valueDeserializer.readInt8()
        let center_buf_value0_buf : string | number | Resource | undefined
        if (center_buf_value0_buf_selector == (0).toChar()) {
            center_buf_value0_buf = (valueDeserializer.readString() as string)
        }
        else if (center_buf_value0_buf_selector == (1).toChar()) {
            center_buf_value0_buf = (valueDeserializer.readNumber() as number)
        }
        else if (center_buf_value0_buf_selector == (2).toChar()) {
            center_buf_value0_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for center_buf_value0_buf has to be chosen through deserialisation.")
        }
        const center_buf_value0 : Length = (center_buf_value0_buf as string | number | Resource)
        const center_buf_value1_buf_selector : int32 = valueDeserializer.readInt8()
        let center_buf_value1_buf : string | number | Resource | undefined
        if (center_buf_value1_buf_selector == (0).toChar()) {
            center_buf_value1_buf = (valueDeserializer.readString() as string)
        }
        else if (center_buf_value1_buf_selector == (1).toChar()) {
            center_buf_value1_buf = (valueDeserializer.readNumber() as number)
        }
        else if (center_buf_value1_buf_selector == (2).toChar()) {
            center_buf_value1_buf = Resource_serializer.read(valueDeserializer)
        }
        else {
            throw new Error("One of the branches for center_buf_value1_buf has to be chosen through deserialisation.")
        }
        const center_buf_value1 : Length = (center_buf_value1_buf as string | number | Resource)
        const center_result : [ Length, Length ] = ([center_buf_value0, center_buf_value1] as [ Length, Length ])
        const start_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let start_buf : number | string | undefined
        if ((start_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const start_buf__selector : int32 = valueDeserializer.readInt8()
            let start_buf_ : number | string | undefined
            if (start_buf__selector == (0).toChar()) {
                start_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (start_buf__selector == (1).toChar()) {
                start_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for start_buf_ has to be chosen through deserialisation.")
            }
            start_buf = (start_buf_ as number | string)
        }
        const start_result : number | string | undefined = start_buf
        const end_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let end_buf : number | string | undefined
        if ((end_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const end_buf__selector : int32 = valueDeserializer.readInt8()
            let end_buf_ : number | string | undefined
            if (end_buf__selector == (0).toChar()) {
                end_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (end_buf__selector == (1).toChar()) {
                end_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for end_buf_ has to be chosen through deserialisation.")
            }
            end_buf = (end_buf_ as number | string)
        }
        const end_result : number | string | undefined = end_buf
        const rotation_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rotation_buf : number | string | undefined
        if ((rotation_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const rotation_buf__selector : int32 = valueDeserializer.readInt8()
            let rotation_buf_ : number | string | undefined
            if (rotation_buf__selector == (0).toChar()) {
                rotation_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (rotation_buf__selector == (1).toChar()) {
                rotation_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for rotation_buf_ has to be chosen through deserialisation.")
            }
            rotation_buf = (rotation_buf_ as number | string)
        }
        const rotation_result : number | string | undefined = rotation_buf
        const colors_buf_length : int32 = valueDeserializer.readInt32()
        let colors_buf : Array<[ ResourceColor, number ]> = new Array<[ ResourceColor, number ]>(colors_buf_length)
        for (let colors_buf_i = 0; colors_buf_i < colors_buf_length; colors_buf_i++) {
            const colors_buf_buf_value0_buf_selector : int32 = valueDeserializer.readInt8()
            let colors_buf_buf_value0_buf : Color | number | string | Resource | undefined
            if (colors_buf_buf_value0_buf_selector == (0).toChar()) {
                colors_buf_buf_value0_buf = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (colors_buf_buf_value0_buf_selector == (1).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readNumber() as number)
            }
            else if (colors_buf_buf_value0_buf_selector == (2).toChar()) {
                colors_buf_buf_value0_buf = (valueDeserializer.readString() as string)
            }
            else if (colors_buf_buf_value0_buf_selector == (3).toChar()) {
                colors_buf_buf_value0_buf = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for colors_buf_buf_value0_buf has to be chosen through deserialisation.")
            }
            const colors_buf_buf_value0 : ResourceColor = (colors_buf_buf_value0_buf as Color | number | string | Resource)
            const colors_buf_buf_value1 : number = (valueDeserializer.readNumber() as number)
            colors_buf[colors_buf_i] = ([colors_buf_buf_value0, colors_buf_buf_value1] as [ ResourceColor, number ])
        }
        const colors_result : Array<[ ResourceColor, number ]> = colors_buf
        const repeating_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeating_buf : boolean | undefined
        if ((repeating_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            repeating_buf = valueDeserializer.readBoolean()
        }
        const repeating_result : boolean | undefined = repeating_buf
        let value : SweepGradientOptions = ({center: center_result, start: start_result, end: end_result, rotation: rotation_result, colors: colors_result, repeating: repeating_result} as SweepGradientOptions)
        return value
    }
}
export class TipsOptions_serializer {
    public static write(buffer: SerializerBase, value: TipsOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_appearingTime  = value.appearingTime
        let value_appearingTime_type : int32 = RuntimeType.UNDEFINED
        value_appearingTime_type = runtimeType(value_appearingTime)
        valueSerializer.writeInt8((value_appearingTime_type).toChar())
        if ((value_appearingTime_type) != (RuntimeType.UNDEFINED)) {
            const value_appearingTime_value  = value_appearingTime!
            valueSerializer.writeNumber(value_appearingTime_value)
        }
        const value_disappearingTime  = value.disappearingTime
        let value_disappearingTime_type : int32 = RuntimeType.UNDEFINED
        value_disappearingTime_type = runtimeType(value_disappearingTime)
        valueSerializer.writeInt8((value_disappearingTime_type).toChar())
        if ((value_disappearingTime_type) != (RuntimeType.UNDEFINED)) {
            const value_disappearingTime_value  = value_disappearingTime!
            valueSerializer.writeNumber(value_disappearingTime_value)
        }
        const value_appearingTimeWithContinuousOperation  = value.appearingTimeWithContinuousOperation
        let value_appearingTimeWithContinuousOperation_type : int32 = RuntimeType.UNDEFINED
        value_appearingTimeWithContinuousOperation_type = runtimeType(value_appearingTimeWithContinuousOperation)
        valueSerializer.writeInt8((value_appearingTimeWithContinuousOperation_type).toChar())
        if ((value_appearingTimeWithContinuousOperation_type) != (RuntimeType.UNDEFINED)) {
            const value_appearingTimeWithContinuousOperation_value  = value_appearingTimeWithContinuousOperation!
            valueSerializer.writeNumber(value_appearingTimeWithContinuousOperation_value)
        }
        const value_disappearingTimeWithContinuousOperation  = value.disappearingTimeWithContinuousOperation
        let value_disappearingTimeWithContinuousOperation_type : int32 = RuntimeType.UNDEFINED
        value_disappearingTimeWithContinuousOperation_type = runtimeType(value_disappearingTimeWithContinuousOperation)
        valueSerializer.writeInt8((value_disappearingTimeWithContinuousOperation_type).toChar())
        if ((value_disappearingTimeWithContinuousOperation_type) != (RuntimeType.UNDEFINED)) {
            const value_disappearingTimeWithContinuousOperation_value  = value_disappearingTimeWithContinuousOperation!
            valueSerializer.writeNumber(value_disappearingTimeWithContinuousOperation_value)
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_arrowPointPosition  = value.arrowPointPosition
        let value_arrowPointPosition_type : int32 = RuntimeType.UNDEFINED
        value_arrowPointPosition_type = runtimeType(value_arrowPointPosition)
        valueSerializer.writeInt8((value_arrowPointPosition_type).toChar())
        if ((value_arrowPointPosition_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowPointPosition_value  = (value_arrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(TypeChecker.ArrowPointPosition_ToNumeric(value_arrowPointPosition_value))
        }
        const value_arrowWidth  = value.arrowWidth
        let value_arrowWidth_type : int32 = RuntimeType.UNDEFINED
        value_arrowWidth_type = runtimeType(value_arrowWidth)
        valueSerializer.writeInt8((value_arrowWidth_type).toChar())
        if ((value_arrowWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowWidth_value  = value_arrowWidth!
            let value_arrowWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowWidth_value_type = runtimeType(value_arrowWidth_value)
            if (RuntimeType.STRING == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowWidth_value_0  = value_arrowWidth_value as string
                valueSerializer.writeString(value_arrowWidth_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowWidth_value_1  = value_arrowWidth_value as number
                valueSerializer.writeNumber(value_arrowWidth_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowWidth_value_2  = value_arrowWidth_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowWidth_value_2)
            }
        }
        const value_arrowHeight  = value.arrowHeight
        let value_arrowHeight_type : int32 = RuntimeType.UNDEFINED
        value_arrowHeight_type = runtimeType(value_arrowHeight)
        valueSerializer.writeInt8((value_arrowHeight_type).toChar())
        if ((value_arrowHeight_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowHeight_value  = value_arrowHeight!
            let value_arrowHeight_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowHeight_value_type = runtimeType(value_arrowHeight_value)
            if (RuntimeType.STRING == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowHeight_value_0  = value_arrowHeight_value as string
                valueSerializer.writeString(value_arrowHeight_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowHeight_value_1  = value_arrowHeight_value as number
                valueSerializer.writeNumber(value_arrowHeight_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowHeight_value_2  = value_arrowHeight_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowHeight_value_2)
            }
        }
    }
    public static read(buffer: DeserializerBase): TipsOptions {
        let valueDeserializer : DeserializerBase = buffer
        const appearingTime_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let appearingTime_buf : number | undefined
        if ((appearingTime_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            appearingTime_buf = (valueDeserializer.readNumber() as number)
        }
        const appearingTime_result : number | undefined = appearingTime_buf
        const disappearingTime_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disappearingTime_buf : number | undefined
        if ((disappearingTime_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            disappearingTime_buf = (valueDeserializer.readNumber() as number)
        }
        const disappearingTime_result : number | undefined = disappearingTime_buf
        const appearingTimeWithContinuousOperation_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let appearingTimeWithContinuousOperation_buf : number | undefined
        if ((appearingTimeWithContinuousOperation_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            appearingTimeWithContinuousOperation_buf = (valueDeserializer.readNumber() as number)
        }
        const appearingTimeWithContinuousOperation_result : number | undefined = appearingTimeWithContinuousOperation_buf
        const disappearingTimeWithContinuousOperation_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disappearingTimeWithContinuousOperation_buf : number | undefined
        if ((disappearingTimeWithContinuousOperation_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            disappearingTimeWithContinuousOperation_buf = (valueDeserializer.readNumber() as number)
        }
        const disappearingTimeWithContinuousOperation_result : number | undefined = disappearingTimeWithContinuousOperation_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const arrowPointPosition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPosition_buf : ArrowPointPosition | undefined
        if ((arrowPointPosition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            arrowPointPosition_buf = TypeChecker.ArrowPointPosition_FromNumeric(valueDeserializer.readInt32())
        }
        const arrowPointPosition_result : ArrowPointPosition | undefined = arrowPointPosition_buf
        const arrowWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidth_buf : Dimension | undefined
        if ((arrowWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowWidth_buf_ : string | number | Resource | undefined
            if (arrowWidth_buf__selector == (0).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowWidth_buf__selector == (1).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowWidth_buf__selector == (2).toChar()) {
                arrowWidth_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowWidth_buf_ has to be chosen through deserialisation.")
            }
            arrowWidth_buf = (arrowWidth_buf_ as string | number | Resource)
        }
        const arrowWidth_result : Dimension | undefined = arrowWidth_buf
        const arrowHeight_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeight_buf : Dimension | undefined
        if ((arrowHeight_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowHeight_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowHeight_buf_ : string | number | Resource | undefined
            if (arrowHeight_buf__selector == (0).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowHeight_buf__selector == (1).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowHeight_buf__selector == (2).toChar()) {
                arrowHeight_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowHeight_buf_ has to be chosen through deserialisation.")
            }
            arrowHeight_buf = (arrowHeight_buf_ as string | number | Resource)
        }
        const arrowHeight_result : Dimension | undefined = arrowHeight_buf
        let value : TipsOptions = ({appearingTime: appearingTime_result, disappearingTime: disappearingTime_result, appearingTimeWithContinuousOperation: appearingTimeWithContinuousOperation_result, disappearingTimeWithContinuousOperation: disappearingTimeWithContinuousOperation_result, enableArrow: enableArrow_result, arrowPointPosition: arrowPointPosition_result, arrowWidth: arrowWidth_result, arrowHeight: arrowHeight_result} as TipsOptions)
        return value
    }
}
export class BorderImageOption_serializer {
    public static write(buffer: SerializerBase, value: BorderImageOption): void {
        let valueSerializer : SerializerBase = buffer
        const value_slice  = value.slice
        let value_slice_type : int32 = RuntimeType.UNDEFINED
        value_slice_type = runtimeType(value_slice)
        valueSerializer.writeInt8((value_slice_type).toChar())
        if ((value_slice_type) != (RuntimeType.UNDEFINED)) {
            const value_slice_value  = value_slice!
            let value_slice_value_type : int32 = RuntimeType.UNDEFINED
            value_slice_value_type = runtimeType(value_slice_value)
            if ((RuntimeType.STRING == value_slice_value_type) || (RuntimeType.NUMBER == value_slice_value_type) || (RuntimeType.OBJECT == value_slice_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_slice_value_0  = value_slice_value as Length
                let value_slice_value_0_type : int32 = RuntimeType.UNDEFINED
                value_slice_value_0_type = runtimeType(value_slice_value_0)
                if (RuntimeType.STRING == value_slice_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_slice_value_0_0  = value_slice_value_0 as string
                    valueSerializer.writeString(value_slice_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_slice_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_slice_value_0_1  = value_slice_value_0 as number
                    valueSerializer.writeNumber(value_slice_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_slice_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_slice_value_0_2  = value_slice_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_slice_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeWidths(value_slice_value, true, false, true, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_slice_value_1  = value_slice_value as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, value_slice_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeWidths(value_slice_value, true, false, true, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_slice_value_2  = value_slice_value as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, value_slice_value_2)
            }
        }
        const value_repeat  = value.repeat
        let value_repeat_type : int32 = RuntimeType.UNDEFINED
        value_repeat_type = runtimeType(value_repeat)
        valueSerializer.writeInt8((value_repeat_type).toChar())
        if ((value_repeat_type) != (RuntimeType.UNDEFINED)) {
            const value_repeat_value  = (value_repeat as RepeatMode)
            valueSerializer.writeInt32(TypeChecker.RepeatMode_ToNumeric(value_repeat_value))
        }
        const value_source  = value.source
        let value_source_type : int32 = RuntimeType.UNDEFINED
        value_source_type = runtimeType(value_source)
        valueSerializer.writeInt8((value_source_type).toChar())
        if ((value_source_type) != (RuntimeType.UNDEFINED)) {
            const value_source_value  = value_source!
            let value_source_value_type : int32 = RuntimeType.UNDEFINED
            value_source_value_type = runtimeType(value_source_value)
            if (RuntimeType.STRING == value_source_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_source_value_0  = value_source_value as string
                valueSerializer.writeString(value_source_value_0)
            }
            else if (TypeChecker.isResource(value_source_value, false, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_source_value_1  = value_source_value as Resource
                Resource_serializer.write(valueSerializer, value_source_value_1)
            }
            else if (TypeChecker.isLinearGradientOptions(value_source_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_source_value_2  = value_source_value as LinearGradientOptions
                LinearGradientOptions_serializer.write(valueSerializer, value_source_value_2)
            }
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if ((RuntimeType.STRING == value_width_value_type) || (RuntimeType.NUMBER == value_width_value_type) || (RuntimeType.OBJECT == value_width_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as Length
                let value_width_value_0_type : int32 = RuntimeType.UNDEFINED
                value_width_value_0_type = runtimeType(value_width_value_0)
                if (RuntimeType.STRING == value_width_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_width_value_0_0  = value_width_value_0 as string
                    valueSerializer.writeString(value_width_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_width_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_width_value_0_1  = value_width_value_0 as number
                    valueSerializer.writeNumber(value_width_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_width_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_width_value_0_2  = value_width_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_width_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeWidths(value_width_value, true, false, true, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, value_width_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeWidths(value_width_value, true, false, true, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_outset  = value.outset
        let value_outset_type : int32 = RuntimeType.UNDEFINED
        value_outset_type = runtimeType(value_outset)
        valueSerializer.writeInt8((value_outset_type).toChar())
        if ((value_outset_type) != (RuntimeType.UNDEFINED)) {
            const value_outset_value  = value_outset!
            let value_outset_value_type : int32 = RuntimeType.UNDEFINED
            value_outset_value_type = runtimeType(value_outset_value)
            if ((RuntimeType.STRING == value_outset_value_type) || (RuntimeType.NUMBER == value_outset_value_type) || (RuntimeType.OBJECT == value_outset_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_outset_value_0  = value_outset_value as Length
                let value_outset_value_0_type : int32 = RuntimeType.UNDEFINED
                value_outset_value_0_type = runtimeType(value_outset_value_0)
                if (RuntimeType.STRING == value_outset_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_outset_value_0_0  = value_outset_value_0 as string
                    valueSerializer.writeString(value_outset_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_outset_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_outset_value_0_1  = value_outset_value_0 as number
                    valueSerializer.writeNumber(value_outset_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_outset_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_outset_value_0_2  = value_outset_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_outset_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeWidths(value_outset_value, true, false, true, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_outset_value_1  = value_outset_value as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, value_outset_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeWidths(value_outset_value, true, false, true, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_outset_value_2  = value_outset_value as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, value_outset_value_2)
            }
        }
        const value_fill  = value.fill
        let value_fill_type : int32 = RuntimeType.UNDEFINED
        value_fill_type = runtimeType(value_fill)
        valueSerializer.writeInt8((value_fill_type).toChar())
        if ((value_fill_type) != (RuntimeType.UNDEFINED)) {
            const value_fill_value  = value_fill!
            valueSerializer.writeBoolean(value_fill_value)
        }
    }
    public static read(buffer: DeserializerBase): BorderImageOption {
        let valueDeserializer : DeserializerBase = buffer
        const slice_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let slice_buf : Length | EdgeWidths | LocalizedEdgeWidths | undefined
        if ((slice_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const slice_buf__selector : int32 = valueDeserializer.readInt8()
            let slice_buf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (slice_buf__selector == (0).toChar()) {
                const slice_buf__u_selector : int32 = valueDeserializer.readInt8()
                let slice_buf__u : string | number | Resource | undefined
                if (slice_buf__u_selector == (0).toChar()) {
                    slice_buf__u = (valueDeserializer.readString() as string)
                }
                else if (slice_buf__u_selector == (1).toChar()) {
                    slice_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (slice_buf__u_selector == (2).toChar()) {
                    slice_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for slice_buf__u has to be chosen through deserialisation.")
                }
                slice_buf_ = (slice_buf__u as string | number | Resource)
            }
            else if (slice_buf__selector == (1).toChar()) {
                slice_buf_ = EdgeWidths_serializer.read(valueDeserializer)
            }
            else if (slice_buf__selector == (2).toChar()) {
                slice_buf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for slice_buf_ has to be chosen through deserialisation.")
            }
            slice_buf = (slice_buf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const slice_result : Length | EdgeWidths | LocalizedEdgeWidths | undefined = slice_buf
        const repeat_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeat_buf : RepeatMode | undefined
        if ((repeat_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            repeat_buf = TypeChecker.RepeatMode_FromNumeric(valueDeserializer.readInt32())
        }
        const repeat_result : RepeatMode | undefined = repeat_buf
        const source_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let source_buf : string | Resource | LinearGradientOptions | undefined
        if ((source_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const source_buf__selector : int32 = valueDeserializer.readInt8()
            let source_buf_ : string | Resource | LinearGradientOptions | undefined
            if (source_buf__selector == (0).toChar()) {
                source_buf_ = (valueDeserializer.readString() as string)
            }
            else if (source_buf__selector == (1).toChar()) {
                source_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else if (source_buf__selector == (2).toChar()) {
                source_buf_ = LinearGradientOptions_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for source_buf_ has to be chosen through deserialisation.")
            }
            source_buf = (source_buf_ as string | Resource | LinearGradientOptions)
        }
        const source_result : string | Resource | LinearGradientOptions | undefined = source_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Length | EdgeWidths | LocalizedEdgeWidths | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (width_buf__selector == (0).toChar()) {
                const width_buf__u_selector : int32 = valueDeserializer.readInt8()
                let width_buf__u : string | number | Resource | undefined
                if (width_buf__u_selector == (0).toChar()) {
                    width_buf__u = (valueDeserializer.readString() as string)
                }
                else if (width_buf__u_selector == (1).toChar()) {
                    width_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (width_buf__u_selector == (2).toChar()) {
                    width_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for width_buf__u has to be chosen through deserialisation.")
                }
                width_buf_ = (width_buf__u as string | number | Resource)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = EdgeWidths_serializer.read(valueDeserializer)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const width_result : Length | EdgeWidths | LocalizedEdgeWidths | undefined = width_buf
        const outset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outset_buf : Length | EdgeWidths | LocalizedEdgeWidths | undefined
        if ((outset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const outset_buf__selector : int32 = valueDeserializer.readInt8()
            let outset_buf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (outset_buf__selector == (0).toChar()) {
                const outset_buf__u_selector : int32 = valueDeserializer.readInt8()
                let outset_buf__u : string | number | Resource | undefined
                if (outset_buf__u_selector == (0).toChar()) {
                    outset_buf__u = (valueDeserializer.readString() as string)
                }
                else if (outset_buf__u_selector == (1).toChar()) {
                    outset_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (outset_buf__u_selector == (2).toChar()) {
                    outset_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for outset_buf__u has to be chosen through deserialisation.")
                }
                outset_buf_ = (outset_buf__u as string | number | Resource)
            }
            else if (outset_buf__selector == (1).toChar()) {
                outset_buf_ = EdgeWidths_serializer.read(valueDeserializer)
            }
            else if (outset_buf__selector == (2).toChar()) {
                outset_buf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for outset_buf_ has to be chosen through deserialisation.")
            }
            outset_buf = (outset_buf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const outset_result : Length | EdgeWidths | LocalizedEdgeWidths | undefined = outset_buf
        const fill_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fill_buf : boolean | undefined
        if ((fill_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            fill_buf = valueDeserializer.readBoolean()
        }
        const fill_result : boolean | undefined = fill_buf
        let value : BorderImageOption = ({slice: slice_result, repeat: repeat_result, source: source_result, width: width_result, outset: outset_result, fill: fill_result} as BorderImageOption)
        return value
    }
}
export class EventTarget_serializer {
    public static write(buffer: SerializerBase, value: EventTarget): void {
        let valueSerializer : SerializerBase = buffer
        const value_area  = value.area
        Area_serializer.write(valueSerializer, value_area)
        const value_id  = value.id
        let value_id_type : int32 = RuntimeType.UNDEFINED
        value_id_type = runtimeType(value_id)
        valueSerializer.writeInt8((value_id_type).toChar())
        if ((value_id_type) != (RuntimeType.UNDEFINED)) {
            const value_id_value  = value_id!
            valueSerializer.writeString(value_id_value)
        }
    }
    public static read(buffer: DeserializerBase): EventTarget {
        let valueDeserializer : DeserializerBase = buffer
        const area_result : Area = Area_serializer.read(valueDeserializer)
        const id_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let id_buf : string | undefined
        if ((id_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            id_buf = (valueDeserializer.readString() as string)
        }
        const id_result : string | undefined = id_buf
        let value : EventTarget = ({area: area_result, id: id_result} as EventTarget)
        return value
    }
}
export class FocusAxisEvent_serializer {
    public static write(buffer: SerializerBase, value: FocusAxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): FocusAxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return FocusAxisEventInternal.fromPtr(ptr)
    }
}
export class GeometryInfo_serializer {
    public static write(buffer: SerializerBase, value: GeometryInfo): void {
        let valueSerializer : SerializerBase = buffer
        const value_width  = value.width
        valueSerializer.writeNumber(value_width)
        const value_height  = value.height
        valueSerializer.writeNumber(value_height)
        const value_borderWidth  = value.borderWidth
        EdgeWidths_serializer.write(valueSerializer, value_borderWidth)
        const value_margin  = value.margin
        Padding_serializer.write(valueSerializer, value_margin)
        const value_padding  = value.padding
        Padding_serializer.write(valueSerializer, value_padding)
    }
    public static read(buffer: DeserializerBase): GeometryInfo {
        let valueDeserializer : DeserializerBase = buffer
        const width_result : number = (valueDeserializer.readNumber() as number)
        const height_result : number = (valueDeserializer.readNumber() as number)
        const borderWidth_result : EdgeWidths = EdgeWidths_serializer.read(valueDeserializer)
        const margin_result : Padding = Padding_serializer.read(valueDeserializer)
        const padding_result : Padding = Padding_serializer.read(valueDeserializer)
        let value : GeometryInfo = ({width: width_result, height: height_result, borderWidth: borderWidth_result, margin: margin_result, padding: padding_result} as GeometryInfo)
        return value
    }
}
export class HoverEvent_serializer {
    public static write(buffer: SerializerBase, value: HoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): HoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return HoverEventInternal.fromPtr(ptr)
    }
}
export class LayoutChild_serializer {
    public static write(buffer: SerializerBase, value: LayoutChild): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): LayoutChild {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutChildInternal.fromPtr(ptr)
    }
}
export class MouseEvent_serializer {
    public static write(buffer: SerializerBase, value: MouseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): MouseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MouseEventInternal.fromPtr(ptr)
    }
}
export class PickerDialogButtonStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerDialogButtonStyle): void {
        let valueSerializer : SerializerBase = buffer
        const value_type  = value.type
        let value_type_type : int32 = RuntimeType.UNDEFINED
        value_type_type = runtimeType(value_type)
        valueSerializer.writeInt8((value_type_type).toChar())
        if ((value_type_type) != (RuntimeType.UNDEFINED)) {
            const value_type_value  = (value_type as ButtonType)
            valueSerializer.writeInt32(TypeChecker.ButtonType_ToNumeric(value_type_value))
        }
        const value_style  = value.style
        let value_style_type : int32 = RuntimeType.UNDEFINED
        value_style_type = runtimeType(value_style)
        valueSerializer.writeInt8((value_style_type).toChar())
        if ((value_style_type) != (RuntimeType.UNDEFINED)) {
            const value_style_value  = (value_style as ButtonStyleMode)
            valueSerializer.writeInt32(TypeChecker.ButtonStyleMode_ToNumeric(value_style_value))
        }
        const value_role  = value.role
        let value_role_type : int32 = RuntimeType.UNDEFINED
        value_role_type = runtimeType(value_role)
        valueSerializer.writeInt8((value_role_type).toChar())
        if ((value_role_type) != (RuntimeType.UNDEFINED)) {
            const value_role_value  = (value_role as ButtonRole)
            valueSerializer.writeInt32(TypeChecker.ButtonRole_ToNumeric(value_role_value))
        }
        const value_fontSize  = value.fontSize
        let value_fontSize_type : int32 = RuntimeType.UNDEFINED
        value_fontSize_type = runtimeType(value_fontSize)
        valueSerializer.writeInt8((value_fontSize_type).toChar())
        if ((value_fontSize_type) != (RuntimeType.UNDEFINED)) {
            const value_fontSize_value  = value_fontSize!
            let value_fontSize_value_type : int32 = RuntimeType.UNDEFINED
            value_fontSize_value_type = runtimeType(value_fontSize_value)
            if (RuntimeType.STRING == value_fontSize_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_fontSize_value_0  = value_fontSize_value as string
                valueSerializer.writeString(value_fontSize_value_0)
            }
            else if (RuntimeType.NUMBER == value_fontSize_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_fontSize_value_1  = value_fontSize_value as number
                valueSerializer.writeNumber(value_fontSize_value_1)
            }
            else if (RuntimeType.OBJECT == value_fontSize_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_fontSize_value_2  = value_fontSize_value as Resource
                Resource_serializer.write(valueSerializer, value_fontSize_value_2)
            }
        }
        const value_fontColor  = value.fontColor
        let value_fontColor_type : int32 = RuntimeType.UNDEFINED
        value_fontColor_type = runtimeType(value_fontColor)
        valueSerializer.writeInt8((value_fontColor_type).toChar())
        if ((value_fontColor_type) != (RuntimeType.UNDEFINED)) {
            const value_fontColor_value  = value_fontColor!
            let value_fontColor_value_type : int32 = RuntimeType.UNDEFINED
            value_fontColor_value_type = runtimeType(value_fontColor_value)
            if (TypeChecker.isColor(value_fontColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_fontColor_value_0  = value_fontColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_fontColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_fontColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_fontColor_value_1  = value_fontColor_value as number
                valueSerializer.writeNumber(value_fontColor_value_1)
            }
            else if (RuntimeType.STRING == value_fontColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_fontColor_value_2  = value_fontColor_value as string
                valueSerializer.writeString(value_fontColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_fontColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_fontColor_value_3  = value_fontColor_value as Resource
                Resource_serializer.write(valueSerializer, value_fontColor_value_3)
            }
        }
        const value_fontWeight  = value.fontWeight
        let value_fontWeight_type : int32 = RuntimeType.UNDEFINED
        value_fontWeight_type = runtimeType(value_fontWeight)
        valueSerializer.writeInt8((value_fontWeight_type).toChar())
        if ((value_fontWeight_type) != (RuntimeType.UNDEFINED)) {
            const value_fontWeight_value  = value_fontWeight!
            let value_fontWeight_value_type : int32 = RuntimeType.UNDEFINED
            value_fontWeight_value_type = runtimeType(value_fontWeight_value)
            if (TypeChecker.isFontWeight(value_fontWeight_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_fontWeight_value_0  = value_fontWeight_value as FontWeight
                valueSerializer.writeInt32(TypeChecker.FontWeight_ToNumeric(value_fontWeight_value_0))
            }
            else if (RuntimeType.NUMBER == value_fontWeight_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_fontWeight_value_1  = value_fontWeight_value as number
                valueSerializer.writeNumber(value_fontWeight_value_1)
            }
            else if (RuntimeType.STRING == value_fontWeight_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_fontWeight_value_2  = value_fontWeight_value as string
                valueSerializer.writeString(value_fontWeight_value_2)
            }
        }
        const value_fontStyle  = value.fontStyle
        let value_fontStyle_type : int32 = RuntimeType.UNDEFINED
        value_fontStyle_type = runtimeType(value_fontStyle)
        valueSerializer.writeInt8((value_fontStyle_type).toChar())
        if ((value_fontStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_fontStyle_value  = (value_fontStyle as FontStyle)
            valueSerializer.writeInt32(TypeChecker.FontStyle_ToNumeric(value_fontStyle_value))
        }
        const value_fontFamily  = value.fontFamily
        let value_fontFamily_type : int32 = RuntimeType.UNDEFINED
        value_fontFamily_type = runtimeType(value_fontFamily)
        valueSerializer.writeInt8((value_fontFamily_type).toChar())
        if ((value_fontFamily_type) != (RuntimeType.UNDEFINED)) {
            const value_fontFamily_value  = value_fontFamily!
            let value_fontFamily_value_type : int32 = RuntimeType.UNDEFINED
            value_fontFamily_value_type = runtimeType(value_fontFamily_value)
            if (RuntimeType.OBJECT == value_fontFamily_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_fontFamily_value_0  = value_fontFamily_value as Resource
                Resource_serializer.write(valueSerializer, value_fontFamily_value_0)
            }
            else if (RuntimeType.STRING == value_fontFamily_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_fontFamily_value_1  = value_fontFamily_value as string
                valueSerializer.writeString(value_fontFamily_value_1)
            }
        }
        const value_backgroundColor  = value.backgroundColor
        let value_backgroundColor_type : int32 = RuntimeType.UNDEFINED
        value_backgroundColor_type = runtimeType(value_backgroundColor)
        valueSerializer.writeInt8((value_backgroundColor_type).toChar())
        if ((value_backgroundColor_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundColor_value  = value_backgroundColor!
            let value_backgroundColor_value_type : int32 = RuntimeType.UNDEFINED
            value_backgroundColor_value_type = runtimeType(value_backgroundColor_value)
            if (TypeChecker.isColor(value_backgroundColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_backgroundColor_value_0  = value_backgroundColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_backgroundColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_backgroundColor_value_1  = value_backgroundColor_value as number
                valueSerializer.writeNumber(value_backgroundColor_value_1)
            }
            else if (RuntimeType.STRING == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_backgroundColor_value_2  = value_backgroundColor_value as string
                valueSerializer.writeString(value_backgroundColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_backgroundColor_value_3  = value_backgroundColor_value as Resource
                Resource_serializer.write(valueSerializer, value_backgroundColor_value_3)
            }
        }
        const value_borderRadius  = value.borderRadius
        let value_borderRadius_type : int32 = RuntimeType.UNDEFINED
        value_borderRadius_type = runtimeType(value_borderRadius)
        valueSerializer.writeInt8((value_borderRadius_type).toChar())
        if ((value_borderRadius_type) != (RuntimeType.UNDEFINED)) {
            const value_borderRadius_value  = value_borderRadius!
            let value_borderRadius_value_type : int32 = RuntimeType.UNDEFINED
            value_borderRadius_value_type = runtimeType(value_borderRadius_value)
            if ((RuntimeType.STRING == value_borderRadius_value_type) || (RuntimeType.NUMBER == value_borderRadius_value_type) || (RuntimeType.OBJECT == value_borderRadius_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderRadius_value_0  = value_borderRadius_value as Length
                let value_borderRadius_value_0_type : int32 = RuntimeType.UNDEFINED
                value_borderRadius_value_0_type = runtimeType(value_borderRadius_value_0)
                if (RuntimeType.STRING == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_borderRadius_value_0_0  = value_borderRadius_value_0 as string
                    valueSerializer.writeString(value_borderRadius_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_borderRadius_value_0_1  = value_borderRadius_value_0 as number
                    valueSerializer.writeNumber(value_borderRadius_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_borderRadius_value_0_2  = value_borderRadius_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_borderRadius_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_borderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderRadius_value_1  = value_borderRadius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_borderRadius_value_1)
            }
        }
        const value_primary  = value.primary
        let value_primary_type : int32 = RuntimeType.UNDEFINED
        value_primary_type = runtimeType(value_primary)
        valueSerializer.writeInt8((value_primary_type).toChar())
        if ((value_primary_type) != (RuntimeType.UNDEFINED)) {
            const value_primary_value  = value_primary!
            valueSerializer.writeBoolean(value_primary_value)
        }
    }
    public static read(buffer: DeserializerBase): PickerDialogButtonStyle {
        let valueDeserializer : DeserializerBase = buffer
        const type_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let type_buf : ButtonType | undefined
        if ((type_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            type_buf = TypeChecker.ButtonType_FromNumeric(valueDeserializer.readInt32())
        }
        const type_result : ButtonType | undefined = type_buf
        const style_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let style_buf : ButtonStyleMode | undefined
        if ((style_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            style_buf = TypeChecker.ButtonStyleMode_FromNumeric(valueDeserializer.readInt32())
        }
        const style_result : ButtonStyleMode | undefined = style_buf
        const role_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let role_buf : ButtonRole | undefined
        if ((role_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            role_buf = TypeChecker.ButtonRole_FromNumeric(valueDeserializer.readInt32())
        }
        const role_result : ButtonRole | undefined = role_buf
        const fontSize_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontSize_buf : Length | undefined
        if ((fontSize_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const fontSize_buf__selector : int32 = valueDeserializer.readInt8()
            let fontSize_buf_ : string | number | Resource | undefined
            if (fontSize_buf__selector == (0).toChar()) {
                fontSize_buf_ = (valueDeserializer.readString() as string)
            }
            else if (fontSize_buf__selector == (1).toChar()) {
                fontSize_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (fontSize_buf__selector == (2).toChar()) {
                fontSize_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for fontSize_buf_ has to be chosen through deserialisation.")
            }
            fontSize_buf = (fontSize_buf_ as string | number | Resource)
        }
        const fontSize_result : Length | undefined = fontSize_buf
        const fontColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontColor_buf : ResourceColor | undefined
        if ((fontColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const fontColor_buf__selector : int32 = valueDeserializer.readInt8()
            let fontColor_buf_ : Color | number | string | Resource | undefined
            if (fontColor_buf__selector == (0).toChar()) {
                fontColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (fontColor_buf__selector == (1).toChar()) {
                fontColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (fontColor_buf__selector == (2).toChar()) {
                fontColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (fontColor_buf__selector == (3).toChar()) {
                fontColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for fontColor_buf_ has to be chosen through deserialisation.")
            }
            fontColor_buf = (fontColor_buf_ as Color | number | string | Resource)
        }
        const fontColor_result : ResourceColor | undefined = fontColor_buf
        const fontWeight_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontWeight_buf : FontWeight | number | string | undefined
        if ((fontWeight_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const fontWeight_buf__selector : int32 = valueDeserializer.readInt8()
            let fontWeight_buf_ : FontWeight | number | string | undefined
            if (fontWeight_buf__selector == (0).toChar()) {
                fontWeight_buf_ = TypeChecker.FontWeight_FromNumeric(valueDeserializer.readInt32())
            }
            else if (fontWeight_buf__selector == (1).toChar()) {
                fontWeight_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (fontWeight_buf__selector == (2).toChar()) {
                fontWeight_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for fontWeight_buf_ has to be chosen through deserialisation.")
            }
            fontWeight_buf = (fontWeight_buf_ as FontWeight | number | string)
        }
        const fontWeight_result : FontWeight | number | string | undefined = fontWeight_buf
        const fontStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontStyle_buf : FontStyle | undefined
        if ((fontStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            fontStyle_buf = TypeChecker.FontStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const fontStyle_result : FontStyle | undefined = fontStyle_buf
        const fontFamily_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontFamily_buf : Resource | string | undefined
        if ((fontFamily_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const fontFamily_buf__selector : int32 = valueDeserializer.readInt8()
            let fontFamily_buf_ : Resource | string | undefined
            if (fontFamily_buf__selector == (0).toChar()) {
                fontFamily_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else if (fontFamily_buf__selector == (1).toChar()) {
                fontFamily_buf_ = (valueDeserializer.readString() as string)
            }
            else {
                throw new Error("One of the branches for fontFamily_buf_ has to be chosen through deserialisation.")
            }
            fontFamily_buf = (fontFamily_buf_ as Resource | string)
        }
        const fontFamily_result : Resource | string | undefined = fontFamily_buf
        const backgroundColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColor_buf : ResourceColor | undefined
        if ((backgroundColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const backgroundColor_buf__selector : int32 = valueDeserializer.readInt8()
            let backgroundColor_buf_ : Color | number | string | Resource | undefined
            if (backgroundColor_buf__selector == (0).toChar()) {
                backgroundColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (backgroundColor_buf__selector == (1).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (backgroundColor_buf__selector == (2).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (backgroundColor_buf__selector == (3).toChar()) {
                backgroundColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for backgroundColor_buf_ has to be chosen through deserialisation.")
            }
            backgroundColor_buf = (backgroundColor_buf_ as Color | number | string | Resource)
        }
        const backgroundColor_result : ResourceColor | undefined = backgroundColor_buf
        const borderRadius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadius_buf : Length | BorderRadiuses | undefined
        if ((borderRadius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderRadius_buf__selector : int32 = valueDeserializer.readInt8()
            let borderRadius_buf_ : Length | BorderRadiuses | undefined
            if (borderRadius_buf__selector == (0).toChar()) {
                const borderRadius_buf__u_selector : int32 = valueDeserializer.readInt8()
                let borderRadius_buf__u : string | number | Resource | undefined
                if (borderRadius_buf__u_selector == (0).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readString() as string)
                }
                else if (borderRadius_buf__u_selector == (1).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (borderRadius_buf__u_selector == (2).toChar()) {
                    borderRadius_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for borderRadius_buf__u has to be chosen through deserialisation.")
                }
                borderRadius_buf_ = (borderRadius_buf__u as string | number | Resource)
            }
            else if (borderRadius_buf__selector == (1).toChar()) {
                borderRadius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderRadius_buf_ has to be chosen through deserialisation.")
            }
            borderRadius_buf = (borderRadius_buf_ as Length | BorderRadiuses)
        }
        const borderRadius_result : Length | BorderRadiuses | undefined = borderRadius_buf
        const primary_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let primary_buf : boolean | undefined
        if ((primary_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            primary_buf = valueDeserializer.readBoolean()
        }
        const primary_result : boolean | undefined = primary_buf
        let value : PickerDialogButtonStyle = ({type: type_result, style: style_result, role: role_result, fontSize: fontSize_result, fontColor: fontColor_result, fontWeight: fontWeight_result, fontStyle: fontStyle_result, fontFamily: fontFamily_result, backgroundColor: backgroundColor_result, borderRadius: borderRadius_result, primary: primary_result} as PickerDialogButtonStyle)
        return value
    }
}
export class PickerTextStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerTextStyle): void {
        let valueSerializer : SerializerBase = buffer
        const value_color  = value.color
        let value_color_type : int32 = RuntimeType.UNDEFINED
        value_color_type = runtimeType(value_color)
        valueSerializer.writeInt8((value_color_type).toChar())
        if ((value_color_type) != (RuntimeType.UNDEFINED)) {
            const value_color_value  = value_color!
            let value_color_value_type : int32 = RuntimeType.UNDEFINED
            value_color_value_type = runtimeType(value_color_value)
            if (TypeChecker.isColor(value_color_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_color_value_0  = value_color_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_color_value_0))
            }
            else if (RuntimeType.NUMBER == value_color_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_color_value_1  = value_color_value as number
                valueSerializer.writeNumber(value_color_value_1)
            }
            else if (RuntimeType.STRING == value_color_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_color_value_2  = value_color_value as string
                valueSerializer.writeString(value_color_value_2)
            }
            else if (RuntimeType.OBJECT == value_color_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_color_value_3  = value_color_value as Resource
                Resource_serializer.write(valueSerializer, value_color_value_3)
            }
        }
        const value_font  = value.font
        let value_font_type : int32 = RuntimeType.UNDEFINED
        value_font_type = runtimeType(value_font)
        valueSerializer.writeInt8((value_font_type).toChar())
        if ((value_font_type) != (RuntimeType.UNDEFINED)) {
            const value_font_value  = value_font!
            Font_serializer.write(valueSerializer, value_font_value)
        }
    }
    public static read(buffer: DeserializerBase): PickerTextStyle {
        let valueDeserializer : DeserializerBase = buffer
        const color_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let color_buf : ResourceColor | undefined
        if ((color_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const color_buf__selector : int32 = valueDeserializer.readInt8()
            let color_buf_ : Color | number | string | Resource | undefined
            if (color_buf__selector == (0).toChar()) {
                color_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (color_buf__selector == (1).toChar()) {
                color_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (color_buf__selector == (2).toChar()) {
                color_buf_ = (valueDeserializer.readString() as string)
            }
            else if (color_buf__selector == (3).toChar()) {
                color_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for color_buf_ has to be chosen through deserialisation.")
            }
            color_buf = (color_buf_ as Color | number | string | Resource)
        }
        const color_result : ResourceColor | undefined = color_buf
        const font_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let font_buf : Font | undefined
        if ((font_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            font_buf = Font_serializer.read(valueDeserializer)
        }
        const font_result : Font | undefined = font_buf
        let value : PickerTextStyle = ({color: color_result, font: font_result} as PickerTextStyle)
        return value
    }
}
export class PopupMessageOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupMessageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_textColor  = value.textColor
        let value_textColor_type : int32 = RuntimeType.UNDEFINED
        value_textColor_type = runtimeType(value_textColor)
        valueSerializer.writeInt8((value_textColor_type).toChar())
        if ((value_textColor_type) != (RuntimeType.UNDEFINED)) {
            const value_textColor_value  = value_textColor!
            let value_textColor_value_type : int32 = RuntimeType.UNDEFINED
            value_textColor_value_type = runtimeType(value_textColor_value)
            if (TypeChecker.isColor(value_textColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_textColor_value_0  = value_textColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_textColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_textColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_textColor_value_1  = value_textColor_value as number
                valueSerializer.writeNumber(value_textColor_value_1)
            }
            else if (RuntimeType.STRING == value_textColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_textColor_value_2  = value_textColor_value as string
                valueSerializer.writeString(value_textColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_textColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_textColor_value_3  = value_textColor_value as Resource
                Resource_serializer.write(valueSerializer, value_textColor_value_3)
            }
        }
        const value_font  = value.font
        let value_font_type : int32 = RuntimeType.UNDEFINED
        value_font_type = runtimeType(value_font)
        valueSerializer.writeInt8((value_font_type).toChar())
        if ((value_font_type) != (RuntimeType.UNDEFINED)) {
            const value_font_value  = value_font!
            Font_serializer.write(valueSerializer, value_font_value)
        }
    }
    public static read(buffer: DeserializerBase): PopupMessageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const textColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let textColor_buf : ResourceColor | undefined
        if ((textColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const textColor_buf__selector : int32 = valueDeserializer.readInt8()
            let textColor_buf_ : Color | number | string | Resource | undefined
            if (textColor_buf__selector == (0).toChar()) {
                textColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (textColor_buf__selector == (1).toChar()) {
                textColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (textColor_buf__selector == (2).toChar()) {
                textColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (textColor_buf__selector == (3).toChar()) {
                textColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for textColor_buf_ has to be chosen through deserialisation.")
            }
            textColor_buf = (textColor_buf_ as Color | number | string | Resource)
        }
        const textColor_result : ResourceColor | undefined = textColor_buf
        const font_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let font_buf : Font | undefined
        if ((font_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            font_buf = Font_serializer.read(valueDeserializer)
        }
        const font_result : Font | undefined = font_buf
        let value : PopupMessageOptions = ({textColor: textColor_result, font: font_result} as PopupMessageOptions)
        return value
    }
}
export class SheetOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_backgroundColor  = value.backgroundColor
        let value_backgroundColor_type : int32 = RuntimeType.UNDEFINED
        value_backgroundColor_type = runtimeType(value_backgroundColor)
        valueSerializer.writeInt8((value_backgroundColor_type).toChar())
        if ((value_backgroundColor_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundColor_value  = value_backgroundColor!
            let value_backgroundColor_value_type : int32 = RuntimeType.UNDEFINED
            value_backgroundColor_value_type = runtimeType(value_backgroundColor_value)
            if (TypeChecker.isColor(value_backgroundColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_backgroundColor_value_0  = value_backgroundColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_backgroundColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_backgroundColor_value_1  = value_backgroundColor_value as number
                valueSerializer.writeNumber(value_backgroundColor_value_1)
            }
            else if (RuntimeType.STRING == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_backgroundColor_value_2  = value_backgroundColor_value as string
                valueSerializer.writeString(value_backgroundColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_backgroundColor_value_3  = value_backgroundColor_value as Resource
                Resource_serializer.write(valueSerializer, value_backgroundColor_value_3)
            }
        }
        const value_onAppear  = value.onAppear
        let value_onAppear_type : int32 = RuntimeType.UNDEFINED
        value_onAppear_type = runtimeType(value_onAppear)
        valueSerializer.writeInt8((value_onAppear_type).toChar())
        if ((value_onAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onAppear_value  = value_onAppear!
            valueSerializer.holdAndWriteCallback(value_onAppear_value)
        }
        const value_onDisappear  = value.onDisappear
        let value_onDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onDisappear_type = runtimeType(value_onDisappear)
        valueSerializer.writeInt8((value_onDisappear_type).toChar())
        if ((value_onDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onDisappear_value  = value_onDisappear!
            valueSerializer.holdAndWriteCallback(value_onDisappear_value)
        }
        const value_onWillAppear  = value.onWillAppear
        let value_onWillAppear_type : int32 = RuntimeType.UNDEFINED
        value_onWillAppear_type = runtimeType(value_onWillAppear)
        valueSerializer.writeInt8((value_onWillAppear_type).toChar())
        if ((value_onWillAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillAppear_value  = value_onWillAppear!
            valueSerializer.holdAndWriteCallback(value_onWillAppear_value)
        }
        const value_onWillDisappear  = value.onWillDisappear
        let value_onWillDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onWillDisappear_type = runtimeType(value_onWillDisappear)
        valueSerializer.writeInt8((value_onWillDisappear_type).toChar())
        if ((value_onWillDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDisappear_value  = value_onWillDisappear!
            valueSerializer.holdAndWriteCallback(value_onWillDisappear_value)
        }
        const value_height  = value.height
        let value_height_type : int32 = RuntimeType.UNDEFINED
        value_height_type = runtimeType(value_height)
        valueSerializer.writeInt8((value_height_type).toChar())
        if ((value_height_type) != (RuntimeType.UNDEFINED)) {
            const value_height_value  = value_height!
            let value_height_value_type : int32 = RuntimeType.UNDEFINED
            value_height_value_type = runtimeType(value_height_value)
            if (TypeChecker.isSheetSize(value_height_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_height_value_0  = value_height_value as SheetSize
                valueSerializer.writeInt32(TypeChecker.SheetSize_ToNumeric(value_height_value_0))
            }
            else if ((RuntimeType.STRING == value_height_value_type) || (RuntimeType.NUMBER == value_height_value_type) || (RuntimeType.OBJECT == value_height_value_type)) {
                valueSerializer.writeInt8((1).toChar())
                const value_height_value_1  = value_height_value as Length
                let value_height_value_1_type : int32 = RuntimeType.UNDEFINED
                value_height_value_1_type = runtimeType(value_height_value_1)
                if (RuntimeType.STRING == value_height_value_1_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_height_value_1_0  = value_height_value_1 as string
                    valueSerializer.writeString(value_height_value_1_0)
                }
                else if (RuntimeType.NUMBER == value_height_value_1_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_height_value_1_1  = value_height_value_1 as number
                    valueSerializer.writeNumber(value_height_value_1_1)
                }
                else if (RuntimeType.OBJECT == value_height_value_1_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_height_value_1_2  = value_height_value_1 as Resource
                    Resource_serializer.write(valueSerializer, value_height_value_1_2)
                }
            }
        }
        const value_dragBar  = value.dragBar
        let value_dragBar_type : int32 = RuntimeType.UNDEFINED
        value_dragBar_type = runtimeType(value_dragBar)
        valueSerializer.writeInt8((value_dragBar_type).toChar())
        if ((value_dragBar_type) != (RuntimeType.UNDEFINED)) {
            const value_dragBar_value  = value_dragBar!
            valueSerializer.writeBoolean(value_dragBar_value)
        }
        const value_maskColor  = value.maskColor
        let value_maskColor_type : int32 = RuntimeType.UNDEFINED
        value_maskColor_type = runtimeType(value_maskColor)
        valueSerializer.writeInt8((value_maskColor_type).toChar())
        if ((value_maskColor_type) != (RuntimeType.UNDEFINED)) {
            const value_maskColor_value  = value_maskColor!
            let value_maskColor_value_type : int32 = RuntimeType.UNDEFINED
            value_maskColor_value_type = runtimeType(value_maskColor_value)
            if (TypeChecker.isColor(value_maskColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_maskColor_value_0  = value_maskColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_maskColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_maskColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_maskColor_value_1  = value_maskColor_value as number
                valueSerializer.writeNumber(value_maskColor_value_1)
            }
            else if (RuntimeType.STRING == value_maskColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_maskColor_value_2  = value_maskColor_value as string
                valueSerializer.writeString(value_maskColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_maskColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_maskColor_value_3  = value_maskColor_value as Resource
                Resource_serializer.write(valueSerializer, value_maskColor_value_3)
            }
        }
        const value_detents  = value.detents
        let value_detents_type : int32 = RuntimeType.UNDEFINED
        value_detents_type = runtimeType(value_detents)
        valueSerializer.writeInt8((value_detents_type).toChar())
        if ((value_detents_type) != (RuntimeType.UNDEFINED)) {
            const value_detents_value  = value_detents!
            const value_detents_value_0  = value_detents_value[0]
            let value_detents_value_0_type : int32 = RuntimeType.UNDEFINED
            value_detents_value_0_type = runtimeType(value_detents_value_0)
            if (TypeChecker.isSheetSize(value_detents_value_0)) {
                valueSerializer.writeInt8((0).toChar())
                const value_detents_value_0_0  = value_detents_value_0 as SheetSize
                valueSerializer.writeInt32(TypeChecker.SheetSize_ToNumeric(value_detents_value_0_0))
            }
            else if ((RuntimeType.STRING == value_detents_value_0_type) || (RuntimeType.NUMBER == value_detents_value_0_type) || (RuntimeType.OBJECT == value_detents_value_0_type)) {
                valueSerializer.writeInt8((1).toChar())
                const value_detents_value_0_1  = value_detents_value_0 as Length
                let value_detents_value_0_1_type : int32 = RuntimeType.UNDEFINED
                value_detents_value_0_1_type = runtimeType(value_detents_value_0_1)
                if (RuntimeType.STRING == value_detents_value_0_1_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_detents_value_0_1_0  = value_detents_value_0_1 as string
                    valueSerializer.writeString(value_detents_value_0_1_0)
                }
                else if (RuntimeType.NUMBER == value_detents_value_0_1_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_detents_value_0_1_1  = value_detents_value_0_1 as number
                    valueSerializer.writeNumber(value_detents_value_0_1_1)
                }
                else if (RuntimeType.OBJECT == value_detents_value_0_1_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_detents_value_0_1_2  = value_detents_value_0_1 as Resource
                    Resource_serializer.write(valueSerializer, value_detents_value_0_1_2)
                }
            }
            const value_detents_value_1  = value_detents_value[1]
            let value_detents_value_1_type : int32 = RuntimeType.UNDEFINED
            value_detents_value_1_type = runtimeType(value_detents_value_1)
            valueSerializer.writeInt8((value_detents_value_1_type).toChar())
            if ((value_detents_value_1_type) != (RuntimeType.UNDEFINED)) {
                const value_detents_value_1_value  = value_detents_value_1!
                let value_detents_value_1_value_type : int32 = RuntimeType.UNDEFINED
                value_detents_value_1_value_type = runtimeType(value_detents_value_1_value)
                if (TypeChecker.isSheetSize(value_detents_value_1_value)) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_detents_value_1_value_0  = value_detents_value_1_value as SheetSize
                    valueSerializer.writeInt32(TypeChecker.SheetSize_ToNumeric(value_detents_value_1_value_0))
                }
                else if ((RuntimeType.STRING == value_detents_value_1_value_type) || (RuntimeType.NUMBER == value_detents_value_1_value_type) || (RuntimeType.OBJECT == value_detents_value_1_value_type)) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_detents_value_1_value_1  = value_detents_value_1_value as Length
                    let value_detents_value_1_value_1_type : int32 = RuntimeType.UNDEFINED
                    value_detents_value_1_value_1_type = runtimeType(value_detents_value_1_value_1)
                    if (RuntimeType.STRING == value_detents_value_1_value_1_type) {
                        valueSerializer.writeInt8((0).toChar())
                        const value_detents_value_1_value_1_0  = value_detents_value_1_value_1 as string
                        valueSerializer.writeString(value_detents_value_1_value_1_0)
                    }
                    else if (RuntimeType.NUMBER == value_detents_value_1_value_1_type) {
                        valueSerializer.writeInt8((1).toChar())
                        const value_detents_value_1_value_1_1  = value_detents_value_1_value_1 as number
                        valueSerializer.writeNumber(value_detents_value_1_value_1_1)
                    }
                    else if (RuntimeType.OBJECT == value_detents_value_1_value_1_type) {
                        valueSerializer.writeInt8((2).toChar())
                        const value_detents_value_1_value_1_2  = value_detents_value_1_value_1 as Resource
                        Resource_serializer.write(valueSerializer, value_detents_value_1_value_1_2)
                    }
                }
            }
            const value_detents_value_2  = value_detents_value[2]
            let value_detents_value_2_type : int32 = RuntimeType.UNDEFINED
            value_detents_value_2_type = runtimeType(value_detents_value_2)
            valueSerializer.writeInt8((value_detents_value_2_type).toChar())
            if ((value_detents_value_2_type) != (RuntimeType.UNDEFINED)) {
                const value_detents_value_2_value  = value_detents_value_2!
                let value_detents_value_2_value_type : int32 = RuntimeType.UNDEFINED
                value_detents_value_2_value_type = runtimeType(value_detents_value_2_value)
                if (TypeChecker.isSheetSize(value_detents_value_2_value)) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_detents_value_2_value_0  = value_detents_value_2_value as SheetSize
                    valueSerializer.writeInt32(TypeChecker.SheetSize_ToNumeric(value_detents_value_2_value_0))
                }
                else if ((RuntimeType.STRING == value_detents_value_2_value_type) || (RuntimeType.NUMBER == value_detents_value_2_value_type) || (RuntimeType.OBJECT == value_detents_value_2_value_type)) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_detents_value_2_value_1  = value_detents_value_2_value as Length
                    let value_detents_value_2_value_1_type : int32 = RuntimeType.UNDEFINED
                    value_detents_value_2_value_1_type = runtimeType(value_detents_value_2_value_1)
                    if (RuntimeType.STRING == value_detents_value_2_value_1_type) {
                        valueSerializer.writeInt8((0).toChar())
                        const value_detents_value_2_value_1_0  = value_detents_value_2_value_1 as string
                        valueSerializer.writeString(value_detents_value_2_value_1_0)
                    }
                    else if (RuntimeType.NUMBER == value_detents_value_2_value_1_type) {
                        valueSerializer.writeInt8((1).toChar())
                        const value_detents_value_2_value_1_1  = value_detents_value_2_value_1 as number
                        valueSerializer.writeNumber(value_detents_value_2_value_1_1)
                    }
                    else if (RuntimeType.OBJECT == value_detents_value_2_value_1_type) {
                        valueSerializer.writeInt8((2).toChar())
                        const value_detents_value_2_value_1_2  = value_detents_value_2_value_1 as Resource
                        Resource_serializer.write(valueSerializer, value_detents_value_2_value_1_2)
                    }
                }
            }
        }
        const value_blurStyle  = value.blurStyle
        let value_blurStyle_type : int32 = RuntimeType.UNDEFINED
        value_blurStyle_type = runtimeType(value_blurStyle)
        valueSerializer.writeInt8((value_blurStyle_type).toChar())
        if ((value_blurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_blurStyle_value  = (value_blurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_blurStyle_value))
        }
        const value_showClose  = value.showClose
        let value_showClose_type : int32 = RuntimeType.UNDEFINED
        value_showClose_type = runtimeType(value_showClose)
        valueSerializer.writeInt8((value_showClose_type).toChar())
        if ((value_showClose_type) != (RuntimeType.UNDEFINED)) {
            const value_showClose_value  = value_showClose!
            let value_showClose_value_type : int32 = RuntimeType.UNDEFINED
            value_showClose_value_type = runtimeType(value_showClose_value)
            if (RuntimeType.BOOLEAN == value_showClose_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_showClose_value_0  = value_showClose_value as boolean
                valueSerializer.writeBoolean(value_showClose_value_0)
            }
            else if (RuntimeType.OBJECT == value_showClose_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_showClose_value_1  = value_showClose_value as Resource
                Resource_serializer.write(valueSerializer, value_showClose_value_1)
            }
        }
        const value_preferType  = value.preferType
        let value_preferType_type : int32 = RuntimeType.UNDEFINED
        value_preferType_type = runtimeType(value_preferType)
        valueSerializer.writeInt8((value_preferType_type).toChar())
        if ((value_preferType_type) != (RuntimeType.UNDEFINED)) {
            const value_preferType_value  = (value_preferType as SheetType)
            valueSerializer.writeInt32(TypeChecker.SheetType_ToNumeric(value_preferType_value))
        }
        const value_title  = value.title
        let value_title_type : int32 = RuntimeType.UNDEFINED
        value_title_type = runtimeType(value_title)
        valueSerializer.writeInt8((value_title_type).toChar())
        if ((value_title_type) != (RuntimeType.UNDEFINED)) {
            const value_title_value  = value_title!
            let value_title_value_type : int32 = RuntimeType.UNDEFINED
            value_title_value_type = runtimeType(value_title_value)
            if (RuntimeType.OBJECT == value_title_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_title_value_0  = value_title_value as SheetTitleOptions
                SheetTitleOptions_serializer.write(valueSerializer, value_title_value_0)
            }
            else if (RuntimeType.FUNCTION == value_title_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_title_value_1  = value_title_value as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_title_value_1))
            }
        }
        const value_shouldDismiss  = value.shouldDismiss
        let value_shouldDismiss_type : int32 = RuntimeType.UNDEFINED
        value_shouldDismiss_type = runtimeType(value_shouldDismiss)
        valueSerializer.writeInt8((value_shouldDismiss_type).toChar())
        if ((value_shouldDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_shouldDismiss_value  = value_shouldDismiss!
            valueSerializer.holdAndWriteCallback(value_shouldDismiss_value)
        }
        const value_onWillDismiss  = value.onWillDismiss
        let value_onWillDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillDismiss_type = runtimeType(value_onWillDismiss)
        valueSerializer.writeInt8((value_onWillDismiss_type).toChar())
        if ((value_onWillDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDismiss_value  = value_onWillDismiss!
            valueSerializer.holdAndWriteCallback(value_onWillDismiss_value)
        }
        const value_onWillSpringBackWhenDismiss  = value.onWillSpringBackWhenDismiss
        let value_onWillSpringBackWhenDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillSpringBackWhenDismiss_type = runtimeType(value_onWillSpringBackWhenDismiss)
        valueSerializer.writeInt8((value_onWillSpringBackWhenDismiss_type).toChar())
        if ((value_onWillSpringBackWhenDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillSpringBackWhenDismiss_value  = value_onWillSpringBackWhenDismiss!
            valueSerializer.holdAndWriteCallback(value_onWillSpringBackWhenDismiss_value)
        }
        const value_enableOutsideInteractive  = value.enableOutsideInteractive
        let value_enableOutsideInteractive_type : int32 = RuntimeType.UNDEFINED
        value_enableOutsideInteractive_type = runtimeType(value_enableOutsideInteractive)
        valueSerializer.writeInt8((value_enableOutsideInteractive_type).toChar())
        if ((value_enableOutsideInteractive_type) != (RuntimeType.UNDEFINED)) {
            const value_enableOutsideInteractive_value  = value_enableOutsideInteractive!
            valueSerializer.writeBoolean(value_enableOutsideInteractive_value)
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if (RuntimeType.STRING == value_width_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as string
                valueSerializer.writeString(value_width_value_0)
            }
            else if (RuntimeType.NUMBER == value_width_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as number
                valueSerializer.writeNumber(value_width_value_1)
            }
            else if (RuntimeType.OBJECT == value_width_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as Resource
                Resource_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_borderWidth  = value.borderWidth
        let value_borderWidth_type : int32 = RuntimeType.UNDEFINED
        value_borderWidth_type = runtimeType(value_borderWidth)
        valueSerializer.writeInt8((value_borderWidth_type).toChar())
        if ((value_borderWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_borderWidth_value  = value_borderWidth!
            let value_borderWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_borderWidth_value_type = runtimeType(value_borderWidth_value)
            if ((RuntimeType.STRING == value_borderWidth_value_type) || (RuntimeType.NUMBER == value_borderWidth_value_type) || (RuntimeType.OBJECT == value_borderWidth_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderWidth_value_0  = value_borderWidth_value as Dimension
                let value_borderWidth_value_0_type : int32 = RuntimeType.UNDEFINED
                value_borderWidth_value_0_type = runtimeType(value_borderWidth_value_0)
                if (RuntimeType.STRING == value_borderWidth_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_borderWidth_value_0_0  = value_borderWidth_value_0 as string
                    valueSerializer.writeString(value_borderWidth_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_borderWidth_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_borderWidth_value_0_1  = value_borderWidth_value_0 as number
                    valueSerializer.writeNumber(value_borderWidth_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_borderWidth_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_borderWidth_value_0_2  = value_borderWidth_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_borderWidth_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeWidths(value_borderWidth_value, true, false, true, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderWidth_value_1  = value_borderWidth_value as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, value_borderWidth_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeWidths(value_borderWidth_value, true, false, true, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_borderWidth_value_2  = value_borderWidth_value as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, value_borderWidth_value_2)
            }
        }
        const value_borderColor  = value.borderColor
        let value_borderColor_type : int32 = RuntimeType.UNDEFINED
        value_borderColor_type = runtimeType(value_borderColor)
        valueSerializer.writeInt8((value_borderColor_type).toChar())
        if ((value_borderColor_type) != (RuntimeType.UNDEFINED)) {
            const value_borderColor_value  = value_borderColor!
            let value_borderColor_value_type : int32 = RuntimeType.UNDEFINED
            value_borderColor_value_type = runtimeType(value_borderColor_value)
            if ((TypeChecker.isColor(value_borderColor_value)) || (RuntimeType.NUMBER == value_borderColor_value_type) || (RuntimeType.STRING == value_borderColor_value_type) || (RuntimeType.OBJECT == value_borderColor_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderColor_value_0  = value_borderColor_value as ResourceColor
                let value_borderColor_value_0_type : int32 = RuntimeType.UNDEFINED
                value_borderColor_value_0_type = runtimeType(value_borderColor_value_0)
                if (TypeChecker.isColor(value_borderColor_value_0)) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_borderColor_value_0_0  = value_borderColor_value_0 as Color
                    valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_borderColor_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_borderColor_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_borderColor_value_0_1  = value_borderColor_value_0 as number
                    valueSerializer.writeNumber(value_borderColor_value_0_1)
                }
                else if (RuntimeType.STRING == value_borderColor_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_borderColor_value_0_2  = value_borderColor_value_0 as string
                    valueSerializer.writeString(value_borderColor_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_borderColor_value_0_type) {
                    valueSerializer.writeInt8((3).toChar())
                    const value_borderColor_value_0_3  = value_borderColor_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_borderColor_value_0_3)
                }
            }
            else if (TypeChecker.isEdgeColors(value_borderColor_value, true, false, true, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderColor_value_1  = value_borderColor_value as EdgeColors
                EdgeColors_serializer.write(valueSerializer, value_borderColor_value_1)
            }
            else if (TypeChecker.isLocalizedEdgeColors(value_borderColor_value, true, false, true, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_borderColor_value_2  = value_borderColor_value as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(valueSerializer, value_borderColor_value_2)
            }
        }
        const value_borderStyle  = value.borderStyle
        let value_borderStyle_type : int32 = RuntimeType.UNDEFINED
        value_borderStyle_type = runtimeType(value_borderStyle)
        valueSerializer.writeInt8((value_borderStyle_type).toChar())
        if ((value_borderStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_borderStyle_value  = value_borderStyle!
            let value_borderStyle_value_type : int32 = RuntimeType.UNDEFINED
            value_borderStyle_value_type = runtimeType(value_borderStyle_value)
            if (TypeChecker.isBorderStyle(value_borderStyle_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderStyle_value_0  = value_borderStyle_value as BorderStyle
                valueSerializer.writeInt32(TypeChecker.BorderStyle_ToNumeric(value_borderStyle_value_0))
            }
            else if (RuntimeType.OBJECT == value_borderStyle_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderStyle_value_1  = value_borderStyle_value as EdgeStyles
                EdgeStyles_serializer.write(valueSerializer, value_borderStyle_value_1)
            }
        }
        const value_shadow  = value.shadow
        let value_shadow_type : int32 = RuntimeType.UNDEFINED
        value_shadow_type = runtimeType(value_shadow)
        valueSerializer.writeInt8((value_shadow_type).toChar())
        if ((value_shadow_type) != (RuntimeType.UNDEFINED)) {
            const value_shadow_value  = value_shadow!
            let value_shadow_value_type : int32 = RuntimeType.UNDEFINED
            value_shadow_value_type = runtimeType(value_shadow_value)
            if (RuntimeType.OBJECT == value_shadow_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_shadow_value_0  = value_shadow_value as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, value_shadow_value_0)
            }
            else if (TypeChecker.isShadowStyle(value_shadow_value)) {
                valueSerializer.writeInt8((1).toChar())
                const value_shadow_value_1  = value_shadow_value as ShadowStyle
                valueSerializer.writeInt32(TypeChecker.ShadowStyle_ToNumeric(value_shadow_value_1))
            }
        }
        const value_onHeightDidChange  = value.onHeightDidChange
        let value_onHeightDidChange_type : int32 = RuntimeType.UNDEFINED
        value_onHeightDidChange_type = runtimeType(value_onHeightDidChange)
        valueSerializer.writeInt8((value_onHeightDidChange_type).toChar())
        if ((value_onHeightDidChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onHeightDidChange_value  = value_onHeightDidChange!
            valueSerializer.holdAndWriteCallback(value_onHeightDidChange_value)
        }
        const value_mode  = value.mode
        let value_mode_type : int32 = RuntimeType.UNDEFINED
        value_mode_type = runtimeType(value_mode)
        valueSerializer.writeInt8((value_mode_type).toChar())
        if ((value_mode_type) != (RuntimeType.UNDEFINED)) {
            const value_mode_value  = (value_mode as SheetMode)
            valueSerializer.writeInt32(TypeChecker.SheetMode_ToNumeric(value_mode_value))
        }
        const value_scrollSizeMode  = value.scrollSizeMode
        let value_scrollSizeMode_type : int32 = RuntimeType.UNDEFINED
        value_scrollSizeMode_type = runtimeType(value_scrollSizeMode)
        valueSerializer.writeInt8((value_scrollSizeMode_type).toChar())
        if ((value_scrollSizeMode_type) != (RuntimeType.UNDEFINED)) {
            const value_scrollSizeMode_value  = (value_scrollSizeMode as ScrollSizeMode)
            valueSerializer.writeInt32(TypeChecker.ScrollSizeMode_ToNumeric(value_scrollSizeMode_value))
        }
        const value_onDetentsDidChange  = value.onDetentsDidChange
        let value_onDetentsDidChange_type : int32 = RuntimeType.UNDEFINED
        value_onDetentsDidChange_type = runtimeType(value_onDetentsDidChange)
        valueSerializer.writeInt8((value_onDetentsDidChange_type).toChar())
        if ((value_onDetentsDidChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onDetentsDidChange_value  = value_onDetentsDidChange!
            valueSerializer.holdAndWriteCallback(value_onDetentsDidChange_value)
        }
        const value_onWidthDidChange  = value.onWidthDidChange
        let value_onWidthDidChange_type : int32 = RuntimeType.UNDEFINED
        value_onWidthDidChange_type = runtimeType(value_onWidthDidChange)
        valueSerializer.writeInt8((value_onWidthDidChange_type).toChar())
        if ((value_onWidthDidChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onWidthDidChange_value  = value_onWidthDidChange!
            valueSerializer.holdAndWriteCallback(value_onWidthDidChange_value)
        }
        const value_onTypeDidChange  = value.onTypeDidChange
        let value_onTypeDidChange_type : int32 = RuntimeType.UNDEFINED
        value_onTypeDidChange_type = runtimeType(value_onTypeDidChange)
        valueSerializer.writeInt8((value_onTypeDidChange_type).toChar())
        if ((value_onTypeDidChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onTypeDidChange_value  = value_onTypeDidChange!
            valueSerializer.holdAndWriteCallback(value_onTypeDidChange_value)
        }
        const value_uiContext  = value.uiContext
        let value_uiContext_type : int32 = RuntimeType.UNDEFINED
        value_uiContext_type = runtimeType(value_uiContext)
        valueSerializer.writeInt8((value_uiContext_type).toChar())
        if ((value_uiContext_type) != (RuntimeType.UNDEFINED)) {
            const value_uiContext_value  = value_uiContext!
            UIContext_serializer.write(valueSerializer, value_uiContext_value)
        }
        const value_keyboardAvoidMode  = value.keyboardAvoidMode
        let value_keyboardAvoidMode_type : int32 = RuntimeType.UNDEFINED
        value_keyboardAvoidMode_type = runtimeType(value_keyboardAvoidMode)
        valueSerializer.writeInt8((value_keyboardAvoidMode_type).toChar())
        if ((value_keyboardAvoidMode_type) != (RuntimeType.UNDEFINED)) {
            const value_keyboardAvoidMode_value  = (value_keyboardAvoidMode as SheetKeyboardAvoidMode)
            valueSerializer.writeInt32(TypeChecker.SheetKeyboardAvoidMode_ToNumeric(value_keyboardAvoidMode_value))
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_hoverModeArea  = value.hoverModeArea
        let value_hoverModeArea_type : int32 = RuntimeType.UNDEFINED
        value_hoverModeArea_type = runtimeType(value_hoverModeArea)
        valueSerializer.writeInt8((value_hoverModeArea_type).toChar())
        if ((value_hoverModeArea_type) != (RuntimeType.UNDEFINED)) {
            const value_hoverModeArea_value  = (value_hoverModeArea as HoverModeAreaType)
            valueSerializer.writeInt32(TypeChecker.HoverModeAreaType_ToNumeric(value_hoverModeArea_value))
        }
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_effectEdge  = value.effectEdge
        let value_effectEdge_type : int32 = RuntimeType.UNDEFINED
        value_effectEdge_type = runtimeType(value_effectEdge)
        valueSerializer.writeInt8((value_effectEdge_type).toChar())
        if ((value_effectEdge_type) != (RuntimeType.UNDEFINED)) {
            const value_effectEdge_value  = value_effectEdge!
            valueSerializer.writeNumber(value_effectEdge_value)
        }
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        valueSerializer.writeInt8((value_radius_type).toChar())
        if ((value_radius_type) != (RuntimeType.UNDEFINED)) {
            const value_radius_value  = value_radius!
            let value_radius_value_type : int32 = RuntimeType.UNDEFINED
            value_radius_value_type = runtimeType(value_radius_value)
            if (TypeChecker.isLengthMetrics(value_radius_value, false, false)) {
                valueSerializer.writeInt8((0).toChar())
                const value_radius_value_0  = value_radius_value as LengthMetrics
                LengthMetrics_serializer.write(valueSerializer, value_radius_value_0)
            }
            else if (TypeChecker.isBorderRadiuses(value_radius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_radius_value_1  = value_radius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_radius_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_radius_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_radius_value_2  = value_radius_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, value_radius_value_2)
            }
        }
        const value_detentSelection  = value.detentSelection
        let value_detentSelection_type : int32 = RuntimeType.UNDEFINED
        value_detentSelection_type = runtimeType(value_detentSelection)
        valueSerializer.writeInt8((value_detentSelection_type).toChar())
        if ((value_detentSelection_type) != (RuntimeType.UNDEFINED)) {
            const value_detentSelection_value  = value_detentSelection!
            let value_detentSelection_value_type : int32 = RuntimeType.UNDEFINED
            value_detentSelection_value_type = runtimeType(value_detentSelection_value)
            if (TypeChecker.isSheetSize(value_detentSelection_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_detentSelection_value_0  = value_detentSelection_value as SheetSize
                valueSerializer.writeInt32(TypeChecker.SheetSize_ToNumeric(value_detentSelection_value_0))
            }
            else if ((RuntimeType.STRING == value_detentSelection_value_type) || (RuntimeType.NUMBER == value_detentSelection_value_type) || (RuntimeType.OBJECT == value_detentSelection_value_type)) {
                valueSerializer.writeInt8((1).toChar())
                const value_detentSelection_value_1  = value_detentSelection_value as Length
                let value_detentSelection_value_1_type : int32 = RuntimeType.UNDEFINED
                value_detentSelection_value_1_type = runtimeType(value_detentSelection_value_1)
                if (RuntimeType.STRING == value_detentSelection_value_1_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_detentSelection_value_1_0  = value_detentSelection_value_1 as string
                    valueSerializer.writeString(value_detentSelection_value_1_0)
                }
                else if (RuntimeType.NUMBER == value_detentSelection_value_1_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_detentSelection_value_1_1  = value_detentSelection_value_1 as number
                    valueSerializer.writeNumber(value_detentSelection_value_1_1)
                }
                else if (RuntimeType.OBJECT == value_detentSelection_value_1_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_detentSelection_value_1_2  = value_detentSelection_value_1 as Resource
                    Resource_serializer.write(valueSerializer, value_detentSelection_value_1_2)
                }
            }
        }
        const value_showInSubWindow  = value.showInSubWindow
        let value_showInSubWindow_type : int32 = RuntimeType.UNDEFINED
        value_showInSubWindow_type = runtimeType(value_showInSubWindow)
        valueSerializer.writeInt8((value_showInSubWindow_type).toChar())
        if ((value_showInSubWindow_type) != (RuntimeType.UNDEFINED)) {
            const value_showInSubWindow_value  = value_showInSubWindow!
            valueSerializer.writeBoolean(value_showInSubWindow_value)
        }
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_placementOnTarget  = value.placementOnTarget
        let value_placementOnTarget_type : int32 = RuntimeType.UNDEFINED
        value_placementOnTarget_type = runtimeType(value_placementOnTarget)
        valueSerializer.writeInt8((value_placementOnTarget_type).toChar())
        if ((value_placementOnTarget_type) != (RuntimeType.UNDEFINED)) {
            const value_placementOnTarget_value  = value_placementOnTarget!
            valueSerializer.writeBoolean(value_placementOnTarget_value)
        }
    }
    public static read(buffer: DeserializerBase): SheetOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColor_buf : ResourceColor | undefined
        if ((backgroundColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const backgroundColor_buf__selector : int32 = valueDeserializer.readInt8()
            let backgroundColor_buf_ : Color | number | string | Resource | undefined
            if (backgroundColor_buf__selector == (0).toChar()) {
                backgroundColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (backgroundColor_buf__selector == (1).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (backgroundColor_buf__selector == (2).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (backgroundColor_buf__selector == (3).toChar()) {
                backgroundColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for backgroundColor_buf_ has to be chosen through deserialisation.")
            }
            backgroundColor_buf = (backgroundColor_buf_ as Color | number | string | Resource)
        }
        const backgroundColor_result : ResourceColor | undefined = backgroundColor_buf
        const onAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppear_buf : (() => void) | undefined
        if ((onAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onAppear_buf = ():void => { 
    const onAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onAppear_buf__argsSerializer.writeInt32(onAppear_buf__resource.resourceId);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__call);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onAppear_buf__argsSerializer.asBuffer(), onAppear_buf__argsSerializer.length());
    onAppear_buf__argsSerializer.release();
    return; }
        }
        const onAppear_result : (() => void) | undefined = onAppear_buf
        const onDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappear_buf : (() => void) | undefined
        if ((onDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onDisappear_buf = ():void => { 
    const onDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onDisappear_buf__argsSerializer.writeInt32(onDisappear_buf__resource.resourceId);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__call);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onDisappear_buf__argsSerializer.asBuffer(), onDisappear_buf__argsSerializer.length());
    onDisappear_buf__argsSerializer.release();
    return; }
        }
        const onDisappear_result : (() => void) | undefined = onDisappear_buf
        const onWillAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillAppear_buf : (() => void) | undefined
        if ((onWillAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillAppear_buf = ():void => { 
    const onWillAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillAppear_buf__argsSerializer.writeInt32(onWillAppear_buf__resource.resourceId);
    onWillAppear_buf__argsSerializer.writePointer(onWillAppear_buf__call);
    onWillAppear_buf__argsSerializer.writePointer(onWillAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onWillAppear_buf__argsSerializer.asBuffer(), onWillAppear_buf__argsSerializer.length());
    onWillAppear_buf__argsSerializer.release();
    return; }
        }
        const onWillAppear_result : (() => void) | undefined = onWillAppear_buf
        const onWillDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDisappear_buf : (() => void) | undefined
        if ((onWillDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillDisappear_buf = ():void => { 
    const onWillDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDisappear_buf__argsSerializer.writeInt32(onWillDisappear_buf__resource.resourceId);
    onWillDisappear_buf__argsSerializer.writePointer(onWillDisappear_buf__call);
    onWillDisappear_buf__argsSerializer.writePointer(onWillDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onWillDisappear_buf__argsSerializer.asBuffer(), onWillDisappear_buf__argsSerializer.length());
    onWillDisappear_buf__argsSerializer.release();
    return; }
        }
        const onWillDisappear_result : (() => void) | undefined = onWillDisappear_buf
        const height_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let height_buf : SheetSize | Length | undefined
        if ((height_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const height_buf__selector : int32 = valueDeserializer.readInt8()
            let height_buf_ : SheetSize | Length | undefined
            if (height_buf__selector == (0).toChar()) {
                height_buf_ = TypeChecker.SheetSize_FromNumeric(valueDeserializer.readInt32())
            }
            else if (height_buf__selector == (1).toChar()) {
                const height_buf__u_selector : int32 = valueDeserializer.readInt8()
                let height_buf__u : string | number | Resource | undefined
                if (height_buf__u_selector == (0).toChar()) {
                    height_buf__u = (valueDeserializer.readString() as string)
                }
                else if (height_buf__u_selector == (1).toChar()) {
                    height_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (height_buf__u_selector == (2).toChar()) {
                    height_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for height_buf__u has to be chosen through deserialisation.")
                }
                height_buf_ = (height_buf__u as string | number | Resource)
            }
            else {
                throw new Error("One of the branches for height_buf_ has to be chosen through deserialisation.")
            }
            height_buf = (height_buf_ as SheetSize | Length)
        }
        const height_result : SheetSize | Length | undefined = height_buf
        const dragBar_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let dragBar_buf : boolean | undefined
        if ((dragBar_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            dragBar_buf = valueDeserializer.readBoolean()
        }
        const dragBar_result : boolean | undefined = dragBar_buf
        const maskColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let maskColor_buf : ResourceColor | undefined
        if ((maskColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const maskColor_buf__selector : int32 = valueDeserializer.readInt8()
            let maskColor_buf_ : Color | number | string | Resource | undefined
            if (maskColor_buf__selector == (0).toChar()) {
                maskColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (maskColor_buf__selector == (1).toChar()) {
                maskColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (maskColor_buf__selector == (2).toChar()) {
                maskColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (maskColor_buf__selector == (3).toChar()) {
                maskColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for maskColor_buf_ has to be chosen through deserialisation.")
            }
            maskColor_buf = (maskColor_buf_ as Color | number | string | Resource)
        }
        const maskColor_result : ResourceColor | undefined = maskColor_buf
        const detents_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let detents_buf : TripleLengthDetents | undefined
        if ((detents_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const detents_buf__value0_buf_selector : int32 = valueDeserializer.readInt8()
            let detents_buf__value0_buf : SheetSize | Length | undefined
            if (detents_buf__value0_buf_selector == (0).toChar()) {
                detents_buf__value0_buf = TypeChecker.SheetSize_FromNumeric(valueDeserializer.readInt32())
            }
            else if (detents_buf__value0_buf_selector == (1).toChar()) {
                const detents_buf__value0_buf_u_selector : int32 = valueDeserializer.readInt8()
                let detents_buf__value0_buf_u : string | number | Resource | undefined
                if (detents_buf__value0_buf_u_selector == (0).toChar()) {
                    detents_buf__value0_buf_u = (valueDeserializer.readString() as string)
                }
                else if (detents_buf__value0_buf_u_selector == (1).toChar()) {
                    detents_buf__value0_buf_u = (valueDeserializer.readNumber() as number)
                }
                else if (detents_buf__value0_buf_u_selector == (2).toChar()) {
                    detents_buf__value0_buf_u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for detents_buf__value0_buf_u has to be chosen through deserialisation.")
                }
                detents_buf__value0_buf = (detents_buf__value0_buf_u as string | number | Resource)
            }
            else {
                throw new Error("One of the branches for detents_buf__value0_buf has to be chosen through deserialisation.")
            }
            const detents_buf__value0 : SheetSize | Length = (detents_buf__value0_buf as SheetSize | Length)
            const detents_buf__value1_buf_runtimeType  = valueDeserializer.readInt8().toInt()
            let detents_buf__value1_buf : SheetSize | Length | undefined
            if ((detents_buf__value1_buf_runtimeType) != (RuntimeType.UNDEFINED))
            {
                const detents_buf__value1_buf__selector : int32 = valueDeserializer.readInt8()
                let detents_buf__value1_buf_ : SheetSize | Length | undefined
                if (detents_buf__value1_buf__selector == (0).toChar()) {
                    detents_buf__value1_buf_ = TypeChecker.SheetSize_FromNumeric(valueDeserializer.readInt32())
                }
                else if (detents_buf__value1_buf__selector == (1).toChar()) {
                    const detents_buf__value1_buf__u_selector : int32 = valueDeserializer.readInt8()
                    let detents_buf__value1_buf__u : string | number | Resource | undefined
                    if (detents_buf__value1_buf__u_selector == (0).toChar()) {
                        detents_buf__value1_buf__u = (valueDeserializer.readString() as string)
                    }
                    else if (detents_buf__value1_buf__u_selector == (1).toChar()) {
                        detents_buf__value1_buf__u = (valueDeserializer.readNumber() as number)
                    }
                    else if (detents_buf__value1_buf__u_selector == (2).toChar()) {
                        detents_buf__value1_buf__u = Resource_serializer.read(valueDeserializer)
                    }
                    else {
                        throw new Error("One of the branches for detents_buf__value1_buf__u has to be chosen through deserialisation.")
                    }
                    detents_buf__value1_buf_ = (detents_buf__value1_buf__u as string | number | Resource)
                }
                else {
                    throw new Error("One of the branches for detents_buf__value1_buf_ has to be chosen through deserialisation.")
                }
                detents_buf__value1_buf = (detents_buf__value1_buf_ as SheetSize | Length)
            }
            const detents_buf__value1 : SheetSize | Length | undefined = detents_buf__value1_buf
            const detents_buf__value2_buf_runtimeType  = valueDeserializer.readInt8().toInt()
            let detents_buf__value2_buf : SheetSize | Length | undefined
            if ((detents_buf__value2_buf_runtimeType) != (RuntimeType.UNDEFINED))
            {
                const detents_buf__value2_buf__selector : int32 = valueDeserializer.readInt8()
                let detents_buf__value2_buf_ : SheetSize | Length | undefined
                if (detents_buf__value2_buf__selector == (0).toChar()) {
                    detents_buf__value2_buf_ = TypeChecker.SheetSize_FromNumeric(valueDeserializer.readInt32())
                }
                else if (detents_buf__value2_buf__selector == (1).toChar()) {
                    const detents_buf__value2_buf__u_selector : int32 = valueDeserializer.readInt8()
                    let detents_buf__value2_buf__u : string | number | Resource | undefined
                    if (detents_buf__value2_buf__u_selector == (0).toChar()) {
                        detents_buf__value2_buf__u = (valueDeserializer.readString() as string)
                    }
                    else if (detents_buf__value2_buf__u_selector == (1).toChar()) {
                        detents_buf__value2_buf__u = (valueDeserializer.readNumber() as number)
                    }
                    else if (detents_buf__value2_buf__u_selector == (2).toChar()) {
                        detents_buf__value2_buf__u = Resource_serializer.read(valueDeserializer)
                    }
                    else {
                        throw new Error("One of the branches for detents_buf__value2_buf__u has to be chosen through deserialisation.")
                    }
                    detents_buf__value2_buf_ = (detents_buf__value2_buf__u as string | number | Resource)
                }
                else {
                    throw new Error("One of the branches for detents_buf__value2_buf_ has to be chosen through deserialisation.")
                }
                detents_buf__value2_buf = (detents_buf__value2_buf_ as SheetSize | Length)
            }
            const detents_buf__value2 : SheetSize | Length | undefined = detents_buf__value2_buf
            detents_buf = ([detents_buf__value0, detents_buf__value1, detents_buf__value2] as TripleLengthDetents)
        }
        const detents_result : TripleLengthDetents | undefined = detents_buf
        const blurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurStyle_buf : BlurStyle | undefined
        if ((blurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            blurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const blurStyle_result : BlurStyle | undefined = blurStyle_buf
        const showClose_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showClose_buf : boolean | Resource | undefined
        if ((showClose_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const showClose_buf__selector : int32 = valueDeserializer.readInt8()
            let showClose_buf_ : boolean | Resource | undefined
            if (showClose_buf__selector == (0).toChar()) {
                showClose_buf_ = valueDeserializer.readBoolean()
            }
            else if (showClose_buf__selector == (1).toChar()) {
                showClose_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for showClose_buf_ has to be chosen through deserialisation.")
            }
            showClose_buf = (showClose_buf_ as boolean | Resource)
        }
        const showClose_result : boolean | Resource | undefined = showClose_buf
        const preferType_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let preferType_buf : SheetType | undefined
        if ((preferType_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            preferType_buf = TypeChecker.SheetType_FromNumeric(valueDeserializer.readInt32())
        }
        const preferType_result : SheetType | undefined = preferType_buf
        const title_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let title_buf : SheetTitleOptions | CustomBuilder | undefined
        if ((title_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const title_buf__selector : int32 = valueDeserializer.readInt8()
            let title_buf_ : SheetTitleOptions | CustomBuilder | undefined
            if (title_buf__selector == (0).toChar()) {
                title_buf_ = SheetTitleOptions_serializer.read(valueDeserializer)
            }
            else if (title_buf__selector == (1).toChar()) {
                const title_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const title_buf__u_call : KPointer = valueDeserializer.readPointer()
                const title_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                title_buf_ = ():void => { 
    const title_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    title_buf__u_argsSerializer.writeInt32(title_buf__u_resource.resourceId);
    title_buf__u_argsSerializer.writePointer(title_buf__u_call);
    title_buf__u_argsSerializer.writePointer(title_buf__u_callSync);
    InteropNativeModule._CallCallback(737226752, title_buf__u_argsSerializer.asBuffer(), title_buf__u_argsSerializer.length());
    title_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for title_buf_ has to be chosen through deserialisation.")
            }
            title_buf = (title_buf_ as SheetTitleOptions | CustomBuilder)
        }
        const title_result : SheetTitleOptions | CustomBuilder | undefined = title_buf
        const shouldDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shouldDismiss_buf : ((sheetDismiss: SheetDismiss) => void) | undefined
        if ((shouldDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const shouldDismiss_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const shouldDismiss_buf__call : KPointer = valueDeserializer.readPointer()
            const shouldDismiss_buf__callSync : KPointer = valueDeserializer.readPointer()
            shouldDismiss_buf = (sheetDismiss: SheetDismiss):void => { 
    const shouldDismiss_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    shouldDismiss_buf__argsSerializer.writeInt32(shouldDismiss_buf__resource.resourceId);
    shouldDismiss_buf__argsSerializer.writePointer(shouldDismiss_buf__call);
    shouldDismiss_buf__argsSerializer.writePointer(shouldDismiss_buf__callSync);
    SheetDismiss_serializer.write(shouldDismiss_buf__argsSerializer, sheetDismiss);
    InteropNativeModule._CallCallback(22609082, shouldDismiss_buf__argsSerializer.asBuffer(), shouldDismiss_buf__argsSerializer.length());
    shouldDismiss_buf__argsSerializer.release();
    return; }
        }
        const shouldDismiss_result : ((sheetDismiss: SheetDismiss) => void) | undefined = shouldDismiss_buf
        const onWillDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismiss_buf : ((value0: DismissSheetAction) => void) | undefined
        if ((onWillDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDismiss_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismiss_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillDismiss_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillDismiss_buf = (value0: DismissSheetAction):void => { 
    const onWillDismiss_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDismiss_buf__argsSerializer.writeInt32(onWillDismiss_buf__resource.resourceId);
    onWillDismiss_buf__argsSerializer.writePointer(onWillDismiss_buf__call);
    onWillDismiss_buf__argsSerializer.writePointer(onWillDismiss_buf__callSync);
    DismissSheetAction_serializer.write(onWillDismiss_buf__argsSerializer, value0);
    InteropNativeModule._CallCallback(889549796, onWillDismiss_buf__argsSerializer.asBuffer(), onWillDismiss_buf__argsSerializer.length());
    onWillDismiss_buf__argsSerializer.release();
    return; }
        }
        const onWillDismiss_result : ((value0: DismissSheetAction) => void) | undefined = onWillDismiss_buf
        const onWillSpringBackWhenDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillSpringBackWhenDismiss_buf : ((value0: SpringBackAction) => void) | undefined
        if ((onWillSpringBackWhenDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillSpringBackWhenDismiss_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillSpringBackWhenDismiss_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillSpringBackWhenDismiss_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillSpringBackWhenDismiss_buf = (value0: SpringBackAction):void => { 
    const onWillSpringBackWhenDismiss_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillSpringBackWhenDismiss_buf__argsSerializer.writeInt32(onWillSpringBackWhenDismiss_buf__resource.resourceId);
    onWillSpringBackWhenDismiss_buf__argsSerializer.writePointer(onWillSpringBackWhenDismiss_buf__call);
    onWillSpringBackWhenDismiss_buf__argsSerializer.writePointer(onWillSpringBackWhenDismiss_buf__callSync);
    SpringBackAction_serializer.write(onWillSpringBackWhenDismiss_buf__argsSerializer, value0);
    InteropNativeModule._CallCallback(1536231691, onWillSpringBackWhenDismiss_buf__argsSerializer.asBuffer(), onWillSpringBackWhenDismiss_buf__argsSerializer.length());
    onWillSpringBackWhenDismiss_buf__argsSerializer.release();
    return; }
        }
        const onWillSpringBackWhenDismiss_result : ((value0: SpringBackAction) => void) | undefined = onWillSpringBackWhenDismiss_buf
        const enableOutsideInteractive_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableOutsideInteractive_buf : boolean | undefined
        if ((enableOutsideInteractive_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableOutsideInteractive_buf = valueDeserializer.readBoolean()
        }
        const enableOutsideInteractive_result : boolean | undefined = enableOutsideInteractive_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Dimension | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : string | number | Resource | undefined
            if (width_buf__selector == (0).toChar()) {
                width_buf_ = (valueDeserializer.readString() as string)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as string | number | Resource)
        }
        const width_result : Dimension | undefined = width_buf
        const borderWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderWidth_buf : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined
        if ((borderWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let borderWidth_buf_ : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined
            if (borderWidth_buf__selector == (0).toChar()) {
                const borderWidth_buf__u_selector : int32 = valueDeserializer.readInt8()
                let borderWidth_buf__u : string | number | Resource | undefined
                if (borderWidth_buf__u_selector == (0).toChar()) {
                    borderWidth_buf__u = (valueDeserializer.readString() as string)
                }
                else if (borderWidth_buf__u_selector == (1).toChar()) {
                    borderWidth_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (borderWidth_buf__u_selector == (2).toChar()) {
                    borderWidth_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for borderWidth_buf__u has to be chosen through deserialisation.")
                }
                borderWidth_buf_ = (borderWidth_buf__u as string | number | Resource)
            }
            else if (borderWidth_buf__selector == (1).toChar()) {
                borderWidth_buf_ = EdgeWidths_serializer.read(valueDeserializer)
            }
            else if (borderWidth_buf__selector == (2).toChar()) {
                borderWidth_buf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderWidth_buf_ has to be chosen through deserialisation.")
            }
            borderWidth_buf = (borderWidth_buf_ as Dimension | EdgeWidths | LocalizedEdgeWidths)
        }
        const borderWidth_result : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined = borderWidth_buf
        const borderColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderColor_buf : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
        if ((borderColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderColor_buf__selector : int32 = valueDeserializer.readInt8()
            let borderColor_buf_ : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
            if (borderColor_buf__selector == (0).toChar()) {
                const borderColor_buf__u_selector : int32 = valueDeserializer.readInt8()
                let borderColor_buf__u : Color | number | string | Resource | undefined
                if (borderColor_buf__u_selector == (0).toChar()) {
                    borderColor_buf__u = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
                }
                else if (borderColor_buf__u_selector == (1).toChar()) {
                    borderColor_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (borderColor_buf__u_selector == (2).toChar()) {
                    borderColor_buf__u = (valueDeserializer.readString() as string)
                }
                else if (borderColor_buf__u_selector == (3).toChar()) {
                    borderColor_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for borderColor_buf__u has to be chosen through deserialisation.")
                }
                borderColor_buf_ = (borderColor_buf__u as Color | number | string | Resource)
            }
            else if (borderColor_buf__selector == (1).toChar()) {
                borderColor_buf_ = EdgeColors_serializer.read(valueDeserializer)
            }
            else if (borderColor_buf__selector == (2).toChar()) {
                borderColor_buf_ = LocalizedEdgeColors_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderColor_buf_ has to be chosen through deserialisation.")
            }
            borderColor_buf = (borderColor_buf_ as ResourceColor | EdgeColors | LocalizedEdgeColors)
        }
        const borderColor_result : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined = borderColor_buf
        const borderStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderStyle_buf : BorderStyle | EdgeStyles | undefined
        if ((borderStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderStyle_buf__selector : int32 = valueDeserializer.readInt8()
            let borderStyle_buf_ : BorderStyle | EdgeStyles | undefined
            if (borderStyle_buf__selector == (0).toChar()) {
                borderStyle_buf_ = TypeChecker.BorderStyle_FromNumeric(valueDeserializer.readInt32())
            }
            else if (borderStyle_buf__selector == (1).toChar()) {
                borderStyle_buf_ = EdgeStyles_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderStyle_buf_ has to be chosen through deserialisation.")
            }
            borderStyle_buf = (borderStyle_buf_ as BorderStyle | EdgeStyles)
        }
        const borderStyle_result : BorderStyle | EdgeStyles | undefined = borderStyle_buf
        const shadow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadow_buf : ShadowOptions | ShadowStyle | undefined
        if ((shadow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const shadow_buf__selector : int32 = valueDeserializer.readInt8()
            let shadow_buf_ : ShadowOptions | ShadowStyle | undefined
            if (shadow_buf__selector == (0).toChar()) {
                shadow_buf_ = ShadowOptions_serializer.read(valueDeserializer)
            }
            else if (shadow_buf__selector == (1).toChar()) {
                shadow_buf_ = TypeChecker.ShadowStyle_FromNumeric(valueDeserializer.readInt32())
            }
            else {
                throw new Error("One of the branches for shadow_buf_ has to be chosen through deserialisation.")
            }
            shadow_buf = (shadow_buf_ as ShadowOptions | ShadowStyle)
        }
        const shadow_result : ShadowOptions | ShadowStyle | undefined = shadow_buf
        const onHeightDidChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onHeightDidChange_buf : ((value0: number) => void) | undefined
        if ((onHeightDidChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onHeightDidChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onHeightDidChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onHeightDidChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onHeightDidChange_buf = (value0: number):void => { 
    const onHeightDidChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onHeightDidChange_buf__argsSerializer.writeInt32(onHeightDidChange_buf__resource.resourceId);
    onHeightDidChange_buf__argsSerializer.writePointer(onHeightDidChange_buf__call);
    onHeightDidChange_buf__argsSerializer.writePointer(onHeightDidChange_buf__callSync);
    onHeightDidChange_buf__argsSerializer.writeNumber(value0);
    InteropNativeModule._CallCallback(36519084, onHeightDidChange_buf__argsSerializer.asBuffer(), onHeightDidChange_buf__argsSerializer.length());
    onHeightDidChange_buf__argsSerializer.release();
    return; }
        }
        const onHeightDidChange_result : ((value0: number) => void) | undefined = onHeightDidChange_buf
        const mode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let mode_buf : SheetMode | undefined
        if ((mode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            mode_buf = TypeChecker.SheetMode_FromNumeric(valueDeserializer.readInt32())
        }
        const mode_result : SheetMode | undefined = mode_buf
        const scrollSizeMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scrollSizeMode_buf : ScrollSizeMode | undefined
        if ((scrollSizeMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            scrollSizeMode_buf = TypeChecker.ScrollSizeMode_FromNumeric(valueDeserializer.readInt32())
        }
        const scrollSizeMode_result : ScrollSizeMode | undefined = scrollSizeMode_buf
        const onDetentsDidChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDetentsDidChange_buf : ((value0: number) => void) | undefined
        if ((onDetentsDidChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onDetentsDidChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDetentsDidChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onDetentsDidChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onDetentsDidChange_buf = (value0: number):void => { 
    const onDetentsDidChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onDetentsDidChange_buf__argsSerializer.writeInt32(onDetentsDidChange_buf__resource.resourceId);
    onDetentsDidChange_buf__argsSerializer.writePointer(onDetentsDidChange_buf__call);
    onDetentsDidChange_buf__argsSerializer.writePointer(onDetentsDidChange_buf__callSync);
    onDetentsDidChange_buf__argsSerializer.writeNumber(value0);
    InteropNativeModule._CallCallback(36519084, onDetentsDidChange_buf__argsSerializer.asBuffer(), onDetentsDidChange_buf__argsSerializer.length());
    onDetentsDidChange_buf__argsSerializer.release();
    return; }
        }
        const onDetentsDidChange_result : ((value0: number) => void) | undefined = onDetentsDidChange_buf
        const onWidthDidChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWidthDidChange_buf : ((value0: number) => void) | undefined
        if ((onWidthDidChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWidthDidChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWidthDidChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onWidthDidChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWidthDidChange_buf = (value0: number):void => { 
    const onWidthDidChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWidthDidChange_buf__argsSerializer.writeInt32(onWidthDidChange_buf__resource.resourceId);
    onWidthDidChange_buf__argsSerializer.writePointer(onWidthDidChange_buf__call);
    onWidthDidChange_buf__argsSerializer.writePointer(onWidthDidChange_buf__callSync);
    onWidthDidChange_buf__argsSerializer.writeNumber(value0);
    InteropNativeModule._CallCallback(36519084, onWidthDidChange_buf__argsSerializer.asBuffer(), onWidthDidChange_buf__argsSerializer.length());
    onWidthDidChange_buf__argsSerializer.release();
    return; }
        }
        const onWidthDidChange_result : ((value0: number) => void) | undefined = onWidthDidChange_buf
        const onTypeDidChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onTypeDidChange_buf : ((value0: SheetType) => void) | undefined
        if ((onTypeDidChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onTypeDidChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onTypeDidChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onTypeDidChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onTypeDidChange_buf = (value0: SheetType):void => { 
    const onTypeDidChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onTypeDidChange_buf__argsSerializer.writeInt32(onTypeDidChange_buf__resource.resourceId);
    onTypeDidChange_buf__argsSerializer.writePointer(onTypeDidChange_buf__call);
    onTypeDidChange_buf__argsSerializer.writePointer(onTypeDidChange_buf__callSync);
    onTypeDidChange_buf__argsSerializer.writeInt32(TypeChecker.SheetType_ToNumeric(value0));
    InteropNativeModule._CallCallback(-224451112, onTypeDidChange_buf__argsSerializer.asBuffer(), onTypeDidChange_buf__argsSerializer.length());
    onTypeDidChange_buf__argsSerializer.release();
    return; }
        }
        const onTypeDidChange_result : ((value0: SheetType) => void) | undefined = onTypeDidChange_buf
        const uiContext_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let uiContext_buf : UIContext | undefined
        if ((uiContext_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            uiContext_buf = (UIContext_serializer.read(valueDeserializer) as UIContext)
        }
        const uiContext_result : UIContext | undefined = uiContext_buf
        const keyboardAvoidMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidMode_buf : SheetKeyboardAvoidMode | undefined
        if ((keyboardAvoidMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            keyboardAvoidMode_buf = TypeChecker.SheetKeyboardAvoidMode_FromNumeric(valueDeserializer.readInt32())
        }
        const keyboardAvoidMode_result : SheetKeyboardAvoidMode | undefined = keyboardAvoidMode_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const hoverModeArea_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hoverModeArea_buf : HoverModeAreaType | undefined
        if ((hoverModeArea_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            hoverModeArea_buf = TypeChecker.HoverModeAreaType_FromNumeric(valueDeserializer.readInt32())
        }
        const hoverModeArea_result : HoverModeAreaType | undefined = hoverModeArea_buf
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const effectEdge_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let effectEdge_buf : number | undefined
        if ((effectEdge_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            effectEdge_buf = (valueDeserializer.readNumber() as number)
        }
        const effectEdge_result : number | undefined = effectEdge_buf
        const radius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radius_buf : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined
        if ((radius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const radius_buf__selector : int32 = valueDeserializer.readInt8()
            let radius_buf_ : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (radius_buf__selector == (0).toChar()) {
                radius_buf_ = (LengthMetrics_serializer.read(valueDeserializer) as LengthMetrics)
            }
            else if (radius_buf__selector == (1).toChar()) {
                radius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else if (radius_buf__selector == (2).toChar()) {
                radius_buf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for radius_buf_ has to be chosen through deserialisation.")
            }
            radius_buf = (radius_buf_ as LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const radius_result : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined = radius_buf
        const detentSelection_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let detentSelection_buf : SheetSize | Length | undefined
        if ((detentSelection_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const detentSelection_buf__selector : int32 = valueDeserializer.readInt8()
            let detentSelection_buf_ : SheetSize | Length | undefined
            if (detentSelection_buf__selector == (0).toChar()) {
                detentSelection_buf_ = TypeChecker.SheetSize_FromNumeric(valueDeserializer.readInt32())
            }
            else if (detentSelection_buf__selector == (1).toChar()) {
                const detentSelection_buf__u_selector : int32 = valueDeserializer.readInt8()
                let detentSelection_buf__u : string | number | Resource | undefined
                if (detentSelection_buf__u_selector == (0).toChar()) {
                    detentSelection_buf__u = (valueDeserializer.readString() as string)
                }
                else if (detentSelection_buf__u_selector == (1).toChar()) {
                    detentSelection_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (detentSelection_buf__u_selector == (2).toChar()) {
                    detentSelection_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for detentSelection_buf__u has to be chosen through deserialisation.")
                }
                detentSelection_buf_ = (detentSelection_buf__u as string | number | Resource)
            }
            else {
                throw new Error("One of the branches for detentSelection_buf_ has to be chosen through deserialisation.")
            }
            detentSelection_buf = (detentSelection_buf_ as SheetSize | Length)
        }
        const detentSelection_result : SheetSize | Length | undefined = detentSelection_buf
        const showInSubWindow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindow_buf : boolean | undefined
        if ((showInSubWindow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            showInSubWindow_buf = valueDeserializer.readBoolean()
        }
        const showInSubWindow_result : boolean | undefined = showInSubWindow_buf
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const placementOnTarget_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementOnTarget_buf : boolean | undefined
        if ((placementOnTarget_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placementOnTarget_buf = valueDeserializer.readBoolean()
        }
        const placementOnTarget_result : boolean | undefined = placementOnTarget_buf
        let value : SheetOptions = ({backgroundColor: backgroundColor_result, onAppear: onAppear_result, onDisappear: onDisappear_result, onWillAppear: onWillAppear_result, onWillDisappear: onWillDisappear_result, height: height_result, dragBar: dragBar_result, maskColor: maskColor_result, detents: detents_result, blurStyle: blurStyle_result, showClose: showClose_result, preferType: preferType_result, title: title_result, shouldDismiss: shouldDismiss_result, onWillDismiss: onWillDismiss_result, onWillSpringBackWhenDismiss: onWillSpringBackWhenDismiss_result, enableOutsideInteractive: enableOutsideInteractive_result, width: width_result, borderWidth: borderWidth_result, borderColor: borderColor_result, borderStyle: borderStyle_result, shadow: shadow_result, onHeightDidChange: onHeightDidChange_result, mode: mode_result, scrollSizeMode: scrollSizeMode_result, onDetentsDidChange: onDetentsDidChange_result, onWidthDidChange: onWidthDidChange_result, onTypeDidChange: onTypeDidChange_result, uiContext: uiContext_result, keyboardAvoidMode: keyboardAvoidMode_result, enableHoverMode: enableHoverMode_result, hoverModeArea: hoverModeArea_result, offset: offset_result, effectEdge: effectEdge_result, radius: radius_result, detentSelection: detentSelection_result, showInSubWindow: showInSubWindow_result, placement: placement_result, placementOnTarget: placementOnTarget_result} as SheetOptions)
        return value
    }
}
export class TouchEvent_serializer {
    public static write(buffer: SerializerBase, value: TouchEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TouchEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TouchEventInternal.fromPtr(ptr)
    }
}
export class AccessibilityHoverEvent_serializer {
    public static write(buffer: SerializerBase, value: AccessibilityHoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AccessibilityHoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AccessibilityHoverEventInternal.fromPtr(ptr)
    }
}
export class AxisEvent_serializer {
    public static write(buffer: SerializerBase, value: AxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AxisEventInternal.fromPtr(ptr)
    }
}
export class BaseEvent_serializer {
    public static write(buffer: SerializerBase, value: BaseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): BaseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return BaseEventInternal.fromPtr(ptr)
    }
}
export class ClickEvent_serializer {
    public static write(buffer: SerializerBase, value: ClickEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ClickEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ClickEventInternal.fromPtr(ptr)
    }
}
export class AsymmetricTransitionOption_serializer {
    public static write(buffer: SerializerBase, value: AsymmetricTransitionOption): void {
        let valueSerializer : SerializerBase = buffer
        const value_appear  = value.appear
        TransitionEffect_serializer.write(valueSerializer, value_appear)
        const value_disappear  = value.disappear
        TransitionEffect_serializer.write(valueSerializer, value_disappear)
    }
    public static read(buffer: DeserializerBase): AsymmetricTransitionOption {
        let valueDeserializer : DeserializerBase = buffer
        const appear_result : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        const disappear_result : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        let value : AsymmetricTransitionOption = ({appear: appear_result, disappear: disappear_result} as AsymmetricTransitionOption)
        return value
    }
}
export class ContentCoverOptions_serializer {
    public static write(buffer: SerializerBase, value: ContentCoverOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_backgroundColor  = value.backgroundColor
        let value_backgroundColor_type : int32 = RuntimeType.UNDEFINED
        value_backgroundColor_type = runtimeType(value_backgroundColor)
        valueSerializer.writeInt8((value_backgroundColor_type).toChar())
        if ((value_backgroundColor_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundColor_value  = value_backgroundColor!
            let value_backgroundColor_value_type : int32 = RuntimeType.UNDEFINED
            value_backgroundColor_value_type = runtimeType(value_backgroundColor_value)
            if (TypeChecker.isColor(value_backgroundColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_backgroundColor_value_0  = value_backgroundColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_backgroundColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_backgroundColor_value_1  = value_backgroundColor_value as number
                valueSerializer.writeNumber(value_backgroundColor_value_1)
            }
            else if (RuntimeType.STRING == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_backgroundColor_value_2  = value_backgroundColor_value as string
                valueSerializer.writeString(value_backgroundColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_backgroundColor_value_3  = value_backgroundColor_value as Resource
                Resource_serializer.write(valueSerializer, value_backgroundColor_value_3)
            }
        }
        const value_onAppear  = value.onAppear
        let value_onAppear_type : int32 = RuntimeType.UNDEFINED
        value_onAppear_type = runtimeType(value_onAppear)
        valueSerializer.writeInt8((value_onAppear_type).toChar())
        if ((value_onAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onAppear_value  = value_onAppear!
            valueSerializer.holdAndWriteCallback(value_onAppear_value)
        }
        const value_onDisappear  = value.onDisappear
        let value_onDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onDisappear_type = runtimeType(value_onDisappear)
        valueSerializer.writeInt8((value_onDisappear_type).toChar())
        if ((value_onDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onDisappear_value  = value_onDisappear!
            valueSerializer.holdAndWriteCallback(value_onDisappear_value)
        }
        const value_onWillAppear  = value.onWillAppear
        let value_onWillAppear_type : int32 = RuntimeType.UNDEFINED
        value_onWillAppear_type = runtimeType(value_onWillAppear)
        valueSerializer.writeInt8((value_onWillAppear_type).toChar())
        if ((value_onWillAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillAppear_value  = value_onWillAppear!
            valueSerializer.holdAndWriteCallback(value_onWillAppear_value)
        }
        const value_onWillDisappear  = value.onWillDisappear
        let value_onWillDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onWillDisappear_type = runtimeType(value_onWillDisappear)
        valueSerializer.writeInt8((value_onWillDisappear_type).toChar())
        if ((value_onWillDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDisappear_value  = value_onWillDisappear!
            valueSerializer.holdAndWriteCallback(value_onWillDisappear_value)
        }
        const value_modalTransition  = value.modalTransition
        let value_modalTransition_type : int32 = RuntimeType.UNDEFINED
        value_modalTransition_type = runtimeType(value_modalTransition)
        valueSerializer.writeInt8((value_modalTransition_type).toChar())
        if ((value_modalTransition_type) != (RuntimeType.UNDEFINED)) {
            const value_modalTransition_value  = (value_modalTransition as ModalTransition)
            valueSerializer.writeInt32(TypeChecker.ModalTransition_ToNumeric(value_modalTransition_value))
        }
        const value_onWillDismiss  = value.onWillDismiss
        let value_onWillDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillDismiss_type = runtimeType(value_onWillDismiss)
        valueSerializer.writeInt8((value_onWillDismiss_type).toChar())
        if ((value_onWillDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDismiss_value  = value_onWillDismiss!
            valueSerializer.holdAndWriteCallback(value_onWillDismiss_value)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
    }
    public static read(buffer: DeserializerBase): ContentCoverOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColor_buf : ResourceColor | undefined
        if ((backgroundColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const backgroundColor_buf__selector : int32 = valueDeserializer.readInt8()
            let backgroundColor_buf_ : Color | number | string | Resource | undefined
            if (backgroundColor_buf__selector == (0).toChar()) {
                backgroundColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (backgroundColor_buf__selector == (1).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (backgroundColor_buf__selector == (2).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (backgroundColor_buf__selector == (3).toChar()) {
                backgroundColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for backgroundColor_buf_ has to be chosen through deserialisation.")
            }
            backgroundColor_buf = (backgroundColor_buf_ as Color | number | string | Resource)
        }
        const backgroundColor_result : ResourceColor | undefined = backgroundColor_buf
        const onAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppear_buf : (() => void) | undefined
        if ((onAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onAppear_buf = ():void => { 
    const onAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onAppear_buf__argsSerializer.writeInt32(onAppear_buf__resource.resourceId);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__call);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onAppear_buf__argsSerializer.asBuffer(), onAppear_buf__argsSerializer.length());
    onAppear_buf__argsSerializer.release();
    return; }
        }
        const onAppear_result : (() => void) | undefined = onAppear_buf
        const onDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappear_buf : (() => void) | undefined
        if ((onDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onDisappear_buf = ():void => { 
    const onDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onDisappear_buf__argsSerializer.writeInt32(onDisappear_buf__resource.resourceId);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__call);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onDisappear_buf__argsSerializer.asBuffer(), onDisappear_buf__argsSerializer.length());
    onDisappear_buf__argsSerializer.release();
    return; }
        }
        const onDisappear_result : (() => void) | undefined = onDisappear_buf
        const onWillAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillAppear_buf : (() => void) | undefined
        if ((onWillAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillAppear_buf = ():void => { 
    const onWillAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillAppear_buf__argsSerializer.writeInt32(onWillAppear_buf__resource.resourceId);
    onWillAppear_buf__argsSerializer.writePointer(onWillAppear_buf__call);
    onWillAppear_buf__argsSerializer.writePointer(onWillAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onWillAppear_buf__argsSerializer.asBuffer(), onWillAppear_buf__argsSerializer.length());
    onWillAppear_buf__argsSerializer.release();
    return; }
        }
        const onWillAppear_result : (() => void) | undefined = onWillAppear_buf
        const onWillDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDisappear_buf : (() => void) | undefined
        if ((onWillDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillDisappear_buf = ():void => { 
    const onWillDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDisappear_buf__argsSerializer.writeInt32(onWillDisappear_buf__resource.resourceId);
    onWillDisappear_buf__argsSerializer.writePointer(onWillDisappear_buf__call);
    onWillDisappear_buf__argsSerializer.writePointer(onWillDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onWillDisappear_buf__argsSerializer.asBuffer(), onWillDisappear_buf__argsSerializer.length());
    onWillDisappear_buf__argsSerializer.release();
    return; }
        }
        const onWillDisappear_result : (() => void) | undefined = onWillDisappear_buf
        const modalTransition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modalTransition_buf : ModalTransition | undefined
        if ((modalTransition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            modalTransition_buf = TypeChecker.ModalTransition_FromNumeric(valueDeserializer.readInt32())
        }
        const modalTransition_result : ModalTransition | undefined = modalTransition_buf
        const onWillDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismiss_buf : ((value0: DismissContentCoverAction) => void) | undefined
        if ((onWillDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDismiss_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismiss_buf__call : KPointer = valueDeserializer.readPointer()
            const onWillDismiss_buf__callSync : KPointer = valueDeserializer.readPointer()
            onWillDismiss_buf = (value0: DismissContentCoverAction):void => { 
    const onWillDismiss_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDismiss_buf__argsSerializer.writeInt32(onWillDismiss_buf__resource.resourceId);
    onWillDismiss_buf__argsSerializer.writePointer(onWillDismiss_buf__call);
    onWillDismiss_buf__argsSerializer.writePointer(onWillDismiss_buf__callSync);
    DismissContentCoverAction_serializer.write(onWillDismiss_buf__argsSerializer, value0);
    InteropNativeModule._CallCallback(-1283506641, onWillDismiss_buf__argsSerializer.asBuffer(), onWillDismiss_buf__argsSerializer.length());
    onWillDismiss_buf__argsSerializer.release();
    return; }
        }
        const onWillDismiss_result : ((value0: DismissContentCoverAction) => void) | undefined = onWillDismiss_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        let value : ContentCoverOptions = ({backgroundColor: backgroundColor_result, onAppear: onAppear_result, onDisappear: onDisappear_result, onWillAppear: onWillAppear_result, onWillDisappear: onWillDisappear_result, modalTransition: modalTransition_result, onWillDismiss: onWillDismiss_result, transition: transition_result} as ContentCoverOptions)
        return value
    }
}
export class ContextMenuAnimationOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuAnimationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_scale  = value.scale
        let value_scale_type : int32 = RuntimeType.UNDEFINED
        value_scale_type = runtimeType(value_scale)
        valueSerializer.writeInt8((value_scale_type).toChar())
        if ((value_scale_type) != (RuntimeType.UNDEFINED)) {
            const value_scale_value  = value_scale!
            const value_scale_value_0  = value_scale_value[0]
            valueSerializer.writeNumber(value_scale_value_0)
            const value_scale_value_1  = value_scale_value[1]
            valueSerializer.writeNumber(value_scale_value_1)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_hoverScale  = value.hoverScale
        let value_hoverScale_type : int32 = RuntimeType.UNDEFINED
        value_hoverScale_type = runtimeType(value_hoverScale)
        valueSerializer.writeInt8((value_hoverScale_type).toChar())
        if ((value_hoverScale_type) != (RuntimeType.UNDEFINED)) {
            const value_hoverScale_value  = value_hoverScale!
            const value_hoverScale_value_0  = value_hoverScale_value[0]
            valueSerializer.writeNumber(value_hoverScale_value_0)
            const value_hoverScale_value_1  = value_hoverScale_value[1]
            valueSerializer.writeNumber(value_hoverScale_value_1)
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuAnimationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scale_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scale_buf : AnimationNumberRange | undefined
        if ((scale_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const scale_buf__value0 : number = (valueDeserializer.readNumber() as number)
            const scale_buf__value1 : number = (valueDeserializer.readNumber() as number)
            scale_buf = ([scale_buf__value0, scale_buf__value1] as AnimationNumberRange)
        }
        const scale_result : AnimationNumberRange | undefined = scale_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const hoverScale_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hoverScale_buf : AnimationNumberRange | undefined
        if ((hoverScale_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const hoverScale_buf__value0 : number = (valueDeserializer.readNumber() as number)
            const hoverScale_buf__value1 : number = (valueDeserializer.readNumber() as number)
            hoverScale_buf = ([hoverScale_buf__value0, hoverScale_buf__value1] as AnimationNumberRange)
        }
        const hoverScale_result : AnimationNumberRange | undefined = hoverScale_buf
        let value : ContextMenuAnimationOptions = ({scale: scale_result, transition: transition_result, hoverScale: hoverScale_result} as ContextMenuAnimationOptions)
        return value
    }
}
export class ContextMenuOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_arrowOffset  = value.arrowOffset
        let value_arrowOffset_type : int32 = RuntimeType.UNDEFINED
        value_arrowOffset_type = runtimeType(value_arrowOffset)
        valueSerializer.writeInt8((value_arrowOffset_type).toChar())
        if ((value_arrowOffset_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowOffset_value  = value_arrowOffset!
            let value_arrowOffset_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowOffset_value_type = runtimeType(value_arrowOffset_value)
            if (RuntimeType.STRING == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowOffset_value_0  = value_arrowOffset_value as string
                valueSerializer.writeString(value_arrowOffset_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowOffset_value_1  = value_arrowOffset_value as number
                valueSerializer.writeNumber(value_arrowOffset_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowOffset_value_2  = value_arrowOffset_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowOffset_value_2)
            }
        }
        const value_preview  = value.preview
        let value_preview_type : int32 = RuntimeType.UNDEFINED
        value_preview_type = runtimeType(value_preview)
        valueSerializer.writeInt8((value_preview_type).toChar())
        if ((value_preview_type) != (RuntimeType.UNDEFINED)) {
            const value_preview_value  = value_preview!
            let value_preview_value_type : int32 = RuntimeType.UNDEFINED
            value_preview_value_type = runtimeType(value_preview_value)
            if (TypeChecker.isMenuPreviewMode(value_preview_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_preview_value_0  = value_preview_value as MenuPreviewMode
                valueSerializer.writeInt32(TypeChecker.MenuPreviewMode_ToNumeric(value_preview_value_0))
            }
            else if (RuntimeType.FUNCTION == value_preview_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_preview_value_1  = value_preview_value as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_preview_value_1))
            }
        }
        const value_previewBorderRadius  = value.previewBorderRadius
        let value_previewBorderRadius_type : int32 = RuntimeType.UNDEFINED
        value_previewBorderRadius_type = runtimeType(value_previewBorderRadius)
        valueSerializer.writeInt8((value_previewBorderRadius_type).toChar())
        if ((value_previewBorderRadius_type) != (RuntimeType.UNDEFINED)) {
            const value_previewBorderRadius_value  = value_previewBorderRadius!
            let value_previewBorderRadius_value_type : int32 = RuntimeType.UNDEFINED
            value_previewBorderRadius_value_type = runtimeType(value_previewBorderRadius_value)
            if ((RuntimeType.STRING == value_previewBorderRadius_value_type) || (RuntimeType.NUMBER == value_previewBorderRadius_value_type) || (RuntimeType.OBJECT == value_previewBorderRadius_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_previewBorderRadius_value_0  = value_previewBorderRadius_value as Length
                let value_previewBorderRadius_value_0_type : int32 = RuntimeType.UNDEFINED
                value_previewBorderRadius_value_0_type = runtimeType(value_previewBorderRadius_value_0)
                if (RuntimeType.STRING == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_previewBorderRadius_value_0_0  = value_previewBorderRadius_value_0 as string
                    valueSerializer.writeString(value_previewBorderRadius_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_previewBorderRadius_value_0_1  = value_previewBorderRadius_value_0 as number
                    valueSerializer.writeNumber(value_previewBorderRadius_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_previewBorderRadius_value_0_2  = value_previewBorderRadius_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_previewBorderRadius_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_previewBorderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_previewBorderRadius_value_1  = value_previewBorderRadius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_previewBorderRadius_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_previewBorderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_previewBorderRadius_value_2  = value_previewBorderRadius_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, value_previewBorderRadius_value_2)
            }
        }
        const value_borderRadius  = value.borderRadius
        let value_borderRadius_type : int32 = RuntimeType.UNDEFINED
        value_borderRadius_type = runtimeType(value_borderRadius)
        valueSerializer.writeInt8((value_borderRadius_type).toChar())
        if ((value_borderRadius_type) != (RuntimeType.UNDEFINED)) {
            const value_borderRadius_value  = value_borderRadius!
            let value_borderRadius_value_type : int32 = RuntimeType.UNDEFINED
            value_borderRadius_value_type = runtimeType(value_borderRadius_value)
            if ((RuntimeType.STRING == value_borderRadius_value_type) || (RuntimeType.NUMBER == value_borderRadius_value_type) || (RuntimeType.OBJECT == value_borderRadius_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderRadius_value_0  = value_borderRadius_value as Length
                let value_borderRadius_value_0_type : int32 = RuntimeType.UNDEFINED
                value_borderRadius_value_0_type = runtimeType(value_borderRadius_value_0)
                if (RuntimeType.STRING == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_borderRadius_value_0_0  = value_borderRadius_value_0 as string
                    valueSerializer.writeString(value_borderRadius_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_borderRadius_value_0_1  = value_borderRadius_value_0 as number
                    valueSerializer.writeNumber(value_borderRadius_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_borderRadius_value_0_2  = value_borderRadius_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_borderRadius_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_borderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderRadius_value_1  = value_borderRadius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_borderRadius_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_borderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_borderRadius_value_2  = value_borderRadius_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, value_borderRadius_value_2)
            }
        }
        const value_onAppear  = value.onAppear
        let value_onAppear_type : int32 = RuntimeType.UNDEFINED
        value_onAppear_type = runtimeType(value_onAppear)
        valueSerializer.writeInt8((value_onAppear_type).toChar())
        if ((value_onAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onAppear_value  = value_onAppear!
            valueSerializer.holdAndWriteCallback(value_onAppear_value)
        }
        const value_onDisappear  = value.onDisappear
        let value_onDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onDisappear_type = runtimeType(value_onDisappear)
        valueSerializer.writeInt8((value_onDisappear_type).toChar())
        if ((value_onDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onDisappear_value  = value_onDisappear!
            valueSerializer.holdAndWriteCallback(value_onDisappear_value)
        }
        const value_aboutToAppear  = value.aboutToAppear
        let value_aboutToAppear_type : int32 = RuntimeType.UNDEFINED
        value_aboutToAppear_type = runtimeType(value_aboutToAppear)
        valueSerializer.writeInt8((value_aboutToAppear_type).toChar())
        if ((value_aboutToAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_aboutToAppear_value  = value_aboutToAppear!
            valueSerializer.holdAndWriteCallback(value_aboutToAppear_value)
        }
        const value_aboutToDisappear  = value.aboutToDisappear
        let value_aboutToDisappear_type : int32 = RuntimeType.UNDEFINED
        value_aboutToDisappear_type = runtimeType(value_aboutToDisappear)
        valueSerializer.writeInt8((value_aboutToDisappear_type).toChar())
        if ((value_aboutToDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_aboutToDisappear_value  = value_aboutToDisappear!
            valueSerializer.holdAndWriteCallback(value_aboutToDisappear_value)
        }
        const value_layoutRegionMargin  = value.layoutRegionMargin
        let value_layoutRegionMargin_type : int32 = RuntimeType.UNDEFINED
        value_layoutRegionMargin_type = runtimeType(value_layoutRegionMargin)
        valueSerializer.writeInt8((value_layoutRegionMargin_type).toChar())
        if ((value_layoutRegionMargin_type) != (RuntimeType.UNDEFINED)) {
            const value_layoutRegionMargin_value  = value_layoutRegionMargin!
            Padding_serializer.write(valueSerializer, value_layoutRegionMargin_value)
        }
        const value_previewAnimationOptions  = value.previewAnimationOptions
        let value_previewAnimationOptions_type : int32 = RuntimeType.UNDEFINED
        value_previewAnimationOptions_type = runtimeType(value_previewAnimationOptions)
        valueSerializer.writeInt8((value_previewAnimationOptions_type).toChar())
        if ((value_previewAnimationOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_previewAnimationOptions_value  = value_previewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, value_previewAnimationOptions_value)
        }
        const value_backgroundColor  = value.backgroundColor
        let value_backgroundColor_type : int32 = RuntimeType.UNDEFINED
        value_backgroundColor_type = runtimeType(value_backgroundColor)
        valueSerializer.writeInt8((value_backgroundColor_type).toChar())
        if ((value_backgroundColor_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundColor_value  = value_backgroundColor!
            let value_backgroundColor_value_type : int32 = RuntimeType.UNDEFINED
            value_backgroundColor_value_type = runtimeType(value_backgroundColor_value)
            if (TypeChecker.isColor(value_backgroundColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_backgroundColor_value_0  = value_backgroundColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_backgroundColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_backgroundColor_value_1  = value_backgroundColor_value as number
                valueSerializer.writeNumber(value_backgroundColor_value_1)
            }
            else if (RuntimeType.STRING == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_backgroundColor_value_2  = value_backgroundColor_value as string
                valueSerializer.writeString(value_backgroundColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_backgroundColor_value_3  = value_backgroundColor_value as Resource
                Resource_serializer.write(valueSerializer, value_backgroundColor_value_3)
            }
        }
        const value_backgroundBlurStyle  = value.backgroundBlurStyle
        let value_backgroundBlurStyle_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyle_type = runtimeType(value_backgroundBlurStyle)
        valueSerializer.writeInt8((value_backgroundBlurStyle_type).toChar())
        if ((value_backgroundBlurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyle_value  = (value_backgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_backgroundBlurStyle_value))
        }
        const value_backgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        let value_backgroundBlurStyleOptions_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyleOptions_type = runtimeType(value_backgroundBlurStyleOptions)
        valueSerializer.writeInt8((value_backgroundBlurStyleOptions_type).toChar())
        if ((value_backgroundBlurStyleOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyleOptions_value  = value_backgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, value_backgroundBlurStyleOptions_value)
        }
        const value_backgroundEffect  = value.backgroundEffect
        let value_backgroundEffect_type : int32 = RuntimeType.UNDEFINED
        value_backgroundEffect_type = runtimeType(value_backgroundEffect)
        valueSerializer.writeInt8((value_backgroundEffect_type).toChar())
        if ((value_backgroundEffect_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundEffect_value  = value_backgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, value_backgroundEffect_value)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_outlineColor  = value.outlineColor
        let value_outlineColor_type : int32 = RuntimeType.UNDEFINED
        value_outlineColor_type = runtimeType(value_outlineColor)
        valueSerializer.writeInt8((value_outlineColor_type).toChar())
        if ((value_outlineColor_type) != (RuntimeType.UNDEFINED)) {
            const value_outlineColor_value  = value_outlineColor!
            let value_outlineColor_value_type : int32 = RuntimeType.UNDEFINED
            value_outlineColor_value_type = runtimeType(value_outlineColor_value)
            if ((TypeChecker.isColor(value_outlineColor_value)) || (RuntimeType.NUMBER == value_outlineColor_value_type) || (RuntimeType.STRING == value_outlineColor_value_type) || (RuntimeType.OBJECT == value_outlineColor_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_outlineColor_value_0  = value_outlineColor_value as ResourceColor
                let value_outlineColor_value_0_type : int32 = RuntimeType.UNDEFINED
                value_outlineColor_value_0_type = runtimeType(value_outlineColor_value_0)
                if (TypeChecker.isColor(value_outlineColor_value_0)) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_outlineColor_value_0_0  = value_outlineColor_value_0 as Color
                    valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_outlineColor_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_outlineColor_value_0_1  = value_outlineColor_value_0 as number
                    valueSerializer.writeNumber(value_outlineColor_value_0_1)
                }
                else if (RuntimeType.STRING == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_outlineColor_value_0_2  = value_outlineColor_value_0 as string
                    valueSerializer.writeString(value_outlineColor_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((3).toChar())
                    const value_outlineColor_value_0_3  = value_outlineColor_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_outlineColor_value_0_3)
                }
            }
            else if (TypeChecker.isEdgeColors(value_outlineColor_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_outlineColor_value_1  = value_outlineColor_value as EdgeColors
                EdgeColors_serializer.write(valueSerializer, value_outlineColor_value_1)
            }
        }
        const value_outlineWidth  = value.outlineWidth
        let value_outlineWidth_type : int32 = RuntimeType.UNDEFINED
        value_outlineWidth_type = runtimeType(value_outlineWidth)
        valueSerializer.writeInt8((value_outlineWidth_type).toChar())
        if ((value_outlineWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_outlineWidth_value  = value_outlineWidth!
            let value_outlineWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_outlineWidth_value_type = runtimeType(value_outlineWidth_value)
            if ((RuntimeType.STRING == value_outlineWidth_value_type) || (RuntimeType.NUMBER == value_outlineWidth_value_type) || (RuntimeType.OBJECT == value_outlineWidth_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_outlineWidth_value_0  = value_outlineWidth_value as Dimension
                let value_outlineWidth_value_0_type : int32 = RuntimeType.UNDEFINED
                value_outlineWidth_value_0_type = runtimeType(value_outlineWidth_value_0)
                if (RuntimeType.STRING == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_outlineWidth_value_0_0  = value_outlineWidth_value_0 as string
                    valueSerializer.writeString(value_outlineWidth_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_outlineWidth_value_0_1  = value_outlineWidth_value_0 as number
                    valueSerializer.writeNumber(value_outlineWidth_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_outlineWidth_value_0_2  = value_outlineWidth_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_outlineWidth_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeOutlineWidths(value_outlineWidth_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_outlineWidth_value_1  = value_outlineWidth_value as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, value_outlineWidth_value_1)
            }
        }
        const value_hapticFeedbackMode  = value.hapticFeedbackMode
        let value_hapticFeedbackMode_type : int32 = RuntimeType.UNDEFINED
        value_hapticFeedbackMode_type = runtimeType(value_hapticFeedbackMode)
        valueSerializer.writeInt8((value_hapticFeedbackMode_type).toChar())
        if ((value_hapticFeedbackMode_type) != (RuntimeType.UNDEFINED)) {
            const value_hapticFeedbackMode_value  = (value_hapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(TypeChecker.HapticFeedbackMode_ToNumeric(value_hapticFeedbackMode_value))
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const arrowOffset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffset_buf : Length | undefined
        if ((arrowOffset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowOffset_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowOffset_buf_ : string | number | Resource | undefined
            if (arrowOffset_buf__selector == (0).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowOffset_buf__selector == (1).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowOffset_buf__selector == (2).toChar()) {
                arrowOffset_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowOffset_buf_ has to be chosen through deserialisation.")
            }
            arrowOffset_buf = (arrowOffset_buf_ as string | number | Resource)
        }
        const arrowOffset_result : Length | undefined = arrowOffset_buf
        const preview_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let preview_buf : MenuPreviewMode | CustomBuilder | undefined
        if ((preview_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const preview_buf__selector : int32 = valueDeserializer.readInt8()
            let preview_buf_ : MenuPreviewMode | CustomBuilder | undefined
            if (preview_buf__selector == (0).toChar()) {
                preview_buf_ = TypeChecker.MenuPreviewMode_FromNumeric(valueDeserializer.readInt32())
            }
            else if (preview_buf__selector == (1).toChar()) {
                const preview_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const preview_buf__u_call : KPointer = valueDeserializer.readPointer()
                const preview_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                preview_buf_ = ():void => { 
    const preview_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    preview_buf__u_argsSerializer.writeInt32(preview_buf__u_resource.resourceId);
    preview_buf__u_argsSerializer.writePointer(preview_buf__u_call);
    preview_buf__u_argsSerializer.writePointer(preview_buf__u_callSync);
    InteropNativeModule._CallCallback(737226752, preview_buf__u_argsSerializer.asBuffer(), preview_buf__u_argsSerializer.length());
    preview_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for preview_buf_ has to be chosen through deserialisation.")
            }
            preview_buf = (preview_buf_ as MenuPreviewMode | CustomBuilder)
        }
        const preview_result : MenuPreviewMode | CustomBuilder | undefined = preview_buf
        const previewBorderRadius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewBorderRadius_buf : BorderRadiusType | undefined
        if ((previewBorderRadius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const previewBorderRadius_buf__selector : int32 = valueDeserializer.readInt8()
            let previewBorderRadius_buf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadius_buf__selector == (0).toChar()) {
                const previewBorderRadius_buf__u_selector : int32 = valueDeserializer.readInt8()
                let previewBorderRadius_buf__u : string | number | Resource | undefined
                if (previewBorderRadius_buf__u_selector == (0).toChar()) {
                    previewBorderRadius_buf__u = (valueDeserializer.readString() as string)
                }
                else if (previewBorderRadius_buf__u_selector == (1).toChar()) {
                    previewBorderRadius_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (previewBorderRadius_buf__u_selector == (2).toChar()) {
                    previewBorderRadius_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for previewBorderRadius_buf__u has to be chosen through deserialisation.")
                }
                previewBorderRadius_buf_ = (previewBorderRadius_buf__u as string | number | Resource)
            }
            else if (previewBorderRadius_buf__selector == (1).toChar()) {
                previewBorderRadius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else if (previewBorderRadius_buf__selector == (2).toChar()) {
                previewBorderRadius_buf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for previewBorderRadius_buf_ has to be chosen through deserialisation.")
            }
            previewBorderRadius_buf = (previewBorderRadius_buf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadius_result : BorderRadiusType | undefined = previewBorderRadius_buf
        const borderRadius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadius_buf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
        if ((borderRadius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderRadius_buf__selector : int32 = valueDeserializer.readInt8()
            let borderRadius_buf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadius_buf__selector == (0).toChar()) {
                const borderRadius_buf__u_selector : int32 = valueDeserializer.readInt8()
                let borderRadius_buf__u : string | number | Resource | undefined
                if (borderRadius_buf__u_selector == (0).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readString() as string)
                }
                else if (borderRadius_buf__u_selector == (1).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (borderRadius_buf__u_selector == (2).toChar()) {
                    borderRadius_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for borderRadius_buf__u has to be chosen through deserialisation.")
                }
                borderRadius_buf_ = (borderRadius_buf__u as string | number | Resource)
            }
            else if (borderRadius_buf__selector == (1).toChar()) {
                borderRadius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else if (borderRadius_buf__selector == (2).toChar()) {
                borderRadius_buf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderRadius_buf_ has to be chosen through deserialisation.")
            }
            borderRadius_buf = (borderRadius_buf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadius_result : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadius_buf
        const onAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppear_buf : (() => void) | undefined
        if ((onAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onAppear_buf = ():void => { 
    const onAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onAppear_buf__argsSerializer.writeInt32(onAppear_buf__resource.resourceId);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__call);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onAppear_buf__argsSerializer.asBuffer(), onAppear_buf__argsSerializer.length());
    onAppear_buf__argsSerializer.release();
    return; }
        }
        const onAppear_result : (() => void) | undefined = onAppear_buf
        const onDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappear_buf : (() => void) | undefined
        if ((onDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onDisappear_buf = ():void => { 
    const onDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onDisappear_buf__argsSerializer.writeInt32(onDisappear_buf__resource.resourceId);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__call);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onDisappear_buf__argsSerializer.asBuffer(), onDisappear_buf__argsSerializer.length());
    onDisappear_buf__argsSerializer.release();
    return; }
        }
        const onDisappear_result : (() => void) | undefined = onDisappear_buf
        const aboutToAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToAppear_buf : (() => void) | undefined
        if ((aboutToAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const aboutToAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const aboutToAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            aboutToAppear_buf = ():void => { 
    const aboutToAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    aboutToAppear_buf__argsSerializer.writeInt32(aboutToAppear_buf__resource.resourceId);
    aboutToAppear_buf__argsSerializer.writePointer(aboutToAppear_buf__call);
    aboutToAppear_buf__argsSerializer.writePointer(aboutToAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, aboutToAppear_buf__argsSerializer.asBuffer(), aboutToAppear_buf__argsSerializer.length());
    aboutToAppear_buf__argsSerializer.release();
    return; }
        }
        const aboutToAppear_result : (() => void) | undefined = aboutToAppear_buf
        const aboutToDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToDisappear_buf : (() => void) | undefined
        if ((aboutToDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const aboutToDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const aboutToDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            aboutToDisappear_buf = ():void => { 
    const aboutToDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    aboutToDisappear_buf__argsSerializer.writeInt32(aboutToDisappear_buf__resource.resourceId);
    aboutToDisappear_buf__argsSerializer.writePointer(aboutToDisappear_buf__call);
    aboutToDisappear_buf__argsSerializer.writePointer(aboutToDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, aboutToDisappear_buf__argsSerializer.asBuffer(), aboutToDisappear_buf__argsSerializer.length());
    aboutToDisappear_buf__argsSerializer.release();
    return; }
        }
        const aboutToDisappear_result : (() => void) | undefined = aboutToDisappear_buf
        const layoutRegionMargin_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let layoutRegionMargin_buf : Padding | undefined
        if ((layoutRegionMargin_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            layoutRegionMargin_buf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMargin_result : Padding | undefined = layoutRegionMargin_buf
        const previewAnimationOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewAnimationOptions_buf : ContextMenuAnimationOptions | undefined
        if ((previewAnimationOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            previewAnimationOptions_buf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptions_result : ContextMenuAnimationOptions | undefined = previewAnimationOptions_buf
        const backgroundColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColor_buf : ResourceColor | undefined
        if ((backgroundColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const backgroundColor_buf__selector : int32 = valueDeserializer.readInt8()
            let backgroundColor_buf_ : Color | number | string | Resource | undefined
            if (backgroundColor_buf__selector == (0).toChar()) {
                backgroundColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (backgroundColor_buf__selector == (1).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (backgroundColor_buf__selector == (2).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (backgroundColor_buf__selector == (3).toChar()) {
                backgroundColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for backgroundColor_buf_ has to be chosen through deserialisation.")
            }
            backgroundColor_buf = (backgroundColor_buf_ as Color | number | string | Resource)
        }
        const backgroundColor_result : ResourceColor | undefined = backgroundColor_buf
        const backgroundBlurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyle_buf : BlurStyle | undefined
        if ((backgroundBlurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const backgroundBlurStyle_result : BlurStyle | undefined = backgroundBlurStyle_buf
        const backgroundBlurStyleOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleOptions_buf : BackgroundBlurStyleOptions | undefined
        if ((backgroundBlurStyleOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyleOptions_buf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptions_result : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptions_buf
        const backgroundEffect_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundEffect_buf : BackgroundEffectOptions | undefined
        if ((backgroundEffect_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundEffect_buf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffect_result : BackgroundEffectOptions | undefined = backgroundEffect_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const outlineColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineColor_buf : ResourceColor | EdgeColors | undefined
        if ((outlineColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const outlineColor_buf__selector : int32 = valueDeserializer.readInt8()
            let outlineColor_buf_ : ResourceColor | EdgeColors | undefined
            if (outlineColor_buf__selector == (0).toChar()) {
                const outlineColor_buf__u_selector : int32 = valueDeserializer.readInt8()
                let outlineColor_buf__u : Color | number | string | Resource | undefined
                if (outlineColor_buf__u_selector == (0).toChar()) {
                    outlineColor_buf__u = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
                }
                else if (outlineColor_buf__u_selector == (1).toChar()) {
                    outlineColor_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (outlineColor_buf__u_selector == (2).toChar()) {
                    outlineColor_buf__u = (valueDeserializer.readString() as string)
                }
                else if (outlineColor_buf__u_selector == (3).toChar()) {
                    outlineColor_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for outlineColor_buf__u has to be chosen through deserialisation.")
                }
                outlineColor_buf_ = (outlineColor_buf__u as Color | number | string | Resource)
            }
            else if (outlineColor_buf__selector == (1).toChar()) {
                outlineColor_buf_ = EdgeColors_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for outlineColor_buf_ has to be chosen through deserialisation.")
            }
            outlineColor_buf = (outlineColor_buf_ as ResourceColor | EdgeColors)
        }
        const outlineColor_result : ResourceColor | EdgeColors | undefined = outlineColor_buf
        const outlineWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineWidth_buf : Dimension | EdgeOutlineWidths | undefined
        if ((outlineWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const outlineWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let outlineWidth_buf_ : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidth_buf__selector == (0).toChar()) {
                const outlineWidth_buf__u_selector : int32 = valueDeserializer.readInt8()
                let outlineWidth_buf__u : string | number | Resource | undefined
                if (outlineWidth_buf__u_selector == (0).toChar()) {
                    outlineWidth_buf__u = (valueDeserializer.readString() as string)
                }
                else if (outlineWidth_buf__u_selector == (1).toChar()) {
                    outlineWidth_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (outlineWidth_buf__u_selector == (2).toChar()) {
                    outlineWidth_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for outlineWidth_buf__u has to be chosen through deserialisation.")
                }
                outlineWidth_buf_ = (outlineWidth_buf__u as string | number | Resource)
            }
            else if (outlineWidth_buf__selector == (1).toChar()) {
                outlineWidth_buf_ = EdgeOutlineWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for outlineWidth_buf_ has to be chosen through deserialisation.")
            }
            outlineWidth_buf = (outlineWidth_buf_ as Dimension | EdgeOutlineWidths)
        }
        const outlineWidth_result : Dimension | EdgeOutlineWidths | undefined = outlineWidth_buf
        const hapticFeedbackMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hapticFeedbackMode_buf : HapticFeedbackMode | undefined
        if ((hapticFeedbackMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            hapticFeedbackMode_buf = TypeChecker.HapticFeedbackMode_FromNumeric(valueDeserializer.readInt32())
        }
        const hapticFeedbackMode_result : HapticFeedbackMode | undefined = hapticFeedbackMode_buf
        let value : ContextMenuOptions = ({offset: offset_result, placement: placement_result, enableArrow: enableArrow_result, arrowOffset: arrowOffset_result, preview: preview_result, previewBorderRadius: previewBorderRadius_result, borderRadius: borderRadius_result, onAppear: onAppear_result, onDisappear: onDisappear_result, aboutToAppear: aboutToAppear_result, aboutToDisappear: aboutToDisappear_result, layoutRegionMargin: layoutRegionMargin_result, previewAnimationOptions: previewAnimationOptions_result, backgroundColor: backgroundColor_result, backgroundBlurStyle: backgroundBlurStyle_result, backgroundBlurStyleOptions: backgroundBlurStyleOptions_result, backgroundEffect: backgroundEffect_result, transition: transition_result, enableHoverMode: enableHoverMode_result, outlineColor: outlineColor_result, outlineWidth: outlineWidth_result, hapticFeedbackMode: hapticFeedbackMode_result} as ContextMenuOptions)
        return value
    }
}
export class CustomPopupOptions_serializer {
    public static write(buffer: SerializerBase, value: CustomPopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_builder  = value.builder
        valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_builder))
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_popupColor  = value.popupColor
        let value_popupColor_type : int32 = RuntimeType.UNDEFINED
        value_popupColor_type = runtimeType(value_popupColor)
        valueSerializer.writeInt8((value_popupColor_type).toChar())
        if ((value_popupColor_type) != (RuntimeType.UNDEFINED)) {
            const value_popupColor_value  = value_popupColor!
            let value_popupColor_value_type : int32 = RuntimeType.UNDEFINED
            value_popupColor_value_type = runtimeType(value_popupColor_value)
            if (TypeChecker.isColor(value_popupColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_popupColor_value_0  = value_popupColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_popupColor_value_0))
            }
            else if (RuntimeType.STRING == value_popupColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_popupColor_value_1  = value_popupColor_value as string
                valueSerializer.writeString(value_popupColor_value_1)
            }
            else if (RuntimeType.OBJECT == value_popupColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_popupColor_value_2  = value_popupColor_value as Resource
                Resource_serializer.write(valueSerializer, value_popupColor_value_2)
            }
            else if (RuntimeType.NUMBER == value_popupColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_popupColor_value_3  = value_popupColor_value as number
                valueSerializer.writeNumber(value_popupColor_value_3)
            }
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_autoCancel  = value.autoCancel
        let value_autoCancel_type : int32 = RuntimeType.UNDEFINED
        value_autoCancel_type = runtimeType(value_autoCancel)
        valueSerializer.writeInt8((value_autoCancel_type).toChar())
        if ((value_autoCancel_type) != (RuntimeType.UNDEFINED)) {
            const value_autoCancel_value  = value_autoCancel!
            valueSerializer.writeBoolean(value_autoCancel_value)
        }
        const value_onStateChange  = value.onStateChange
        let value_onStateChange_type : int32 = RuntimeType.UNDEFINED
        value_onStateChange_type = runtimeType(value_onStateChange)
        valueSerializer.writeInt8((value_onStateChange_type).toChar())
        if ((value_onStateChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onStateChange_value  = value_onStateChange!
            valueSerializer.holdAndWriteCallback(value_onStateChange_value)
        }
        const value_arrowOffset  = value.arrowOffset
        let value_arrowOffset_type : int32 = RuntimeType.UNDEFINED
        value_arrowOffset_type = runtimeType(value_arrowOffset)
        valueSerializer.writeInt8((value_arrowOffset_type).toChar())
        if ((value_arrowOffset_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowOffset_value  = value_arrowOffset!
            let value_arrowOffset_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowOffset_value_type = runtimeType(value_arrowOffset_value)
            if (RuntimeType.STRING == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowOffset_value_0  = value_arrowOffset_value as string
                valueSerializer.writeString(value_arrowOffset_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowOffset_value_1  = value_arrowOffset_value as number
                valueSerializer.writeNumber(value_arrowOffset_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowOffset_value_2  = value_arrowOffset_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowOffset_value_2)
            }
        }
        const value_showInSubWindow  = value.showInSubWindow
        let value_showInSubWindow_type : int32 = RuntimeType.UNDEFINED
        value_showInSubWindow_type = runtimeType(value_showInSubWindow)
        valueSerializer.writeInt8((value_showInSubWindow_type).toChar())
        if ((value_showInSubWindow_type) != (RuntimeType.UNDEFINED)) {
            const value_showInSubWindow_value  = value_showInSubWindow!
            valueSerializer.writeBoolean(value_showInSubWindow_value)
        }
        const value_mask  = value.mask
        let value_mask_type : int32 = RuntimeType.UNDEFINED
        value_mask_type = runtimeType(value_mask)
        valueSerializer.writeInt8((value_mask_type).toChar())
        if ((value_mask_type) != (RuntimeType.UNDEFINED)) {
            const value_mask_value  = value_mask!
            let value_mask_value_type : int32 = RuntimeType.UNDEFINED
            value_mask_value_type = runtimeType(value_mask_value)
            if (RuntimeType.BOOLEAN == value_mask_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_mask_value_0  = value_mask_value as boolean
                valueSerializer.writeBoolean(value_mask_value_0)
            }
            else if (RuntimeType.OBJECT == value_mask_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_mask_value_1  = value_mask_value as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, value_mask_value_1)
            }
        }
        const value_targetSpace  = value.targetSpace
        let value_targetSpace_type : int32 = RuntimeType.UNDEFINED
        value_targetSpace_type = runtimeType(value_targetSpace)
        valueSerializer.writeInt8((value_targetSpace_type).toChar())
        if ((value_targetSpace_type) != (RuntimeType.UNDEFINED)) {
            const value_targetSpace_value  = value_targetSpace!
            let value_targetSpace_value_type : int32 = RuntimeType.UNDEFINED
            value_targetSpace_value_type = runtimeType(value_targetSpace_value)
            if (RuntimeType.STRING == value_targetSpace_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_targetSpace_value_0  = value_targetSpace_value as string
                valueSerializer.writeString(value_targetSpace_value_0)
            }
            else if (RuntimeType.NUMBER == value_targetSpace_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_targetSpace_value_1  = value_targetSpace_value as number
                valueSerializer.writeNumber(value_targetSpace_value_1)
            }
            else if (RuntimeType.OBJECT == value_targetSpace_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_targetSpace_value_2  = value_targetSpace_value as Resource
                Resource_serializer.write(valueSerializer, value_targetSpace_value_2)
            }
        }
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if (RuntimeType.STRING == value_width_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as string
                valueSerializer.writeString(value_width_value_0)
            }
            else if (RuntimeType.NUMBER == value_width_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as number
                valueSerializer.writeNumber(value_width_value_1)
            }
            else if (RuntimeType.OBJECT == value_width_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as Resource
                Resource_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_arrowPointPosition  = value.arrowPointPosition
        let value_arrowPointPosition_type : int32 = RuntimeType.UNDEFINED
        value_arrowPointPosition_type = runtimeType(value_arrowPointPosition)
        valueSerializer.writeInt8((value_arrowPointPosition_type).toChar())
        if ((value_arrowPointPosition_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowPointPosition_value  = (value_arrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(TypeChecker.ArrowPointPosition_ToNumeric(value_arrowPointPosition_value))
        }
        const value_arrowWidth  = value.arrowWidth
        let value_arrowWidth_type : int32 = RuntimeType.UNDEFINED
        value_arrowWidth_type = runtimeType(value_arrowWidth)
        valueSerializer.writeInt8((value_arrowWidth_type).toChar())
        if ((value_arrowWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowWidth_value  = value_arrowWidth!
            let value_arrowWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowWidth_value_type = runtimeType(value_arrowWidth_value)
            if (RuntimeType.STRING == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowWidth_value_0  = value_arrowWidth_value as string
                valueSerializer.writeString(value_arrowWidth_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowWidth_value_1  = value_arrowWidth_value as number
                valueSerializer.writeNumber(value_arrowWidth_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowWidth_value_2  = value_arrowWidth_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowWidth_value_2)
            }
        }
        const value_arrowHeight  = value.arrowHeight
        let value_arrowHeight_type : int32 = RuntimeType.UNDEFINED
        value_arrowHeight_type = runtimeType(value_arrowHeight)
        valueSerializer.writeInt8((value_arrowHeight_type).toChar())
        if ((value_arrowHeight_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowHeight_value  = value_arrowHeight!
            let value_arrowHeight_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowHeight_value_type = runtimeType(value_arrowHeight_value)
            if (RuntimeType.STRING == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowHeight_value_0  = value_arrowHeight_value as string
                valueSerializer.writeString(value_arrowHeight_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowHeight_value_1  = value_arrowHeight_value as number
                valueSerializer.writeNumber(value_arrowHeight_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowHeight_value_2  = value_arrowHeight_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowHeight_value_2)
            }
        }
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        valueSerializer.writeInt8((value_radius_type).toChar())
        if ((value_radius_type) != (RuntimeType.UNDEFINED)) {
            const value_radius_value  = value_radius!
            let value_radius_value_type : int32 = RuntimeType.UNDEFINED
            value_radius_value_type = runtimeType(value_radius_value)
            if (RuntimeType.STRING == value_radius_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_radius_value_0  = value_radius_value as string
                valueSerializer.writeString(value_radius_value_0)
            }
            else if (RuntimeType.NUMBER == value_radius_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_radius_value_1  = value_radius_value as number
                valueSerializer.writeNumber(value_radius_value_1)
            }
            else if (RuntimeType.OBJECT == value_radius_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_radius_value_2  = value_radius_value as Resource
                Resource_serializer.write(valueSerializer, value_radius_value_2)
            }
        }
        const value_shadow  = value.shadow
        let value_shadow_type : int32 = RuntimeType.UNDEFINED
        value_shadow_type = runtimeType(value_shadow)
        valueSerializer.writeInt8((value_shadow_type).toChar())
        if ((value_shadow_type) != (RuntimeType.UNDEFINED)) {
            const value_shadow_value  = value_shadow!
            let value_shadow_value_type : int32 = RuntimeType.UNDEFINED
            value_shadow_value_type = runtimeType(value_shadow_value)
            if (RuntimeType.OBJECT == value_shadow_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_shadow_value_0  = value_shadow_value as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, value_shadow_value_0)
            }
            else if (TypeChecker.isShadowStyle(value_shadow_value)) {
                valueSerializer.writeInt8((1).toChar())
                const value_shadow_value_1  = value_shadow_value as ShadowStyle
                valueSerializer.writeInt32(TypeChecker.ShadowStyle_ToNumeric(value_shadow_value_1))
            }
        }
        const value_backgroundBlurStyle  = value.backgroundBlurStyle
        let value_backgroundBlurStyle_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyle_type = runtimeType(value_backgroundBlurStyle)
        valueSerializer.writeInt8((value_backgroundBlurStyle_type).toChar())
        if ((value_backgroundBlurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyle_value  = (value_backgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_backgroundBlurStyle_value))
        }
        const value_focusable  = value.focusable
        let value_focusable_type : int32 = RuntimeType.UNDEFINED
        value_focusable_type = runtimeType(value_focusable)
        valueSerializer.writeInt8((value_focusable_type).toChar())
        if ((value_focusable_type) != (RuntimeType.UNDEFINED)) {
            const value_focusable_value  = value_focusable!
            valueSerializer.writeBoolean(value_focusable_value)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_onWillDismiss  = value.onWillDismiss
        let value_onWillDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillDismiss_type = runtimeType(value_onWillDismiss)
        valueSerializer.writeInt8((value_onWillDismiss_type).toChar())
        if ((value_onWillDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDismiss_value  = value_onWillDismiss!
            let value_onWillDismiss_value_type : int32 = RuntimeType.UNDEFINED
            value_onWillDismiss_value_type = runtimeType(value_onWillDismiss_value)
            if (RuntimeType.BOOLEAN == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_onWillDismiss_value_0  = value_onWillDismiss_value as boolean
                valueSerializer.writeBoolean(value_onWillDismiss_value_0)
            }
            else if (RuntimeType.FUNCTION == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_onWillDismiss_value_1  = value_onWillDismiss_value as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(value_onWillDismiss_value_1)
            }
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_followTransformOfTarget  = value.followTransformOfTarget
        let value_followTransformOfTarget_type : int32 = RuntimeType.UNDEFINED
        value_followTransformOfTarget_type = runtimeType(value_followTransformOfTarget)
        valueSerializer.writeInt8((value_followTransformOfTarget_type).toChar())
        if ((value_followTransformOfTarget_type) != (RuntimeType.UNDEFINED)) {
            const value_followTransformOfTarget_value  = value_followTransformOfTarget!
            valueSerializer.writeBoolean(value_followTransformOfTarget_value)
        }
        const value_keyboardAvoidMode  = value.keyboardAvoidMode
        let value_keyboardAvoidMode_type : int32 = RuntimeType.UNDEFINED
        value_keyboardAvoidMode_type = runtimeType(value_keyboardAvoidMode)
        valueSerializer.writeInt8((value_keyboardAvoidMode_type).toChar())
        if ((value_keyboardAvoidMode_type) != (RuntimeType.UNDEFINED)) {
            const value_keyboardAvoidMode_value  = (value_keyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(TypeChecker.KeyboardAvoidMode_ToNumeric(value_keyboardAvoidMode_value))
        }
    }
    public static read(buffer: DeserializerBase): CustomPopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const builder_buf_resource : CallbackResource = valueDeserializer.readCallbackResource()
        const builder_buf_call : KPointer = valueDeserializer.readPointer()
        const builder_buf_callSync : KPointer = valueDeserializer.readPointer()
        const builder_result : CustomBuilder = ():void => { 
    const builder_buf_argsSerializer : SerializerBase = SerializerBase.hold();
    builder_buf_argsSerializer.writeInt32(builder_buf_resource.resourceId);
    builder_buf_argsSerializer.writePointer(builder_buf_call);
    builder_buf_argsSerializer.writePointer(builder_buf_callSync);
    InteropNativeModule._CallCallback(737226752, builder_buf_argsSerializer.asBuffer(), builder_buf_argsSerializer.length());
    builder_buf_argsSerializer.release();
    return; }
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const popupColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColor_buf : Color | string | Resource | number | undefined
        if ((popupColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const popupColor_buf__selector : int32 = valueDeserializer.readInt8()
            let popupColor_buf_ : Color | string | Resource | number | undefined
            if (popupColor_buf__selector == (0).toChar()) {
                popupColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (popupColor_buf__selector == (1).toChar()) {
                popupColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (popupColor_buf__selector == (2).toChar()) {
                popupColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else if (popupColor_buf__selector == (3).toChar()) {
                popupColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else {
                throw new Error("One of the branches for popupColor_buf_ has to be chosen through deserialisation.")
            }
            popupColor_buf = (popupColor_buf_ as Color | string | Resource | number)
        }
        const popupColor_result : Color | string | Resource | number | undefined = popupColor_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const autoCancel_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancel_buf : boolean | undefined
        if ((autoCancel_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            autoCancel_buf = valueDeserializer.readBoolean()
        }
        const autoCancel_result : boolean | undefined = autoCancel_buf
        const onStateChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChange_buf : PopupStateChangeCallback | undefined
        if ((onStateChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onStateChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onStateChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onStateChange_buf = (event: PopupStateChangeParam):void => { 
    const onStateChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onStateChange_buf__argsSerializer.writeInt32(onStateChange_buf__resource.resourceId);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__call);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__callSync);
    PopupStateChangeParam_serializer.write(onStateChange_buf__argsSerializer, event);
    InteropNativeModule._CallCallback(-1444325632, onStateChange_buf__argsSerializer.asBuffer(), onStateChange_buf__argsSerializer.length());
    onStateChange_buf__argsSerializer.release();
    return; }
        }
        const onStateChange_result : PopupStateChangeCallback | undefined = onStateChange_buf
        const arrowOffset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffset_buf : Length | undefined
        if ((arrowOffset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowOffset_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowOffset_buf_ : string | number | Resource | undefined
            if (arrowOffset_buf__selector == (0).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowOffset_buf__selector == (1).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowOffset_buf__selector == (2).toChar()) {
                arrowOffset_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowOffset_buf_ has to be chosen through deserialisation.")
            }
            arrowOffset_buf = (arrowOffset_buf_ as string | number | Resource)
        }
        const arrowOffset_result : Length | undefined = arrowOffset_buf
        const showInSubWindow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindow_buf : boolean | undefined
        if ((showInSubWindow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            showInSubWindow_buf = valueDeserializer.readBoolean()
        }
        const showInSubWindow_result : boolean | undefined = showInSubWindow_buf
        const mask_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let mask_buf : boolean | PopupMaskType | undefined
        if ((mask_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const mask_buf__selector : int32 = valueDeserializer.readInt8()
            let mask_buf_ : boolean | PopupMaskType | undefined
            if (mask_buf__selector == (0).toChar()) {
                mask_buf_ = valueDeserializer.readBoolean()
            }
            else if (mask_buf__selector == (1).toChar()) {
                mask_buf_ = PopupMaskType_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for mask_buf_ has to be chosen through deserialisation.")
            }
            mask_buf = (mask_buf_ as boolean | PopupMaskType)
        }
        const mask_result : boolean | PopupMaskType | undefined = mask_buf
        const targetSpace_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpace_buf : Length | undefined
        if ((targetSpace_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const targetSpace_buf__selector : int32 = valueDeserializer.readInt8()
            let targetSpace_buf_ : string | number | Resource | undefined
            if (targetSpace_buf__selector == (0).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readString() as string)
            }
            else if (targetSpace_buf__selector == (1).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (targetSpace_buf__selector == (2).toChar()) {
                targetSpace_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for targetSpace_buf_ has to be chosen through deserialisation.")
            }
            targetSpace_buf = (targetSpace_buf_ as string | number | Resource)
        }
        const targetSpace_result : Length | undefined = targetSpace_buf
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Dimension | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : string | number | Resource | undefined
            if (width_buf__selector == (0).toChar()) {
                width_buf_ = (valueDeserializer.readString() as string)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as string | number | Resource)
        }
        const width_result : Dimension | undefined = width_buf
        const arrowPointPosition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPosition_buf : ArrowPointPosition | undefined
        if ((arrowPointPosition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            arrowPointPosition_buf = TypeChecker.ArrowPointPosition_FromNumeric(valueDeserializer.readInt32())
        }
        const arrowPointPosition_result : ArrowPointPosition | undefined = arrowPointPosition_buf
        const arrowWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidth_buf : Dimension | undefined
        if ((arrowWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowWidth_buf_ : string | number | Resource | undefined
            if (arrowWidth_buf__selector == (0).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowWidth_buf__selector == (1).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowWidth_buf__selector == (2).toChar()) {
                arrowWidth_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowWidth_buf_ has to be chosen through deserialisation.")
            }
            arrowWidth_buf = (arrowWidth_buf_ as string | number | Resource)
        }
        const arrowWidth_result : Dimension | undefined = arrowWidth_buf
        const arrowHeight_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeight_buf : Dimension | undefined
        if ((arrowHeight_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowHeight_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowHeight_buf_ : string | number | Resource | undefined
            if (arrowHeight_buf__selector == (0).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowHeight_buf__selector == (1).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowHeight_buf__selector == (2).toChar()) {
                arrowHeight_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowHeight_buf_ has to be chosen through deserialisation.")
            }
            arrowHeight_buf = (arrowHeight_buf_ as string | number | Resource)
        }
        const arrowHeight_result : Dimension | undefined = arrowHeight_buf
        const radius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radius_buf : Dimension | undefined
        if ((radius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const radius_buf__selector : int32 = valueDeserializer.readInt8()
            let radius_buf_ : string | number | Resource | undefined
            if (radius_buf__selector == (0).toChar()) {
                radius_buf_ = (valueDeserializer.readString() as string)
            }
            else if (radius_buf__selector == (1).toChar()) {
                radius_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (radius_buf__selector == (2).toChar()) {
                radius_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for radius_buf_ has to be chosen through deserialisation.")
            }
            radius_buf = (radius_buf_ as string | number | Resource)
        }
        const radius_result : Dimension | undefined = radius_buf
        const shadow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadow_buf : ShadowOptions | ShadowStyle | undefined
        if ((shadow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const shadow_buf__selector : int32 = valueDeserializer.readInt8()
            let shadow_buf_ : ShadowOptions | ShadowStyle | undefined
            if (shadow_buf__selector == (0).toChar()) {
                shadow_buf_ = ShadowOptions_serializer.read(valueDeserializer)
            }
            else if (shadow_buf__selector == (1).toChar()) {
                shadow_buf_ = TypeChecker.ShadowStyle_FromNumeric(valueDeserializer.readInt32())
            }
            else {
                throw new Error("One of the branches for shadow_buf_ has to be chosen through deserialisation.")
            }
            shadow_buf = (shadow_buf_ as ShadowOptions | ShadowStyle)
        }
        const shadow_result : ShadowOptions | ShadowStyle | undefined = shadow_buf
        const backgroundBlurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyle_buf : BlurStyle | undefined
        if ((backgroundBlurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const backgroundBlurStyle_result : BlurStyle | undefined = backgroundBlurStyle_buf
        const focusable_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let focusable_buf : boolean | undefined
        if ((focusable_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            focusable_buf = valueDeserializer.readBoolean()
        }
        const focusable_result : boolean | undefined = focusable_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const onWillDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismiss_buf : boolean | ((value0: DismissPopupAction) => void) | undefined
        if ((onWillDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDismiss_buf__selector : int32 = valueDeserializer.readInt8()
            let onWillDismiss_buf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismiss_buf__selector == (0).toChar()) {
                onWillDismiss_buf_ = valueDeserializer.readBoolean()
            }
            else if (onWillDismiss_buf__selector == (1).toChar()) {
                const onWillDismiss_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismiss_buf__u_call : KPointer = valueDeserializer.readPointer()
                const onWillDismiss_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                onWillDismiss_buf_ = (value0: DismissPopupAction):void => { 
    const onWillDismiss_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDismiss_buf__u_argsSerializer.writeInt32(onWillDismiss_buf__u_resource.resourceId);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_call);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_callSync);
    DismissPopupAction_serializer.write(onWillDismiss_buf__u_argsSerializer, value0);
    InteropNativeModule._CallCallback(-2004166751, onWillDismiss_buf__u_argsSerializer.asBuffer(), onWillDismiss_buf__u_argsSerializer.length());
    onWillDismiss_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for onWillDismiss_buf_ has to be chosen through deserialisation.")
            }
            onWillDismiss_buf = (onWillDismiss_buf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismiss_result : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismiss_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const followTransformOfTarget_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTarget_buf : boolean | undefined
        if ((followTransformOfTarget_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            followTransformOfTarget_buf = valueDeserializer.readBoolean()
        }
        const followTransformOfTarget_result : boolean | undefined = followTransformOfTarget_buf
        const keyboardAvoidMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidMode_buf : KeyboardAvoidMode | undefined
        if ((keyboardAvoidMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            keyboardAvoidMode_buf = TypeChecker.KeyboardAvoidMode_FromNumeric(valueDeserializer.readInt32())
        }
        const keyboardAvoidMode_result : KeyboardAvoidMode | undefined = keyboardAvoidMode_buf
        let value : CustomPopupOptions = ({builder: builder_result, placement: placement_result, popupColor: popupColor_result, enableArrow: enableArrow_result, autoCancel: autoCancel_result, onStateChange: onStateChange_result, arrowOffset: arrowOffset_result, showInSubWindow: showInSubWindow_result, mask: mask_result, targetSpace: targetSpace_result, offset: offset_result, width: width_result, arrowPointPosition: arrowPointPosition_result, arrowWidth: arrowWidth_result, arrowHeight: arrowHeight_result, radius: radius_result, shadow: shadow_result, backgroundBlurStyle: backgroundBlurStyle_result, focusable: focusable_result, transition: transition_result, onWillDismiss: onWillDismiss_result, enableHoverMode: enableHoverMode_result, followTransformOfTarget: followTransformOfTarget_result, keyboardAvoidMode: keyboardAvoidMode_result} as CustomPopupOptions)
        return value
    }
}
export class MenuOptions_serializer {
    public static write(buffer: SerializerBase, value: MenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_arrowOffset  = value.arrowOffset
        let value_arrowOffset_type : int32 = RuntimeType.UNDEFINED
        value_arrowOffset_type = runtimeType(value_arrowOffset)
        valueSerializer.writeInt8((value_arrowOffset_type).toChar())
        if ((value_arrowOffset_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowOffset_value  = value_arrowOffset!
            let value_arrowOffset_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowOffset_value_type = runtimeType(value_arrowOffset_value)
            if (RuntimeType.STRING == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowOffset_value_0  = value_arrowOffset_value as string
                valueSerializer.writeString(value_arrowOffset_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowOffset_value_1  = value_arrowOffset_value as number
                valueSerializer.writeNumber(value_arrowOffset_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowOffset_value_2  = value_arrowOffset_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowOffset_value_2)
            }
        }
        const value_preview  = value.preview
        let value_preview_type : int32 = RuntimeType.UNDEFINED
        value_preview_type = runtimeType(value_preview)
        valueSerializer.writeInt8((value_preview_type).toChar())
        if ((value_preview_type) != (RuntimeType.UNDEFINED)) {
            const value_preview_value  = value_preview!
            let value_preview_value_type : int32 = RuntimeType.UNDEFINED
            value_preview_value_type = runtimeType(value_preview_value)
            if (TypeChecker.isMenuPreviewMode(value_preview_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_preview_value_0  = value_preview_value as MenuPreviewMode
                valueSerializer.writeInt32(TypeChecker.MenuPreviewMode_ToNumeric(value_preview_value_0))
            }
            else if (RuntimeType.FUNCTION == value_preview_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_preview_value_1  = value_preview_value as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(value_preview_value_1))
            }
        }
        const value_previewBorderRadius  = value.previewBorderRadius
        let value_previewBorderRadius_type : int32 = RuntimeType.UNDEFINED
        value_previewBorderRadius_type = runtimeType(value_previewBorderRadius)
        valueSerializer.writeInt8((value_previewBorderRadius_type).toChar())
        if ((value_previewBorderRadius_type) != (RuntimeType.UNDEFINED)) {
            const value_previewBorderRadius_value  = value_previewBorderRadius!
            let value_previewBorderRadius_value_type : int32 = RuntimeType.UNDEFINED
            value_previewBorderRadius_value_type = runtimeType(value_previewBorderRadius_value)
            if ((RuntimeType.STRING == value_previewBorderRadius_value_type) || (RuntimeType.NUMBER == value_previewBorderRadius_value_type) || (RuntimeType.OBJECT == value_previewBorderRadius_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_previewBorderRadius_value_0  = value_previewBorderRadius_value as Length
                let value_previewBorderRadius_value_0_type : int32 = RuntimeType.UNDEFINED
                value_previewBorderRadius_value_0_type = runtimeType(value_previewBorderRadius_value_0)
                if (RuntimeType.STRING == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_previewBorderRadius_value_0_0  = value_previewBorderRadius_value_0 as string
                    valueSerializer.writeString(value_previewBorderRadius_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_previewBorderRadius_value_0_1  = value_previewBorderRadius_value_0 as number
                    valueSerializer.writeNumber(value_previewBorderRadius_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_previewBorderRadius_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_previewBorderRadius_value_0_2  = value_previewBorderRadius_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_previewBorderRadius_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_previewBorderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_previewBorderRadius_value_1  = value_previewBorderRadius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_previewBorderRadius_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_previewBorderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_previewBorderRadius_value_2  = value_previewBorderRadius_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, value_previewBorderRadius_value_2)
            }
        }
        const value_borderRadius  = value.borderRadius
        let value_borderRadius_type : int32 = RuntimeType.UNDEFINED
        value_borderRadius_type = runtimeType(value_borderRadius)
        valueSerializer.writeInt8((value_borderRadius_type).toChar())
        if ((value_borderRadius_type) != (RuntimeType.UNDEFINED)) {
            const value_borderRadius_value  = value_borderRadius!
            let value_borderRadius_value_type : int32 = RuntimeType.UNDEFINED
            value_borderRadius_value_type = runtimeType(value_borderRadius_value)
            if ((RuntimeType.STRING == value_borderRadius_value_type) || (RuntimeType.NUMBER == value_borderRadius_value_type) || (RuntimeType.OBJECT == value_borderRadius_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_borderRadius_value_0  = value_borderRadius_value as Length
                let value_borderRadius_value_0_type : int32 = RuntimeType.UNDEFINED
                value_borderRadius_value_0_type = runtimeType(value_borderRadius_value_0)
                if (RuntimeType.STRING == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_borderRadius_value_0_0  = value_borderRadius_value_0 as string
                    valueSerializer.writeString(value_borderRadius_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_borderRadius_value_0_1  = value_borderRadius_value_0 as number
                    valueSerializer.writeNumber(value_borderRadius_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_borderRadius_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_borderRadius_value_0_2  = value_borderRadius_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_borderRadius_value_0_2)
                }
            }
            else if (TypeChecker.isBorderRadiuses(value_borderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_borderRadius_value_1  = value_borderRadius_value as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, value_borderRadius_value_1)
            }
            else if (TypeChecker.isLocalizedBorderRadiuses(value_borderRadius_value, false, false, false, false)) {
                valueSerializer.writeInt8((2).toChar())
                const value_borderRadius_value_2  = value_borderRadius_value as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, value_borderRadius_value_2)
            }
        }
        const value_onAppear  = value.onAppear
        let value_onAppear_type : int32 = RuntimeType.UNDEFINED
        value_onAppear_type = runtimeType(value_onAppear)
        valueSerializer.writeInt8((value_onAppear_type).toChar())
        if ((value_onAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_onAppear_value  = value_onAppear!
            valueSerializer.holdAndWriteCallback(value_onAppear_value)
        }
        const value_onDisappear  = value.onDisappear
        let value_onDisappear_type : int32 = RuntimeType.UNDEFINED
        value_onDisappear_type = runtimeType(value_onDisappear)
        valueSerializer.writeInt8((value_onDisappear_type).toChar())
        if ((value_onDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_onDisappear_value  = value_onDisappear!
            valueSerializer.holdAndWriteCallback(value_onDisappear_value)
        }
        const value_aboutToAppear  = value.aboutToAppear
        let value_aboutToAppear_type : int32 = RuntimeType.UNDEFINED
        value_aboutToAppear_type = runtimeType(value_aboutToAppear)
        valueSerializer.writeInt8((value_aboutToAppear_type).toChar())
        if ((value_aboutToAppear_type) != (RuntimeType.UNDEFINED)) {
            const value_aboutToAppear_value  = value_aboutToAppear!
            valueSerializer.holdAndWriteCallback(value_aboutToAppear_value)
        }
        const value_aboutToDisappear  = value.aboutToDisappear
        let value_aboutToDisappear_type : int32 = RuntimeType.UNDEFINED
        value_aboutToDisappear_type = runtimeType(value_aboutToDisappear)
        valueSerializer.writeInt8((value_aboutToDisappear_type).toChar())
        if ((value_aboutToDisappear_type) != (RuntimeType.UNDEFINED)) {
            const value_aboutToDisappear_value  = value_aboutToDisappear!
            valueSerializer.holdAndWriteCallback(value_aboutToDisappear_value)
        }
        const value_layoutRegionMargin  = value.layoutRegionMargin
        let value_layoutRegionMargin_type : int32 = RuntimeType.UNDEFINED
        value_layoutRegionMargin_type = runtimeType(value_layoutRegionMargin)
        valueSerializer.writeInt8((value_layoutRegionMargin_type).toChar())
        if ((value_layoutRegionMargin_type) != (RuntimeType.UNDEFINED)) {
            const value_layoutRegionMargin_value  = value_layoutRegionMargin!
            Padding_serializer.write(valueSerializer, value_layoutRegionMargin_value)
        }
        const value_previewAnimationOptions  = value.previewAnimationOptions
        let value_previewAnimationOptions_type : int32 = RuntimeType.UNDEFINED
        value_previewAnimationOptions_type = runtimeType(value_previewAnimationOptions)
        valueSerializer.writeInt8((value_previewAnimationOptions_type).toChar())
        if ((value_previewAnimationOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_previewAnimationOptions_value  = value_previewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, value_previewAnimationOptions_value)
        }
        const value_backgroundColor  = value.backgroundColor
        let value_backgroundColor_type : int32 = RuntimeType.UNDEFINED
        value_backgroundColor_type = runtimeType(value_backgroundColor)
        valueSerializer.writeInt8((value_backgroundColor_type).toChar())
        if ((value_backgroundColor_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundColor_value  = value_backgroundColor!
            let value_backgroundColor_value_type : int32 = RuntimeType.UNDEFINED
            value_backgroundColor_value_type = runtimeType(value_backgroundColor_value)
            if (TypeChecker.isColor(value_backgroundColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_backgroundColor_value_0  = value_backgroundColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_backgroundColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_backgroundColor_value_1  = value_backgroundColor_value as number
                valueSerializer.writeNumber(value_backgroundColor_value_1)
            }
            else if (RuntimeType.STRING == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_backgroundColor_value_2  = value_backgroundColor_value as string
                valueSerializer.writeString(value_backgroundColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_backgroundColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_backgroundColor_value_3  = value_backgroundColor_value as Resource
                Resource_serializer.write(valueSerializer, value_backgroundColor_value_3)
            }
        }
        const value_backgroundBlurStyle  = value.backgroundBlurStyle
        let value_backgroundBlurStyle_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyle_type = runtimeType(value_backgroundBlurStyle)
        valueSerializer.writeInt8((value_backgroundBlurStyle_type).toChar())
        if ((value_backgroundBlurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyle_value  = (value_backgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_backgroundBlurStyle_value))
        }
        const value_backgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        let value_backgroundBlurStyleOptions_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyleOptions_type = runtimeType(value_backgroundBlurStyleOptions)
        valueSerializer.writeInt8((value_backgroundBlurStyleOptions_type).toChar())
        if ((value_backgroundBlurStyleOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyleOptions_value  = value_backgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, value_backgroundBlurStyleOptions_value)
        }
        const value_backgroundEffect  = value.backgroundEffect
        let value_backgroundEffect_type : int32 = RuntimeType.UNDEFINED
        value_backgroundEffect_type = runtimeType(value_backgroundEffect)
        valueSerializer.writeInt8((value_backgroundEffect_type).toChar())
        if ((value_backgroundEffect_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundEffect_value  = value_backgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, value_backgroundEffect_value)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_outlineColor  = value.outlineColor
        let value_outlineColor_type : int32 = RuntimeType.UNDEFINED
        value_outlineColor_type = runtimeType(value_outlineColor)
        valueSerializer.writeInt8((value_outlineColor_type).toChar())
        if ((value_outlineColor_type) != (RuntimeType.UNDEFINED)) {
            const value_outlineColor_value  = value_outlineColor!
            let value_outlineColor_value_type : int32 = RuntimeType.UNDEFINED
            value_outlineColor_value_type = runtimeType(value_outlineColor_value)
            if ((TypeChecker.isColor(value_outlineColor_value)) || (RuntimeType.NUMBER == value_outlineColor_value_type) || (RuntimeType.STRING == value_outlineColor_value_type) || (RuntimeType.OBJECT == value_outlineColor_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_outlineColor_value_0  = value_outlineColor_value as ResourceColor
                let value_outlineColor_value_0_type : int32 = RuntimeType.UNDEFINED
                value_outlineColor_value_0_type = runtimeType(value_outlineColor_value_0)
                if (TypeChecker.isColor(value_outlineColor_value_0)) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_outlineColor_value_0_0  = value_outlineColor_value_0 as Color
                    valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_outlineColor_value_0_0))
                }
                else if (RuntimeType.NUMBER == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_outlineColor_value_0_1  = value_outlineColor_value_0 as number
                    valueSerializer.writeNumber(value_outlineColor_value_0_1)
                }
                else if (RuntimeType.STRING == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_outlineColor_value_0_2  = value_outlineColor_value_0 as string
                    valueSerializer.writeString(value_outlineColor_value_0_2)
                }
                else if (RuntimeType.OBJECT == value_outlineColor_value_0_type) {
                    valueSerializer.writeInt8((3).toChar())
                    const value_outlineColor_value_0_3  = value_outlineColor_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_outlineColor_value_0_3)
                }
            }
            else if (TypeChecker.isEdgeColors(value_outlineColor_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_outlineColor_value_1  = value_outlineColor_value as EdgeColors
                EdgeColors_serializer.write(valueSerializer, value_outlineColor_value_1)
            }
        }
        const value_outlineWidth  = value.outlineWidth
        let value_outlineWidth_type : int32 = RuntimeType.UNDEFINED
        value_outlineWidth_type = runtimeType(value_outlineWidth)
        valueSerializer.writeInt8((value_outlineWidth_type).toChar())
        if ((value_outlineWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_outlineWidth_value  = value_outlineWidth!
            let value_outlineWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_outlineWidth_value_type = runtimeType(value_outlineWidth_value)
            if ((RuntimeType.STRING == value_outlineWidth_value_type) || (RuntimeType.NUMBER == value_outlineWidth_value_type) || (RuntimeType.OBJECT == value_outlineWidth_value_type)) {
                valueSerializer.writeInt8((0).toChar())
                const value_outlineWidth_value_0  = value_outlineWidth_value as Dimension
                let value_outlineWidth_value_0_type : int32 = RuntimeType.UNDEFINED
                value_outlineWidth_value_0_type = runtimeType(value_outlineWidth_value_0)
                if (RuntimeType.STRING == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((0).toChar())
                    const value_outlineWidth_value_0_0  = value_outlineWidth_value_0 as string
                    valueSerializer.writeString(value_outlineWidth_value_0_0)
                }
                else if (RuntimeType.NUMBER == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((1).toChar())
                    const value_outlineWidth_value_0_1  = value_outlineWidth_value_0 as number
                    valueSerializer.writeNumber(value_outlineWidth_value_0_1)
                }
                else if (RuntimeType.OBJECT == value_outlineWidth_value_0_type) {
                    valueSerializer.writeInt8((2).toChar())
                    const value_outlineWidth_value_0_2  = value_outlineWidth_value_0 as Resource
                    Resource_serializer.write(valueSerializer, value_outlineWidth_value_0_2)
                }
            }
            else if (TypeChecker.isEdgeOutlineWidths(value_outlineWidth_value, false, false, false, false)) {
                valueSerializer.writeInt8((1).toChar())
                const value_outlineWidth_value_1  = value_outlineWidth_value as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, value_outlineWidth_value_1)
            }
        }
        const value_hapticFeedbackMode  = value.hapticFeedbackMode
        let value_hapticFeedbackMode_type : int32 = RuntimeType.UNDEFINED
        value_hapticFeedbackMode_type = runtimeType(value_hapticFeedbackMode)
        valueSerializer.writeInt8((value_hapticFeedbackMode_type).toChar())
        if ((value_hapticFeedbackMode_type) != (RuntimeType.UNDEFINED)) {
            const value_hapticFeedbackMode_value  = (value_hapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(TypeChecker.HapticFeedbackMode_ToNumeric(value_hapticFeedbackMode_value))
        }
        const value_title  = value.title
        let value_title_type : int32 = RuntimeType.UNDEFINED
        value_title_type = runtimeType(value_title)
        valueSerializer.writeInt8((value_title_type).toChar())
        if ((value_title_type) != (RuntimeType.UNDEFINED)) {
            const value_title_value  = value_title!
            let value_title_value_type : int32 = RuntimeType.UNDEFINED
            value_title_value_type = runtimeType(value_title_value)
            if (RuntimeType.STRING == value_title_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_title_value_0  = value_title_value as string
                valueSerializer.writeString(value_title_value_0)
            }
            else if (RuntimeType.OBJECT == value_title_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_title_value_1  = value_title_value as Resource
                Resource_serializer.write(valueSerializer, value_title_value_1)
            }
        }
        const value_showInSubWindow  = value.showInSubWindow
        let value_showInSubWindow_type : int32 = RuntimeType.UNDEFINED
        value_showInSubWindow_type = runtimeType(value_showInSubWindow)
        valueSerializer.writeInt8((value_showInSubWindow_type).toChar())
        if ((value_showInSubWindow_type) != (RuntimeType.UNDEFINED)) {
            const value_showInSubWindow_value  = value_showInSubWindow!
            valueSerializer.writeBoolean(value_showInSubWindow_value)
        }
    }
    public static read(buffer: DeserializerBase): MenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const arrowOffset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffset_buf : Length | undefined
        if ((arrowOffset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowOffset_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowOffset_buf_ : string | number | Resource | undefined
            if (arrowOffset_buf__selector == (0).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowOffset_buf__selector == (1).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowOffset_buf__selector == (2).toChar()) {
                arrowOffset_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowOffset_buf_ has to be chosen through deserialisation.")
            }
            arrowOffset_buf = (arrowOffset_buf_ as string | number | Resource)
        }
        const arrowOffset_result : Length | undefined = arrowOffset_buf
        const preview_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let preview_buf : MenuPreviewMode | CustomBuilder | undefined
        if ((preview_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const preview_buf__selector : int32 = valueDeserializer.readInt8()
            let preview_buf_ : MenuPreviewMode | CustomBuilder | undefined
            if (preview_buf__selector == (0).toChar()) {
                preview_buf_ = TypeChecker.MenuPreviewMode_FromNumeric(valueDeserializer.readInt32())
            }
            else if (preview_buf__selector == (1).toChar()) {
                const preview_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const preview_buf__u_call : KPointer = valueDeserializer.readPointer()
                const preview_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                preview_buf_ = ():void => { 
    const preview_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    preview_buf__u_argsSerializer.writeInt32(preview_buf__u_resource.resourceId);
    preview_buf__u_argsSerializer.writePointer(preview_buf__u_call);
    preview_buf__u_argsSerializer.writePointer(preview_buf__u_callSync);
    InteropNativeModule._CallCallback(737226752, preview_buf__u_argsSerializer.asBuffer(), preview_buf__u_argsSerializer.length());
    preview_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for preview_buf_ has to be chosen through deserialisation.")
            }
            preview_buf = (preview_buf_ as MenuPreviewMode | CustomBuilder)
        }
        const preview_result : MenuPreviewMode | CustomBuilder | undefined = preview_buf
        const previewBorderRadius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewBorderRadius_buf : BorderRadiusType | undefined
        if ((previewBorderRadius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const previewBorderRadius_buf__selector : int32 = valueDeserializer.readInt8()
            let previewBorderRadius_buf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadius_buf__selector == (0).toChar()) {
                const previewBorderRadius_buf__u_selector : int32 = valueDeserializer.readInt8()
                let previewBorderRadius_buf__u : string | number | Resource | undefined
                if (previewBorderRadius_buf__u_selector == (0).toChar()) {
                    previewBorderRadius_buf__u = (valueDeserializer.readString() as string)
                }
                else if (previewBorderRadius_buf__u_selector == (1).toChar()) {
                    previewBorderRadius_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (previewBorderRadius_buf__u_selector == (2).toChar()) {
                    previewBorderRadius_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for previewBorderRadius_buf__u has to be chosen through deserialisation.")
                }
                previewBorderRadius_buf_ = (previewBorderRadius_buf__u as string | number | Resource)
            }
            else if (previewBorderRadius_buf__selector == (1).toChar()) {
                previewBorderRadius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else if (previewBorderRadius_buf__selector == (2).toChar()) {
                previewBorderRadius_buf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for previewBorderRadius_buf_ has to be chosen through deserialisation.")
            }
            previewBorderRadius_buf = (previewBorderRadius_buf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadius_result : BorderRadiusType | undefined = previewBorderRadius_buf
        const borderRadius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadius_buf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
        if ((borderRadius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const borderRadius_buf__selector : int32 = valueDeserializer.readInt8()
            let borderRadius_buf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadius_buf__selector == (0).toChar()) {
                const borderRadius_buf__u_selector : int32 = valueDeserializer.readInt8()
                let borderRadius_buf__u : string | number | Resource | undefined
                if (borderRadius_buf__u_selector == (0).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readString() as string)
                }
                else if (borderRadius_buf__u_selector == (1).toChar()) {
                    borderRadius_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (borderRadius_buf__u_selector == (2).toChar()) {
                    borderRadius_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for borderRadius_buf__u has to be chosen through deserialisation.")
                }
                borderRadius_buf_ = (borderRadius_buf__u as string | number | Resource)
            }
            else if (borderRadius_buf__selector == (1).toChar()) {
                borderRadius_buf_ = BorderRadiuses_serializer.read(valueDeserializer)
            }
            else if (borderRadius_buf__selector == (2).toChar()) {
                borderRadius_buf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for borderRadius_buf_ has to be chosen through deserialisation.")
            }
            borderRadius_buf = (borderRadius_buf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadius_result : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadius_buf
        const onAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppear_buf : (() => void) | undefined
        if ((onAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const onAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onAppear_buf = ():void => { 
    const onAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onAppear_buf__argsSerializer.writeInt32(onAppear_buf__resource.resourceId);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__call);
    onAppear_buf__argsSerializer.writePointer(onAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onAppear_buf__argsSerializer.asBuffer(), onAppear_buf__argsSerializer.length());
    onAppear_buf__argsSerializer.release();
    return; }
        }
        const onAppear_result : (() => void) | undefined = onAppear_buf
        const onDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappear_buf : (() => void) | undefined
        if ((onDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const onDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            onDisappear_buf = ():void => { 
    const onDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onDisappear_buf__argsSerializer.writeInt32(onDisappear_buf__resource.resourceId);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__call);
    onDisappear_buf__argsSerializer.writePointer(onDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, onDisappear_buf__argsSerializer.asBuffer(), onDisappear_buf__argsSerializer.length());
    onDisappear_buf__argsSerializer.release();
    return; }
        }
        const onDisappear_result : (() => void) | undefined = onDisappear_buf
        const aboutToAppear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToAppear_buf : (() => void) | undefined
        if ((aboutToAppear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const aboutToAppear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppear_buf__call : KPointer = valueDeserializer.readPointer()
            const aboutToAppear_buf__callSync : KPointer = valueDeserializer.readPointer()
            aboutToAppear_buf = ():void => { 
    const aboutToAppear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    aboutToAppear_buf__argsSerializer.writeInt32(aboutToAppear_buf__resource.resourceId);
    aboutToAppear_buf__argsSerializer.writePointer(aboutToAppear_buf__call);
    aboutToAppear_buf__argsSerializer.writePointer(aboutToAppear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, aboutToAppear_buf__argsSerializer.asBuffer(), aboutToAppear_buf__argsSerializer.length());
    aboutToAppear_buf__argsSerializer.release();
    return; }
        }
        const aboutToAppear_result : (() => void) | undefined = aboutToAppear_buf
        const aboutToDisappear_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToDisappear_buf : (() => void) | undefined
        if ((aboutToDisappear_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const aboutToDisappear_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappear_buf__call : KPointer = valueDeserializer.readPointer()
            const aboutToDisappear_buf__callSync : KPointer = valueDeserializer.readPointer()
            aboutToDisappear_buf = ():void => { 
    const aboutToDisappear_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    aboutToDisappear_buf__argsSerializer.writeInt32(aboutToDisappear_buf__resource.resourceId);
    aboutToDisappear_buf__argsSerializer.writePointer(aboutToDisappear_buf__call);
    aboutToDisappear_buf__argsSerializer.writePointer(aboutToDisappear_buf__callSync);
    InteropNativeModule._CallCallback(-1867723152, aboutToDisappear_buf__argsSerializer.asBuffer(), aboutToDisappear_buf__argsSerializer.length());
    aboutToDisappear_buf__argsSerializer.release();
    return; }
        }
        const aboutToDisappear_result : (() => void) | undefined = aboutToDisappear_buf
        const layoutRegionMargin_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let layoutRegionMargin_buf : Padding | undefined
        if ((layoutRegionMargin_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            layoutRegionMargin_buf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMargin_result : Padding | undefined = layoutRegionMargin_buf
        const previewAnimationOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewAnimationOptions_buf : ContextMenuAnimationOptions | undefined
        if ((previewAnimationOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            previewAnimationOptions_buf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptions_result : ContextMenuAnimationOptions | undefined = previewAnimationOptions_buf
        const backgroundColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColor_buf : ResourceColor | undefined
        if ((backgroundColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const backgroundColor_buf__selector : int32 = valueDeserializer.readInt8()
            let backgroundColor_buf_ : Color | number | string | Resource | undefined
            if (backgroundColor_buf__selector == (0).toChar()) {
                backgroundColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (backgroundColor_buf__selector == (1).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (backgroundColor_buf__selector == (2).toChar()) {
                backgroundColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (backgroundColor_buf__selector == (3).toChar()) {
                backgroundColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for backgroundColor_buf_ has to be chosen through deserialisation.")
            }
            backgroundColor_buf = (backgroundColor_buf_ as Color | number | string | Resource)
        }
        const backgroundColor_result : ResourceColor | undefined = backgroundColor_buf
        const backgroundBlurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyle_buf : BlurStyle | undefined
        if ((backgroundBlurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const backgroundBlurStyle_result : BlurStyle | undefined = backgroundBlurStyle_buf
        const backgroundBlurStyleOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleOptions_buf : BackgroundBlurStyleOptions | undefined
        if ((backgroundBlurStyleOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyleOptions_buf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptions_result : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptions_buf
        const backgroundEffect_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundEffect_buf : BackgroundEffectOptions | undefined
        if ((backgroundEffect_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundEffect_buf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffect_result : BackgroundEffectOptions | undefined = backgroundEffect_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const outlineColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineColor_buf : ResourceColor | EdgeColors | undefined
        if ((outlineColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const outlineColor_buf__selector : int32 = valueDeserializer.readInt8()
            let outlineColor_buf_ : ResourceColor | EdgeColors | undefined
            if (outlineColor_buf__selector == (0).toChar()) {
                const outlineColor_buf__u_selector : int32 = valueDeserializer.readInt8()
                let outlineColor_buf__u : Color | number | string | Resource | undefined
                if (outlineColor_buf__u_selector == (0).toChar()) {
                    outlineColor_buf__u = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
                }
                else if (outlineColor_buf__u_selector == (1).toChar()) {
                    outlineColor_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (outlineColor_buf__u_selector == (2).toChar()) {
                    outlineColor_buf__u = (valueDeserializer.readString() as string)
                }
                else if (outlineColor_buf__u_selector == (3).toChar()) {
                    outlineColor_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for outlineColor_buf__u has to be chosen through deserialisation.")
                }
                outlineColor_buf_ = (outlineColor_buf__u as Color | number | string | Resource)
            }
            else if (outlineColor_buf__selector == (1).toChar()) {
                outlineColor_buf_ = EdgeColors_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for outlineColor_buf_ has to be chosen through deserialisation.")
            }
            outlineColor_buf = (outlineColor_buf_ as ResourceColor | EdgeColors)
        }
        const outlineColor_result : ResourceColor | EdgeColors | undefined = outlineColor_buf
        const outlineWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineWidth_buf : Dimension | EdgeOutlineWidths | undefined
        if ((outlineWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const outlineWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let outlineWidth_buf_ : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidth_buf__selector == (0).toChar()) {
                const outlineWidth_buf__u_selector : int32 = valueDeserializer.readInt8()
                let outlineWidth_buf__u : string | number | Resource | undefined
                if (outlineWidth_buf__u_selector == (0).toChar()) {
                    outlineWidth_buf__u = (valueDeserializer.readString() as string)
                }
                else if (outlineWidth_buf__u_selector == (1).toChar()) {
                    outlineWidth_buf__u = (valueDeserializer.readNumber() as number)
                }
                else if (outlineWidth_buf__u_selector == (2).toChar()) {
                    outlineWidth_buf__u = Resource_serializer.read(valueDeserializer)
                }
                else {
                    throw new Error("One of the branches for outlineWidth_buf__u has to be chosen through deserialisation.")
                }
                outlineWidth_buf_ = (outlineWidth_buf__u as string | number | Resource)
            }
            else if (outlineWidth_buf__selector == (1).toChar()) {
                outlineWidth_buf_ = EdgeOutlineWidths_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for outlineWidth_buf_ has to be chosen through deserialisation.")
            }
            outlineWidth_buf = (outlineWidth_buf_ as Dimension | EdgeOutlineWidths)
        }
        const outlineWidth_result : Dimension | EdgeOutlineWidths | undefined = outlineWidth_buf
        const hapticFeedbackMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hapticFeedbackMode_buf : HapticFeedbackMode | undefined
        if ((hapticFeedbackMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            hapticFeedbackMode_buf = TypeChecker.HapticFeedbackMode_FromNumeric(valueDeserializer.readInt32())
        }
        const hapticFeedbackMode_result : HapticFeedbackMode | undefined = hapticFeedbackMode_buf
        const title_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let title_buf : ResourceStr | undefined
        if ((title_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const title_buf__selector : int32 = valueDeserializer.readInt8()
            let title_buf_ : string | Resource | undefined
            if (title_buf__selector == (0).toChar()) {
                title_buf_ = (valueDeserializer.readString() as string)
            }
            else if (title_buf__selector == (1).toChar()) {
                title_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for title_buf_ has to be chosen through deserialisation.")
            }
            title_buf = (title_buf_ as string | Resource)
        }
        const title_result : ResourceStr | undefined = title_buf
        const showInSubWindow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindow_buf : boolean | undefined
        if ((showInSubWindow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            showInSubWindow_buf = valueDeserializer.readBoolean()
        }
        const showInSubWindow_result : boolean | undefined = showInSubWindow_buf
        let value : MenuOptions = ({offset: offset_result, placement: placement_result, enableArrow: enableArrow_result, arrowOffset: arrowOffset_result, preview: preview_result, previewBorderRadius: previewBorderRadius_result, borderRadius: borderRadius_result, onAppear: onAppear_result, onDisappear: onDisappear_result, aboutToAppear: aboutToAppear_result, aboutToDisappear: aboutToDisappear_result, layoutRegionMargin: layoutRegionMargin_result, previewAnimationOptions: previewAnimationOptions_result, backgroundColor: backgroundColor_result, backgroundBlurStyle: backgroundBlurStyle_result, backgroundBlurStyleOptions: backgroundBlurStyleOptions_result, backgroundEffect: backgroundEffect_result, transition: transition_result, enableHoverMode: enableHoverMode_result, outlineColor: outlineColor_result, outlineWidth: outlineWidth_result, hapticFeedbackMode: hapticFeedbackMode_result, title: title_result, showInSubWindow: showInSubWindow_result} as MenuOptions)
        return value
    }
}
export class PopupCommonOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupCommonOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_popupColor  = value.popupColor
        let value_popupColor_type : int32 = RuntimeType.UNDEFINED
        value_popupColor_type = runtimeType(value_popupColor)
        valueSerializer.writeInt8((value_popupColor_type).toChar())
        if ((value_popupColor_type) != (RuntimeType.UNDEFINED)) {
            const value_popupColor_value  = value_popupColor!
            let value_popupColor_value_type : int32 = RuntimeType.UNDEFINED
            value_popupColor_value_type = runtimeType(value_popupColor_value)
            if (TypeChecker.isColor(value_popupColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_popupColor_value_0  = value_popupColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_popupColor_value_0))
            }
            else if (RuntimeType.NUMBER == value_popupColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_popupColor_value_1  = value_popupColor_value as number
                valueSerializer.writeNumber(value_popupColor_value_1)
            }
            else if (RuntimeType.STRING == value_popupColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_popupColor_value_2  = value_popupColor_value as string
                valueSerializer.writeString(value_popupColor_value_2)
            }
            else if (RuntimeType.OBJECT == value_popupColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_popupColor_value_3  = value_popupColor_value as Resource
                Resource_serializer.write(valueSerializer, value_popupColor_value_3)
            }
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_autoCancel  = value.autoCancel
        let value_autoCancel_type : int32 = RuntimeType.UNDEFINED
        value_autoCancel_type = runtimeType(value_autoCancel)
        valueSerializer.writeInt8((value_autoCancel_type).toChar())
        if ((value_autoCancel_type) != (RuntimeType.UNDEFINED)) {
            const value_autoCancel_value  = value_autoCancel!
            valueSerializer.writeBoolean(value_autoCancel_value)
        }
        const value_onStateChange  = value.onStateChange
        let value_onStateChange_type : int32 = RuntimeType.UNDEFINED
        value_onStateChange_type = runtimeType(value_onStateChange)
        valueSerializer.writeInt8((value_onStateChange_type).toChar())
        if ((value_onStateChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onStateChange_value  = value_onStateChange!
            valueSerializer.holdAndWriteCallback(value_onStateChange_value)
        }
        const value_arrowOffset  = value.arrowOffset
        let value_arrowOffset_type : int32 = RuntimeType.UNDEFINED
        value_arrowOffset_type = runtimeType(value_arrowOffset)
        valueSerializer.writeInt8((value_arrowOffset_type).toChar())
        if ((value_arrowOffset_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowOffset_value  = value_arrowOffset!
            let value_arrowOffset_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowOffset_value_type = runtimeType(value_arrowOffset_value)
            if (RuntimeType.STRING == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowOffset_value_0  = value_arrowOffset_value as string
                valueSerializer.writeString(value_arrowOffset_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowOffset_value_1  = value_arrowOffset_value as number
                valueSerializer.writeNumber(value_arrowOffset_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowOffset_value_2  = value_arrowOffset_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowOffset_value_2)
            }
        }
        const value_showInSubWindow  = value.showInSubWindow
        let value_showInSubWindow_type : int32 = RuntimeType.UNDEFINED
        value_showInSubWindow_type = runtimeType(value_showInSubWindow)
        valueSerializer.writeInt8((value_showInSubWindow_type).toChar())
        if ((value_showInSubWindow_type) != (RuntimeType.UNDEFINED)) {
            const value_showInSubWindow_value  = value_showInSubWindow!
            valueSerializer.writeBoolean(value_showInSubWindow_value)
        }
        const value_mask  = value.mask
        let value_mask_type : int32 = RuntimeType.UNDEFINED
        value_mask_type = runtimeType(value_mask)
        valueSerializer.writeInt8((value_mask_type).toChar())
        if ((value_mask_type) != (RuntimeType.UNDEFINED)) {
            const value_mask_value  = value_mask!
            let value_mask_value_type : int32 = RuntimeType.UNDEFINED
            value_mask_value_type = runtimeType(value_mask_value)
            if (RuntimeType.BOOLEAN == value_mask_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_mask_value_0  = value_mask_value as boolean
                valueSerializer.writeBoolean(value_mask_value_0)
            }
            else if (RuntimeType.OBJECT == value_mask_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_mask_value_1  = value_mask_value as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, value_mask_value_1)
            }
        }
        const value_targetSpace  = value.targetSpace
        let value_targetSpace_type : int32 = RuntimeType.UNDEFINED
        value_targetSpace_type = runtimeType(value_targetSpace)
        valueSerializer.writeInt8((value_targetSpace_type).toChar())
        if ((value_targetSpace_type) != (RuntimeType.UNDEFINED)) {
            const value_targetSpace_value  = value_targetSpace!
            let value_targetSpace_value_type : int32 = RuntimeType.UNDEFINED
            value_targetSpace_value_type = runtimeType(value_targetSpace_value)
            if (RuntimeType.STRING == value_targetSpace_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_targetSpace_value_0  = value_targetSpace_value as string
                valueSerializer.writeString(value_targetSpace_value_0)
            }
            else if (RuntimeType.NUMBER == value_targetSpace_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_targetSpace_value_1  = value_targetSpace_value as number
                valueSerializer.writeNumber(value_targetSpace_value_1)
            }
            else if (RuntimeType.OBJECT == value_targetSpace_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_targetSpace_value_2  = value_targetSpace_value as Resource
                Resource_serializer.write(valueSerializer, value_targetSpace_value_2)
            }
        }
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if (RuntimeType.STRING == value_width_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as string
                valueSerializer.writeString(value_width_value_0)
            }
            else if (RuntimeType.NUMBER == value_width_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as number
                valueSerializer.writeNumber(value_width_value_1)
            }
            else if (RuntimeType.OBJECT == value_width_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as Resource
                Resource_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_arrowPointPosition  = value.arrowPointPosition
        let value_arrowPointPosition_type : int32 = RuntimeType.UNDEFINED
        value_arrowPointPosition_type = runtimeType(value_arrowPointPosition)
        valueSerializer.writeInt8((value_arrowPointPosition_type).toChar())
        if ((value_arrowPointPosition_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowPointPosition_value  = (value_arrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(TypeChecker.ArrowPointPosition_ToNumeric(value_arrowPointPosition_value))
        }
        const value_arrowWidth  = value.arrowWidth
        let value_arrowWidth_type : int32 = RuntimeType.UNDEFINED
        value_arrowWidth_type = runtimeType(value_arrowWidth)
        valueSerializer.writeInt8((value_arrowWidth_type).toChar())
        if ((value_arrowWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowWidth_value  = value_arrowWidth!
            let value_arrowWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowWidth_value_type = runtimeType(value_arrowWidth_value)
            if (RuntimeType.STRING == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowWidth_value_0  = value_arrowWidth_value as string
                valueSerializer.writeString(value_arrowWidth_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowWidth_value_1  = value_arrowWidth_value as number
                valueSerializer.writeNumber(value_arrowWidth_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowWidth_value_2  = value_arrowWidth_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowWidth_value_2)
            }
        }
        const value_arrowHeight  = value.arrowHeight
        let value_arrowHeight_type : int32 = RuntimeType.UNDEFINED
        value_arrowHeight_type = runtimeType(value_arrowHeight)
        valueSerializer.writeInt8((value_arrowHeight_type).toChar())
        if ((value_arrowHeight_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowHeight_value  = value_arrowHeight!
            let value_arrowHeight_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowHeight_value_type = runtimeType(value_arrowHeight_value)
            if (RuntimeType.STRING == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowHeight_value_0  = value_arrowHeight_value as string
                valueSerializer.writeString(value_arrowHeight_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowHeight_value_1  = value_arrowHeight_value as number
                valueSerializer.writeNumber(value_arrowHeight_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowHeight_value_2  = value_arrowHeight_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowHeight_value_2)
            }
        }
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        valueSerializer.writeInt8((value_radius_type).toChar())
        if ((value_radius_type) != (RuntimeType.UNDEFINED)) {
            const value_radius_value  = value_radius!
            let value_radius_value_type : int32 = RuntimeType.UNDEFINED
            value_radius_value_type = runtimeType(value_radius_value)
            if (RuntimeType.STRING == value_radius_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_radius_value_0  = value_radius_value as string
                valueSerializer.writeString(value_radius_value_0)
            }
            else if (RuntimeType.NUMBER == value_radius_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_radius_value_1  = value_radius_value as number
                valueSerializer.writeNumber(value_radius_value_1)
            }
            else if (RuntimeType.OBJECT == value_radius_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_radius_value_2  = value_radius_value as Resource
                Resource_serializer.write(valueSerializer, value_radius_value_2)
            }
        }
        const value_shadow  = value.shadow
        let value_shadow_type : int32 = RuntimeType.UNDEFINED
        value_shadow_type = runtimeType(value_shadow)
        valueSerializer.writeInt8((value_shadow_type).toChar())
        if ((value_shadow_type) != (RuntimeType.UNDEFINED)) {
            const value_shadow_value  = value_shadow!
            let value_shadow_value_type : int32 = RuntimeType.UNDEFINED
            value_shadow_value_type = runtimeType(value_shadow_value)
            if (RuntimeType.OBJECT == value_shadow_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_shadow_value_0  = value_shadow_value as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, value_shadow_value_0)
            }
            else if (TypeChecker.isShadowStyle(value_shadow_value)) {
                valueSerializer.writeInt8((1).toChar())
                const value_shadow_value_1  = value_shadow_value as ShadowStyle
                valueSerializer.writeInt32(TypeChecker.ShadowStyle_ToNumeric(value_shadow_value_1))
            }
        }
        const value_backgroundBlurStyle  = value.backgroundBlurStyle
        let value_backgroundBlurStyle_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyle_type = runtimeType(value_backgroundBlurStyle)
        valueSerializer.writeInt8((value_backgroundBlurStyle_type).toChar())
        if ((value_backgroundBlurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyle_value  = (value_backgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_backgroundBlurStyle_value))
        }
        const value_focusable  = value.focusable
        let value_focusable_type : int32 = RuntimeType.UNDEFINED
        value_focusable_type = runtimeType(value_focusable)
        valueSerializer.writeInt8((value_focusable_type).toChar())
        if ((value_focusable_type) != (RuntimeType.UNDEFINED)) {
            const value_focusable_value  = value_focusable!
            valueSerializer.writeBoolean(value_focusable_value)
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_onWillDismiss  = value.onWillDismiss
        let value_onWillDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillDismiss_type = runtimeType(value_onWillDismiss)
        valueSerializer.writeInt8((value_onWillDismiss_type).toChar())
        if ((value_onWillDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDismiss_value  = value_onWillDismiss!
            let value_onWillDismiss_value_type : int32 = RuntimeType.UNDEFINED
            value_onWillDismiss_value_type = runtimeType(value_onWillDismiss_value)
            if (RuntimeType.BOOLEAN == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_onWillDismiss_value_0  = value_onWillDismiss_value as boolean
                valueSerializer.writeBoolean(value_onWillDismiss_value_0)
            }
            else if (RuntimeType.FUNCTION == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_onWillDismiss_value_1  = value_onWillDismiss_value as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(value_onWillDismiss_value_1)
            }
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_followTransformOfTarget  = value.followTransformOfTarget
        let value_followTransformOfTarget_type : int32 = RuntimeType.UNDEFINED
        value_followTransformOfTarget_type = runtimeType(value_followTransformOfTarget)
        valueSerializer.writeInt8((value_followTransformOfTarget_type).toChar())
        if ((value_followTransformOfTarget_type) != (RuntimeType.UNDEFINED)) {
            const value_followTransformOfTarget_value  = value_followTransformOfTarget!
            valueSerializer.writeBoolean(value_followTransformOfTarget_value)
        }
    }
    public static read(buffer: DeserializerBase): PopupCommonOptions {
        let valueDeserializer : DeserializerBase = buffer
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const popupColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColor_buf : ResourceColor | undefined
        if ((popupColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const popupColor_buf__selector : int32 = valueDeserializer.readInt8()
            let popupColor_buf_ : Color | number | string | Resource | undefined
            if (popupColor_buf__selector == (0).toChar()) {
                popupColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (popupColor_buf__selector == (1).toChar()) {
                popupColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (popupColor_buf__selector == (2).toChar()) {
                popupColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (popupColor_buf__selector == (3).toChar()) {
                popupColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for popupColor_buf_ has to be chosen through deserialisation.")
            }
            popupColor_buf = (popupColor_buf_ as Color | number | string | Resource)
        }
        const popupColor_result : ResourceColor | undefined = popupColor_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const autoCancel_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancel_buf : boolean | undefined
        if ((autoCancel_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            autoCancel_buf = valueDeserializer.readBoolean()
        }
        const autoCancel_result : boolean | undefined = autoCancel_buf
        const onStateChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChange_buf : PopupStateChangeCallback | undefined
        if ((onStateChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onStateChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onStateChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onStateChange_buf = (event: PopupStateChangeParam):void => { 
    const onStateChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onStateChange_buf__argsSerializer.writeInt32(onStateChange_buf__resource.resourceId);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__call);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__callSync);
    PopupStateChangeParam_serializer.write(onStateChange_buf__argsSerializer, event);
    InteropNativeModule._CallCallback(-1444325632, onStateChange_buf__argsSerializer.asBuffer(), onStateChange_buf__argsSerializer.length());
    onStateChange_buf__argsSerializer.release();
    return; }
        }
        const onStateChange_result : PopupStateChangeCallback | undefined = onStateChange_buf
        const arrowOffset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffset_buf : Length | undefined
        if ((arrowOffset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowOffset_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowOffset_buf_ : string | number | Resource | undefined
            if (arrowOffset_buf__selector == (0).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowOffset_buf__selector == (1).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowOffset_buf__selector == (2).toChar()) {
                arrowOffset_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowOffset_buf_ has to be chosen through deserialisation.")
            }
            arrowOffset_buf = (arrowOffset_buf_ as string | number | Resource)
        }
        const arrowOffset_result : Length | undefined = arrowOffset_buf
        const showInSubWindow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindow_buf : boolean | undefined
        if ((showInSubWindow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            showInSubWindow_buf = valueDeserializer.readBoolean()
        }
        const showInSubWindow_result : boolean | undefined = showInSubWindow_buf
        const mask_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let mask_buf : boolean | PopupMaskType | undefined
        if ((mask_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const mask_buf__selector : int32 = valueDeserializer.readInt8()
            let mask_buf_ : boolean | PopupMaskType | undefined
            if (mask_buf__selector == (0).toChar()) {
                mask_buf_ = valueDeserializer.readBoolean()
            }
            else if (mask_buf__selector == (1).toChar()) {
                mask_buf_ = PopupMaskType_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for mask_buf_ has to be chosen through deserialisation.")
            }
            mask_buf = (mask_buf_ as boolean | PopupMaskType)
        }
        const mask_result : boolean | PopupMaskType | undefined = mask_buf
        const targetSpace_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpace_buf : Length | undefined
        if ((targetSpace_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const targetSpace_buf__selector : int32 = valueDeserializer.readInt8()
            let targetSpace_buf_ : string | number | Resource | undefined
            if (targetSpace_buf__selector == (0).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readString() as string)
            }
            else if (targetSpace_buf__selector == (1).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (targetSpace_buf__selector == (2).toChar()) {
                targetSpace_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for targetSpace_buf_ has to be chosen through deserialisation.")
            }
            targetSpace_buf = (targetSpace_buf_ as string | number | Resource)
        }
        const targetSpace_result : Length | undefined = targetSpace_buf
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Dimension | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : string | number | Resource | undefined
            if (width_buf__selector == (0).toChar()) {
                width_buf_ = (valueDeserializer.readString() as string)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as string | number | Resource)
        }
        const width_result : Dimension | undefined = width_buf
        const arrowPointPosition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPosition_buf : ArrowPointPosition | undefined
        if ((arrowPointPosition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            arrowPointPosition_buf = TypeChecker.ArrowPointPosition_FromNumeric(valueDeserializer.readInt32())
        }
        const arrowPointPosition_result : ArrowPointPosition | undefined = arrowPointPosition_buf
        const arrowWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidth_buf : Dimension | undefined
        if ((arrowWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowWidth_buf_ : string | number | Resource | undefined
            if (arrowWidth_buf__selector == (0).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowWidth_buf__selector == (1).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowWidth_buf__selector == (2).toChar()) {
                arrowWidth_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowWidth_buf_ has to be chosen through deserialisation.")
            }
            arrowWidth_buf = (arrowWidth_buf_ as string | number | Resource)
        }
        const arrowWidth_result : Dimension | undefined = arrowWidth_buf
        const arrowHeight_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeight_buf : Dimension | undefined
        if ((arrowHeight_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowHeight_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowHeight_buf_ : string | number | Resource | undefined
            if (arrowHeight_buf__selector == (0).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowHeight_buf__selector == (1).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowHeight_buf__selector == (2).toChar()) {
                arrowHeight_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowHeight_buf_ has to be chosen through deserialisation.")
            }
            arrowHeight_buf = (arrowHeight_buf_ as string | number | Resource)
        }
        const arrowHeight_result : Dimension | undefined = arrowHeight_buf
        const radius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radius_buf : Dimension | undefined
        if ((radius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const radius_buf__selector : int32 = valueDeserializer.readInt8()
            let radius_buf_ : string | number | Resource | undefined
            if (radius_buf__selector == (0).toChar()) {
                radius_buf_ = (valueDeserializer.readString() as string)
            }
            else if (radius_buf__selector == (1).toChar()) {
                radius_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (radius_buf__selector == (2).toChar()) {
                radius_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for radius_buf_ has to be chosen through deserialisation.")
            }
            radius_buf = (radius_buf_ as string | number | Resource)
        }
        const radius_result : Dimension | undefined = radius_buf
        const shadow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadow_buf : ShadowOptions | ShadowStyle | undefined
        if ((shadow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const shadow_buf__selector : int32 = valueDeserializer.readInt8()
            let shadow_buf_ : ShadowOptions | ShadowStyle | undefined
            if (shadow_buf__selector == (0).toChar()) {
                shadow_buf_ = ShadowOptions_serializer.read(valueDeserializer)
            }
            else if (shadow_buf__selector == (1).toChar()) {
                shadow_buf_ = TypeChecker.ShadowStyle_FromNumeric(valueDeserializer.readInt32())
            }
            else {
                throw new Error("One of the branches for shadow_buf_ has to be chosen through deserialisation.")
            }
            shadow_buf = (shadow_buf_ as ShadowOptions | ShadowStyle)
        }
        const shadow_result : ShadowOptions | ShadowStyle | undefined = shadow_buf
        const backgroundBlurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyle_buf : BlurStyle | undefined
        if ((backgroundBlurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const backgroundBlurStyle_result : BlurStyle | undefined = backgroundBlurStyle_buf
        const focusable_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let focusable_buf : boolean | undefined
        if ((focusable_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            focusable_buf = valueDeserializer.readBoolean()
        }
        const focusable_result : boolean | undefined = focusable_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const onWillDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismiss_buf : boolean | ((value0: DismissPopupAction) => void) | undefined
        if ((onWillDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDismiss_buf__selector : int32 = valueDeserializer.readInt8()
            let onWillDismiss_buf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismiss_buf__selector == (0).toChar()) {
                onWillDismiss_buf_ = valueDeserializer.readBoolean()
            }
            else if (onWillDismiss_buf__selector == (1).toChar()) {
                const onWillDismiss_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismiss_buf__u_call : KPointer = valueDeserializer.readPointer()
                const onWillDismiss_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                onWillDismiss_buf_ = (value0: DismissPopupAction):void => { 
    const onWillDismiss_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDismiss_buf__u_argsSerializer.writeInt32(onWillDismiss_buf__u_resource.resourceId);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_call);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_callSync);
    DismissPopupAction_serializer.write(onWillDismiss_buf__u_argsSerializer, value0);
    InteropNativeModule._CallCallback(-2004166751, onWillDismiss_buf__u_argsSerializer.asBuffer(), onWillDismiss_buf__u_argsSerializer.length());
    onWillDismiss_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for onWillDismiss_buf_ has to be chosen through deserialisation.")
            }
            onWillDismiss_buf = (onWillDismiss_buf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismiss_result : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismiss_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const followTransformOfTarget_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTarget_buf : boolean | undefined
        if ((followTransformOfTarget_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            followTransformOfTarget_buf = valueDeserializer.readBoolean()
        }
        const followTransformOfTarget_result : boolean | undefined = followTransformOfTarget_buf
        let value : PopupCommonOptions = ({placement: placement_result, popupColor: popupColor_result, enableArrow: enableArrow_result, autoCancel: autoCancel_result, onStateChange: onStateChange_result, arrowOffset: arrowOffset_result, showInSubWindow: showInSubWindow_result, mask: mask_result, targetSpace: targetSpace_result, offset: offset_result, width: width_result, arrowPointPosition: arrowPointPosition_result, arrowWidth: arrowWidth_result, arrowHeight: arrowHeight_result, radius: radius_result, shadow: shadow_result, backgroundBlurStyle: backgroundBlurStyle_result, focusable: focusable_result, transition: transition_result, onWillDismiss: onWillDismiss_result, enableHoverMode: enableHoverMode_result, followTransformOfTarget: followTransformOfTarget_result} as PopupCommonOptions)
        return value
    }
}
export class PopupOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const value_message  = value.message
        valueSerializer.writeString(value_message)
        const value_placement  = value.placement
        let value_placement_type : int32 = RuntimeType.UNDEFINED
        value_placement_type = runtimeType(value_placement)
        valueSerializer.writeInt8((value_placement_type).toChar())
        if ((value_placement_type) != (RuntimeType.UNDEFINED)) {
            const value_placement_value  = (value_placement as Placement)
            valueSerializer.writeInt32(TypeChecker.Placement_ToNumeric(value_placement_value))
        }
        const value_primaryButton  = value.primaryButton
        let value_primaryButton_type : int32 = RuntimeType.UNDEFINED
        value_primaryButton_type = runtimeType(value_primaryButton)
        valueSerializer.writeInt8((value_primaryButton_type).toChar())
        if ((value_primaryButton_type) != (RuntimeType.UNDEFINED)) {
            const value_primaryButton_value  = value_primaryButton!
            PopupButton_serializer.write(valueSerializer, value_primaryButton_value)
        }
        const value_secondaryButton  = value.secondaryButton
        let value_secondaryButton_type : int32 = RuntimeType.UNDEFINED
        value_secondaryButton_type = runtimeType(value_secondaryButton)
        valueSerializer.writeInt8((value_secondaryButton_type).toChar())
        if ((value_secondaryButton_type) != (RuntimeType.UNDEFINED)) {
            const value_secondaryButton_value  = value_secondaryButton!
            PopupButton_serializer.write(valueSerializer, value_secondaryButton_value)
        }
        const value_onStateChange  = value.onStateChange
        let value_onStateChange_type : int32 = RuntimeType.UNDEFINED
        value_onStateChange_type = runtimeType(value_onStateChange)
        valueSerializer.writeInt8((value_onStateChange_type).toChar())
        if ((value_onStateChange_type) != (RuntimeType.UNDEFINED)) {
            const value_onStateChange_value  = value_onStateChange!
            valueSerializer.holdAndWriteCallback(value_onStateChange_value)
        }
        const value_arrowOffset  = value.arrowOffset
        let value_arrowOffset_type : int32 = RuntimeType.UNDEFINED
        value_arrowOffset_type = runtimeType(value_arrowOffset)
        valueSerializer.writeInt8((value_arrowOffset_type).toChar())
        if ((value_arrowOffset_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowOffset_value  = value_arrowOffset!
            let value_arrowOffset_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowOffset_value_type = runtimeType(value_arrowOffset_value)
            if (RuntimeType.STRING == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowOffset_value_0  = value_arrowOffset_value as string
                valueSerializer.writeString(value_arrowOffset_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowOffset_value_1  = value_arrowOffset_value as number
                valueSerializer.writeNumber(value_arrowOffset_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowOffset_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowOffset_value_2  = value_arrowOffset_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowOffset_value_2)
            }
        }
        const value_showInSubWindow  = value.showInSubWindow
        let value_showInSubWindow_type : int32 = RuntimeType.UNDEFINED
        value_showInSubWindow_type = runtimeType(value_showInSubWindow)
        valueSerializer.writeInt8((value_showInSubWindow_type).toChar())
        if ((value_showInSubWindow_type) != (RuntimeType.UNDEFINED)) {
            const value_showInSubWindow_value  = value_showInSubWindow!
            valueSerializer.writeBoolean(value_showInSubWindow_value)
        }
        const value_mask  = value.mask
        let value_mask_type : int32 = RuntimeType.UNDEFINED
        value_mask_type = runtimeType(value_mask)
        valueSerializer.writeInt8((value_mask_type).toChar())
        if ((value_mask_type) != (RuntimeType.UNDEFINED)) {
            const value_mask_value  = value_mask!
            let value_mask_value_type : int32 = RuntimeType.UNDEFINED
            value_mask_value_type = runtimeType(value_mask_value)
            if (RuntimeType.BOOLEAN == value_mask_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_mask_value_0  = value_mask_value as boolean
                valueSerializer.writeBoolean(value_mask_value_0)
            }
            else if (RuntimeType.OBJECT == value_mask_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_mask_value_1  = value_mask_value as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, value_mask_value_1)
            }
        }
        const value_messageOptions  = value.messageOptions
        let value_messageOptions_type : int32 = RuntimeType.UNDEFINED
        value_messageOptions_type = runtimeType(value_messageOptions)
        valueSerializer.writeInt8((value_messageOptions_type).toChar())
        if ((value_messageOptions_type) != (RuntimeType.UNDEFINED)) {
            const value_messageOptions_value  = value_messageOptions!
            PopupMessageOptions_serializer.write(valueSerializer, value_messageOptions_value)
        }
        const value_targetSpace  = value.targetSpace
        let value_targetSpace_type : int32 = RuntimeType.UNDEFINED
        value_targetSpace_type = runtimeType(value_targetSpace)
        valueSerializer.writeInt8((value_targetSpace_type).toChar())
        if ((value_targetSpace_type) != (RuntimeType.UNDEFINED)) {
            const value_targetSpace_value  = value_targetSpace!
            let value_targetSpace_value_type : int32 = RuntimeType.UNDEFINED
            value_targetSpace_value_type = runtimeType(value_targetSpace_value)
            if (RuntimeType.STRING == value_targetSpace_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_targetSpace_value_0  = value_targetSpace_value as string
                valueSerializer.writeString(value_targetSpace_value_0)
            }
            else if (RuntimeType.NUMBER == value_targetSpace_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_targetSpace_value_1  = value_targetSpace_value as number
                valueSerializer.writeNumber(value_targetSpace_value_1)
            }
            else if (RuntimeType.OBJECT == value_targetSpace_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_targetSpace_value_2  = value_targetSpace_value as Resource
                Resource_serializer.write(valueSerializer, value_targetSpace_value_2)
            }
        }
        const value_enableArrow  = value.enableArrow
        let value_enableArrow_type : int32 = RuntimeType.UNDEFINED
        value_enableArrow_type = runtimeType(value_enableArrow)
        valueSerializer.writeInt8((value_enableArrow_type).toChar())
        if ((value_enableArrow_type) != (RuntimeType.UNDEFINED)) {
            const value_enableArrow_value  = value_enableArrow!
            valueSerializer.writeBoolean(value_enableArrow_value)
        }
        const value_offset  = value.offset
        let value_offset_type : int32 = RuntimeType.UNDEFINED
        value_offset_type = runtimeType(value_offset)
        valueSerializer.writeInt8((value_offset_type).toChar())
        if ((value_offset_type) != (RuntimeType.UNDEFINED)) {
            const value_offset_value  = value_offset!
            Position_serializer.write(valueSerializer, value_offset_value)
        }
        const value_popupColor  = value.popupColor
        let value_popupColor_type : int32 = RuntimeType.UNDEFINED
        value_popupColor_type = runtimeType(value_popupColor)
        valueSerializer.writeInt8((value_popupColor_type).toChar())
        if ((value_popupColor_type) != (RuntimeType.UNDEFINED)) {
            const value_popupColor_value  = value_popupColor!
            let value_popupColor_value_type : int32 = RuntimeType.UNDEFINED
            value_popupColor_value_type = runtimeType(value_popupColor_value)
            if (TypeChecker.isColor(value_popupColor_value)) {
                valueSerializer.writeInt8((0).toChar())
                const value_popupColor_value_0  = value_popupColor_value as Color
                valueSerializer.writeInt32(TypeChecker.Color_ToNumeric(value_popupColor_value_0))
            }
            else if (RuntimeType.STRING == value_popupColor_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_popupColor_value_1  = value_popupColor_value as string
                valueSerializer.writeString(value_popupColor_value_1)
            }
            else if (RuntimeType.OBJECT == value_popupColor_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_popupColor_value_2  = value_popupColor_value as Resource
                Resource_serializer.write(valueSerializer, value_popupColor_value_2)
            }
            else if (RuntimeType.NUMBER == value_popupColor_value_type) {
                valueSerializer.writeInt8((3).toChar())
                const value_popupColor_value_3  = value_popupColor_value as number
                valueSerializer.writeNumber(value_popupColor_value_3)
            }
        }
        const value_autoCancel  = value.autoCancel
        let value_autoCancel_type : int32 = RuntimeType.UNDEFINED
        value_autoCancel_type = runtimeType(value_autoCancel)
        valueSerializer.writeInt8((value_autoCancel_type).toChar())
        if ((value_autoCancel_type) != (RuntimeType.UNDEFINED)) {
            const value_autoCancel_value  = value_autoCancel!
            valueSerializer.writeBoolean(value_autoCancel_value)
        }
        const value_width  = value.width
        let value_width_type : int32 = RuntimeType.UNDEFINED
        value_width_type = runtimeType(value_width)
        valueSerializer.writeInt8((value_width_type).toChar())
        if ((value_width_type) != (RuntimeType.UNDEFINED)) {
            const value_width_value  = value_width!
            let value_width_value_type : int32 = RuntimeType.UNDEFINED
            value_width_value_type = runtimeType(value_width_value)
            if (RuntimeType.STRING == value_width_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_width_value_0  = value_width_value as string
                valueSerializer.writeString(value_width_value_0)
            }
            else if (RuntimeType.NUMBER == value_width_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_width_value_1  = value_width_value as number
                valueSerializer.writeNumber(value_width_value_1)
            }
            else if (RuntimeType.OBJECT == value_width_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_width_value_2  = value_width_value as Resource
                Resource_serializer.write(valueSerializer, value_width_value_2)
            }
        }
        const value_arrowPointPosition  = value.arrowPointPosition
        let value_arrowPointPosition_type : int32 = RuntimeType.UNDEFINED
        value_arrowPointPosition_type = runtimeType(value_arrowPointPosition)
        valueSerializer.writeInt8((value_arrowPointPosition_type).toChar())
        if ((value_arrowPointPosition_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowPointPosition_value  = (value_arrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(TypeChecker.ArrowPointPosition_ToNumeric(value_arrowPointPosition_value))
        }
        const value_arrowWidth  = value.arrowWidth
        let value_arrowWidth_type : int32 = RuntimeType.UNDEFINED
        value_arrowWidth_type = runtimeType(value_arrowWidth)
        valueSerializer.writeInt8((value_arrowWidth_type).toChar())
        if ((value_arrowWidth_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowWidth_value  = value_arrowWidth!
            let value_arrowWidth_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowWidth_value_type = runtimeType(value_arrowWidth_value)
            if (RuntimeType.STRING == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowWidth_value_0  = value_arrowWidth_value as string
                valueSerializer.writeString(value_arrowWidth_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowWidth_value_1  = value_arrowWidth_value as number
                valueSerializer.writeNumber(value_arrowWidth_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowWidth_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowWidth_value_2  = value_arrowWidth_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowWidth_value_2)
            }
        }
        const value_arrowHeight  = value.arrowHeight
        let value_arrowHeight_type : int32 = RuntimeType.UNDEFINED
        value_arrowHeight_type = runtimeType(value_arrowHeight)
        valueSerializer.writeInt8((value_arrowHeight_type).toChar())
        if ((value_arrowHeight_type) != (RuntimeType.UNDEFINED)) {
            const value_arrowHeight_value  = value_arrowHeight!
            let value_arrowHeight_value_type : int32 = RuntimeType.UNDEFINED
            value_arrowHeight_value_type = runtimeType(value_arrowHeight_value)
            if (RuntimeType.STRING == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_arrowHeight_value_0  = value_arrowHeight_value as string
                valueSerializer.writeString(value_arrowHeight_value_0)
            }
            else if (RuntimeType.NUMBER == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_arrowHeight_value_1  = value_arrowHeight_value as number
                valueSerializer.writeNumber(value_arrowHeight_value_1)
            }
            else if (RuntimeType.OBJECT == value_arrowHeight_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_arrowHeight_value_2  = value_arrowHeight_value as Resource
                Resource_serializer.write(valueSerializer, value_arrowHeight_value_2)
            }
        }
        const value_radius  = value.radius
        let value_radius_type : int32 = RuntimeType.UNDEFINED
        value_radius_type = runtimeType(value_radius)
        valueSerializer.writeInt8((value_radius_type).toChar())
        if ((value_radius_type) != (RuntimeType.UNDEFINED)) {
            const value_radius_value  = value_radius!
            let value_radius_value_type : int32 = RuntimeType.UNDEFINED
            value_radius_value_type = runtimeType(value_radius_value)
            if (RuntimeType.STRING == value_radius_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_radius_value_0  = value_radius_value as string
                valueSerializer.writeString(value_radius_value_0)
            }
            else if (RuntimeType.NUMBER == value_radius_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_radius_value_1  = value_radius_value as number
                valueSerializer.writeNumber(value_radius_value_1)
            }
            else if (RuntimeType.OBJECT == value_radius_value_type) {
                valueSerializer.writeInt8((2).toChar())
                const value_radius_value_2  = value_radius_value as Resource
                Resource_serializer.write(valueSerializer, value_radius_value_2)
            }
        }
        const value_shadow  = value.shadow
        let value_shadow_type : int32 = RuntimeType.UNDEFINED
        value_shadow_type = runtimeType(value_shadow)
        valueSerializer.writeInt8((value_shadow_type).toChar())
        if ((value_shadow_type) != (RuntimeType.UNDEFINED)) {
            const value_shadow_value  = value_shadow!
            let value_shadow_value_type : int32 = RuntimeType.UNDEFINED
            value_shadow_value_type = runtimeType(value_shadow_value)
            if (RuntimeType.OBJECT == value_shadow_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_shadow_value_0  = value_shadow_value as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, value_shadow_value_0)
            }
            else if (TypeChecker.isShadowStyle(value_shadow_value)) {
                valueSerializer.writeInt8((1).toChar())
                const value_shadow_value_1  = value_shadow_value as ShadowStyle
                valueSerializer.writeInt32(TypeChecker.ShadowStyle_ToNumeric(value_shadow_value_1))
            }
        }
        const value_backgroundBlurStyle  = value.backgroundBlurStyle
        let value_backgroundBlurStyle_type : int32 = RuntimeType.UNDEFINED
        value_backgroundBlurStyle_type = runtimeType(value_backgroundBlurStyle)
        valueSerializer.writeInt8((value_backgroundBlurStyle_type).toChar())
        if ((value_backgroundBlurStyle_type) != (RuntimeType.UNDEFINED)) {
            const value_backgroundBlurStyle_value  = (value_backgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(TypeChecker.BlurStyle_ToNumeric(value_backgroundBlurStyle_value))
        }
        const value_transition  = value.transition
        let value_transition_type : int32 = RuntimeType.UNDEFINED
        value_transition_type = runtimeType(value_transition)
        valueSerializer.writeInt8((value_transition_type).toChar())
        if ((value_transition_type) != (RuntimeType.UNDEFINED)) {
            const value_transition_value  = value_transition!
            TransitionEffect_serializer.write(valueSerializer, value_transition_value)
        }
        const value_onWillDismiss  = value.onWillDismiss
        let value_onWillDismiss_type : int32 = RuntimeType.UNDEFINED
        value_onWillDismiss_type = runtimeType(value_onWillDismiss)
        valueSerializer.writeInt8((value_onWillDismiss_type).toChar())
        if ((value_onWillDismiss_type) != (RuntimeType.UNDEFINED)) {
            const value_onWillDismiss_value  = value_onWillDismiss!
            let value_onWillDismiss_value_type : int32 = RuntimeType.UNDEFINED
            value_onWillDismiss_value_type = runtimeType(value_onWillDismiss_value)
            if (RuntimeType.BOOLEAN == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((0).toChar())
                const value_onWillDismiss_value_0  = value_onWillDismiss_value as boolean
                valueSerializer.writeBoolean(value_onWillDismiss_value_0)
            }
            else if (RuntimeType.FUNCTION == value_onWillDismiss_value_type) {
                valueSerializer.writeInt8((1).toChar())
                const value_onWillDismiss_value_1  = value_onWillDismiss_value as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(value_onWillDismiss_value_1)
            }
        }
        const value_enableHoverMode  = value.enableHoverMode
        let value_enableHoverMode_type : int32 = RuntimeType.UNDEFINED
        value_enableHoverMode_type = runtimeType(value_enableHoverMode)
        valueSerializer.writeInt8((value_enableHoverMode_type).toChar())
        if ((value_enableHoverMode_type) != (RuntimeType.UNDEFINED)) {
            const value_enableHoverMode_value  = value_enableHoverMode!
            valueSerializer.writeBoolean(value_enableHoverMode_value)
        }
        const value_followTransformOfTarget  = value.followTransformOfTarget
        let value_followTransformOfTarget_type : int32 = RuntimeType.UNDEFINED
        value_followTransformOfTarget_type = runtimeType(value_followTransformOfTarget)
        valueSerializer.writeInt8((value_followTransformOfTarget_type).toChar())
        if ((value_followTransformOfTarget_type) != (RuntimeType.UNDEFINED)) {
            const value_followTransformOfTarget_value  = value_followTransformOfTarget!
            valueSerializer.writeBoolean(value_followTransformOfTarget_value)
        }
        const value_keyboardAvoidMode  = value.keyboardAvoidMode
        let value_keyboardAvoidMode_type : int32 = RuntimeType.UNDEFINED
        value_keyboardAvoidMode_type = runtimeType(value_keyboardAvoidMode)
        valueSerializer.writeInt8((value_keyboardAvoidMode_type).toChar())
        if ((value_keyboardAvoidMode_type) != (RuntimeType.UNDEFINED)) {
            const value_keyboardAvoidMode_value  = (value_keyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(TypeChecker.KeyboardAvoidMode_ToNumeric(value_keyboardAvoidMode_value))
        }
    }
    public static read(buffer: DeserializerBase): PopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const message_result : string = (valueDeserializer.readString() as string)
        const placement_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placement_buf : Placement | undefined
        if ((placement_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            placement_buf = TypeChecker.Placement_FromNumeric(valueDeserializer.readInt32())
        }
        const placement_result : Placement | undefined = placement_buf
        const primaryButton_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let primaryButton_buf : PopupButton | undefined
        if ((primaryButton_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            primaryButton_buf = PopupButton_serializer.read(valueDeserializer)
        }
        const primaryButton_result : PopupButton | undefined = primaryButton_buf
        const secondaryButton_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let secondaryButton_buf : PopupButton | undefined
        if ((secondaryButton_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            secondaryButton_buf = PopupButton_serializer.read(valueDeserializer)
        }
        const secondaryButton_result : PopupButton | undefined = secondaryButton_buf
        const onStateChange_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChange_buf : PopupStateChangeCallback | undefined
        if ((onStateChange_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onStateChange_buf__resource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChange_buf__call : KPointer = valueDeserializer.readPointer()
            const onStateChange_buf__callSync : KPointer = valueDeserializer.readPointer()
            onStateChange_buf = (event: PopupStateChangeParam):void => { 
    const onStateChange_buf__argsSerializer : SerializerBase = SerializerBase.hold();
    onStateChange_buf__argsSerializer.writeInt32(onStateChange_buf__resource.resourceId);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__call);
    onStateChange_buf__argsSerializer.writePointer(onStateChange_buf__callSync);
    PopupStateChangeParam_serializer.write(onStateChange_buf__argsSerializer, event);
    InteropNativeModule._CallCallback(-1444325632, onStateChange_buf__argsSerializer.asBuffer(), onStateChange_buf__argsSerializer.length());
    onStateChange_buf__argsSerializer.release();
    return; }
        }
        const onStateChange_result : PopupStateChangeCallback | undefined = onStateChange_buf
        const arrowOffset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffset_buf : Length | undefined
        if ((arrowOffset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowOffset_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowOffset_buf_ : string | number | Resource | undefined
            if (arrowOffset_buf__selector == (0).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowOffset_buf__selector == (1).toChar()) {
                arrowOffset_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowOffset_buf__selector == (2).toChar()) {
                arrowOffset_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowOffset_buf_ has to be chosen through deserialisation.")
            }
            arrowOffset_buf = (arrowOffset_buf_ as string | number | Resource)
        }
        const arrowOffset_result : Length | undefined = arrowOffset_buf
        const showInSubWindow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindow_buf : boolean | undefined
        if ((showInSubWindow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            showInSubWindow_buf = valueDeserializer.readBoolean()
        }
        const showInSubWindow_result : boolean | undefined = showInSubWindow_buf
        const mask_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let mask_buf : boolean | PopupMaskType | undefined
        if ((mask_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const mask_buf__selector : int32 = valueDeserializer.readInt8()
            let mask_buf_ : boolean | PopupMaskType | undefined
            if (mask_buf__selector == (0).toChar()) {
                mask_buf_ = valueDeserializer.readBoolean()
            }
            else if (mask_buf__selector == (1).toChar()) {
                mask_buf_ = PopupMaskType_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for mask_buf_ has to be chosen through deserialisation.")
            }
            mask_buf = (mask_buf_ as boolean | PopupMaskType)
        }
        const mask_result : boolean | PopupMaskType | undefined = mask_buf
        const messageOptions_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let messageOptions_buf : PopupMessageOptions | undefined
        if ((messageOptions_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            messageOptions_buf = PopupMessageOptions_serializer.read(valueDeserializer)
        }
        const messageOptions_result : PopupMessageOptions | undefined = messageOptions_buf
        const targetSpace_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpace_buf : Length | undefined
        if ((targetSpace_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const targetSpace_buf__selector : int32 = valueDeserializer.readInt8()
            let targetSpace_buf_ : string | number | Resource | undefined
            if (targetSpace_buf__selector == (0).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readString() as string)
            }
            else if (targetSpace_buf__selector == (1).toChar()) {
                targetSpace_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (targetSpace_buf__selector == (2).toChar()) {
                targetSpace_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for targetSpace_buf_ has to be chosen through deserialisation.")
            }
            targetSpace_buf = (targetSpace_buf_ as string | number | Resource)
        }
        const targetSpace_result : Length | undefined = targetSpace_buf
        const enableArrow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrow_buf : boolean | undefined
        if ((enableArrow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableArrow_buf = valueDeserializer.readBoolean()
        }
        const enableArrow_result : boolean | undefined = enableArrow_buf
        const offset_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offset_buf : Position | undefined
        if ((offset_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            offset_buf = Position_serializer.read(valueDeserializer)
        }
        const offset_result : Position | undefined = offset_buf
        const popupColor_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColor_buf : Color | string | Resource | number | undefined
        if ((popupColor_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const popupColor_buf__selector : int32 = valueDeserializer.readInt8()
            let popupColor_buf_ : Color | string | Resource | number | undefined
            if (popupColor_buf__selector == (0).toChar()) {
                popupColor_buf_ = TypeChecker.Color_FromNumeric(valueDeserializer.readInt32())
            }
            else if (popupColor_buf__selector == (1).toChar()) {
                popupColor_buf_ = (valueDeserializer.readString() as string)
            }
            else if (popupColor_buf__selector == (2).toChar()) {
                popupColor_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else if (popupColor_buf__selector == (3).toChar()) {
                popupColor_buf_ = (valueDeserializer.readNumber() as number)
            }
            else {
                throw new Error("One of the branches for popupColor_buf_ has to be chosen through deserialisation.")
            }
            popupColor_buf = (popupColor_buf_ as Color | string | Resource | number)
        }
        const popupColor_result : Color | string | Resource | number | undefined = popupColor_buf
        const autoCancel_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancel_buf : boolean | undefined
        if ((autoCancel_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            autoCancel_buf = valueDeserializer.readBoolean()
        }
        const autoCancel_result : boolean | undefined = autoCancel_buf
        const width_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let width_buf : Dimension | undefined
        if ((width_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const width_buf__selector : int32 = valueDeserializer.readInt8()
            let width_buf_ : string | number | Resource | undefined
            if (width_buf__selector == (0).toChar()) {
                width_buf_ = (valueDeserializer.readString() as string)
            }
            else if (width_buf__selector == (1).toChar()) {
                width_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (width_buf__selector == (2).toChar()) {
                width_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for width_buf_ has to be chosen through deserialisation.")
            }
            width_buf = (width_buf_ as string | number | Resource)
        }
        const width_result : Dimension | undefined = width_buf
        const arrowPointPosition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPosition_buf : ArrowPointPosition | undefined
        if ((arrowPointPosition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            arrowPointPosition_buf = TypeChecker.ArrowPointPosition_FromNumeric(valueDeserializer.readInt32())
        }
        const arrowPointPosition_result : ArrowPointPosition | undefined = arrowPointPosition_buf
        const arrowWidth_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidth_buf : Dimension | undefined
        if ((arrowWidth_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowWidth_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowWidth_buf_ : string | number | Resource | undefined
            if (arrowWidth_buf__selector == (0).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowWidth_buf__selector == (1).toChar()) {
                arrowWidth_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowWidth_buf__selector == (2).toChar()) {
                arrowWidth_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowWidth_buf_ has to be chosen through deserialisation.")
            }
            arrowWidth_buf = (arrowWidth_buf_ as string | number | Resource)
        }
        const arrowWidth_result : Dimension | undefined = arrowWidth_buf
        const arrowHeight_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeight_buf : Dimension | undefined
        if ((arrowHeight_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const arrowHeight_buf__selector : int32 = valueDeserializer.readInt8()
            let arrowHeight_buf_ : string | number | Resource | undefined
            if (arrowHeight_buf__selector == (0).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readString() as string)
            }
            else if (arrowHeight_buf__selector == (1).toChar()) {
                arrowHeight_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (arrowHeight_buf__selector == (2).toChar()) {
                arrowHeight_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for arrowHeight_buf_ has to be chosen through deserialisation.")
            }
            arrowHeight_buf = (arrowHeight_buf_ as string | number | Resource)
        }
        const arrowHeight_result : Dimension | undefined = arrowHeight_buf
        const radius_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radius_buf : Dimension | undefined
        if ((radius_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const radius_buf__selector : int32 = valueDeserializer.readInt8()
            let radius_buf_ : string | number | Resource | undefined
            if (radius_buf__selector == (0).toChar()) {
                radius_buf_ = (valueDeserializer.readString() as string)
            }
            else if (radius_buf__selector == (1).toChar()) {
                radius_buf_ = (valueDeserializer.readNumber() as number)
            }
            else if (radius_buf__selector == (2).toChar()) {
                radius_buf_ = Resource_serializer.read(valueDeserializer)
            }
            else {
                throw new Error("One of the branches for radius_buf_ has to be chosen through deserialisation.")
            }
            radius_buf = (radius_buf_ as string | number | Resource)
        }
        const radius_result : Dimension | undefined = radius_buf
        const shadow_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadow_buf : ShadowOptions | ShadowStyle | undefined
        if ((shadow_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const shadow_buf__selector : int32 = valueDeserializer.readInt8()
            let shadow_buf_ : ShadowOptions | ShadowStyle | undefined
            if (shadow_buf__selector == (0).toChar()) {
                shadow_buf_ = ShadowOptions_serializer.read(valueDeserializer)
            }
            else if (shadow_buf__selector == (1).toChar()) {
                shadow_buf_ = TypeChecker.ShadowStyle_FromNumeric(valueDeserializer.readInt32())
            }
            else {
                throw new Error("One of the branches for shadow_buf_ has to be chosen through deserialisation.")
            }
            shadow_buf = (shadow_buf_ as ShadowOptions | ShadowStyle)
        }
        const shadow_result : ShadowOptions | ShadowStyle | undefined = shadow_buf
        const backgroundBlurStyle_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyle_buf : BlurStyle | undefined
        if ((backgroundBlurStyle_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            backgroundBlurStyle_buf = TypeChecker.BlurStyle_FromNumeric(valueDeserializer.readInt32())
        }
        const backgroundBlurStyle_result : BlurStyle | undefined = backgroundBlurStyle_buf
        const transition_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transition_buf : TransitionEffect | undefined
        if ((transition_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            transition_buf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transition_result : TransitionEffect | undefined = transition_buf
        const onWillDismiss_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismiss_buf : boolean | ((value0: DismissPopupAction) => void) | undefined
        if ((onWillDismiss_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const onWillDismiss_buf__selector : int32 = valueDeserializer.readInt8()
            let onWillDismiss_buf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismiss_buf__selector == (0).toChar()) {
                onWillDismiss_buf_ = valueDeserializer.readBoolean()
            }
            else if (onWillDismiss_buf__selector == (1).toChar()) {
                const onWillDismiss_buf__u_resource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismiss_buf__u_call : KPointer = valueDeserializer.readPointer()
                const onWillDismiss_buf__u_callSync : KPointer = valueDeserializer.readPointer()
                onWillDismiss_buf_ = (value0: DismissPopupAction):void => { 
    const onWillDismiss_buf__u_argsSerializer : SerializerBase = SerializerBase.hold();
    onWillDismiss_buf__u_argsSerializer.writeInt32(onWillDismiss_buf__u_resource.resourceId);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_call);
    onWillDismiss_buf__u_argsSerializer.writePointer(onWillDismiss_buf__u_callSync);
    DismissPopupAction_serializer.write(onWillDismiss_buf__u_argsSerializer, value0);
    InteropNativeModule._CallCallback(-2004166751, onWillDismiss_buf__u_argsSerializer.asBuffer(), onWillDismiss_buf__u_argsSerializer.length());
    onWillDismiss_buf__u_argsSerializer.release();
    return; }
            }
            else {
                throw new Error("One of the branches for onWillDismiss_buf_ has to be chosen through deserialisation.")
            }
            onWillDismiss_buf = (onWillDismiss_buf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismiss_result : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismiss_buf
        const enableHoverMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverMode_buf : boolean | undefined
        if ((enableHoverMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            enableHoverMode_buf = valueDeserializer.readBoolean()
        }
        const enableHoverMode_result : boolean | undefined = enableHoverMode_buf
        const followTransformOfTarget_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTarget_buf : boolean | undefined
        if ((followTransformOfTarget_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            followTransformOfTarget_buf = valueDeserializer.readBoolean()
        }
        const followTransformOfTarget_result : boolean | undefined = followTransformOfTarget_buf
        const keyboardAvoidMode_buf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidMode_buf : KeyboardAvoidMode | undefined
        if ((keyboardAvoidMode_buf_runtimeType) != (RuntimeType.UNDEFINED))
        {
            keyboardAvoidMode_buf = TypeChecker.KeyboardAvoidMode_FromNumeric(valueDeserializer.readInt32())
        }
        const keyboardAvoidMode_result : KeyboardAvoidMode | undefined = keyboardAvoidMode_buf
        let value : PopupOptions = ({message: message_result, placement: placement_result, primaryButton: primaryButton_result, secondaryButton: secondaryButton_result, onStateChange: onStateChange_result, arrowOffset: arrowOffset_result, showInSubWindow: showInSubWindow_result, mask: mask_result, messageOptions: messageOptions_result, targetSpace: targetSpace_result, enableArrow: enableArrow_result, offset: offset_result, popupColor: popupColor_result, autoCancel: autoCancel_result, width: width_result, arrowPointPosition: arrowPointPosition_result, arrowWidth: arrowWidth_result, arrowHeight: arrowHeight_result, radius: radius_result, shadow: shadow_result, backgroundBlurStyle: backgroundBlurStyle_result, transition: transition_result, onWillDismiss: onWillDismiss_result, enableHoverMode: enableHoverMode_result, followTransformOfTarget: followTransformOfTarget_result, keyboardAvoidMode: keyboardAvoidMode_result} as PopupOptions)
        return value
    }
}
export class TransitionEffect_serializer {
    public static write(buffer: SerializerBase, value: TransitionEffect): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TransitionEffect {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TransitionEffectInternal.fromPtr(ptr)
    }
}
export interface AccessibilityHoverEvent {
    type: AccessibilityHoverType
    x: number
    y: number
    displayX: number
    displayY: number
    windowX: number
    windowY: number
}
export class AccessibilityHoverEventInternal extends BaseEventInternal implements MaterializedBase,AccessibilityHoverEvent {
    get type(): AccessibilityHoverType {
        return this.getType()
    }
    set type(type: AccessibilityHoverType) {
        this.setType(type)
    }
    get x(): number {
        return this.getX()
    }
    set x(x: number) {
        this.setX(x)
    }
    get y(): number {
        return this.getY()
    }
    set y(y: number) {
        this.setY(y)
    }
    get displayX(): number {
        return this.getDisplayX()
    }
    set displayX(displayX: number) {
        this.setDisplayX(displayX)
    }
    get displayY(): number {
        return this.getDisplayY()
    }
    set displayY(displayY: number) {
        this.setDisplayY(displayY)
    }
    get windowX(): number {
        return this.getWindowX()
    }
    set windowX(windowX: number) {
        this.setWindowX(windowX)
    }
    get windowY(): number {
        return this.getWindowY()
    }
    set windowY(windowY: number) {
        this.setWindowY(windowY)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(AccessibilityHoverEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AccessibilityHoverEventInternal {
        return new AccessibilityHoverEventInternal(ptr)
    }
    private getType(): AccessibilityHoverType {
        return this.getType_serialize()
    }
    private setType(type: AccessibilityHoverType): void {
        const type_casted = type as (AccessibilityHoverType)
        this.setType_serialize(type_casted)
        return
    }
    private getX(): number {
        return this.getX_serialize()
    }
    private setX(x: number): void {
        const x_casted = x as (number)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): number {
        return this.getY_serialize()
    }
    private setY(y: number): void {
        const y_casted = y as (number)
        this.setY_serialize(y_casted)
        return
    }
    private getDisplayX(): number {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: number): void {
        const displayX_casted = displayX as (number)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): number {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: number): void {
        const displayY_casted = displayY as (number)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): number {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: number): void {
        const windowX_casted = windowX as (number)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): number {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: number): void {
        const windowY_casted = windowY as (number)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getType_serialize(): AccessibilityHoverType {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getType(this.peer!.ptr)
        return TypeChecker.AccessibilityHoverType_FromNumeric(retval)
    }
    private setType_serialize(type: AccessibilityHoverType): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setType(this.peer!.ptr, TypeChecker.AccessibilityHoverType_ToNumeric(type))
    }
    private getX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setY(this.peer!.ptr, y)
    }
    private getDisplayX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: number): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowY(this.peer!.ptr, windowY)
    }
}
export interface AxisEvent {
    action: AxisAction
    displayX: number
    displayY: number
    windowX: number
    windowY: number
    x: number
    y: number
    scrollStep?: number | undefined
    propagation: (() => void)
    getHorizontalAxisValue(): number
    getVerticalAxisValue(): number
}
export class AxisEventInternal extends BaseEventInternal implements MaterializedBase,AxisEvent {
    get action(): AxisAction {
        return this.getAction()
    }
    set action(action: AxisAction) {
        this.setAction(action)
    }
    get displayX(): number {
        return this.getDisplayX()
    }
    set displayX(displayX: number) {
        this.setDisplayX(displayX)
    }
    get displayY(): number {
        return this.getDisplayY()
    }
    set displayY(displayY: number) {
        this.setDisplayY(displayY)
    }
    get windowX(): number {
        return this.getWindowX()
    }
    set windowX(windowX: number) {
        this.setWindowX(windowX)
    }
    get windowY(): number {
        return this.getWindowY()
    }
    set windowY(windowY: number) {
        this.setWindowY(windowY)
    }
    get x(): number {
        return this.getX()
    }
    set x(x: number) {
        this.setX(x)
    }
    get y(): number {
        return this.getY()
    }
    set y(y: number) {
        this.setY(y)
    }
    get scrollStep(): number | undefined {
        return this.getScrollStep()
    }
    set scrollStep(scrollStep: number | undefined) {
        const scrollStep_NonNull  = (scrollStep as number)
        this.setScrollStep(scrollStep_NonNull)
    }
    get propagation(): (() => void) {
        return this.getPropagation()
    }
    set propagation(propagation: (() => void)) {
        this.setPropagation(propagation)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(AxisEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AxisEventInternal {
        return new AxisEventInternal(ptr)
    }
    public getHorizontalAxisValue(): number {
        return this.getHorizontalAxisValue_serialize()
    }
    public getVerticalAxisValue(): number {
        return this.getVerticalAxisValue_serialize()
    }
    private getAction(): AxisAction {
        return this.getAction_serialize()
    }
    private setAction(action: AxisAction): void {
        const action_casted = action as (AxisAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): number {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: number): void {
        const displayX_casted = displayX as (number)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): number {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: number): void {
        const displayY_casted = displayY as (number)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): number {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: number): void {
        const windowX_casted = windowX as (number)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): number {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: number): void {
        const windowY_casted = windowY as (number)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): number {
        return this.getX_serialize()
    }
    private setX(x: number): void {
        const x_casted = x as (number)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): number {
        return this.getY_serialize()
    }
    private setY(y: number): void {
        const y_casted = y as (number)
        this.setY_serialize(y_casted)
        return
    }
    private getScrollStep(): number | undefined {
        return this.getScrollStep_serialize()
    }
    private setScrollStep(scrollStep: number | undefined): void {
        const scrollStep_casted = scrollStep as (number | undefined)
        this.setScrollStep_serialize(scrollStep_casted)
        return
    }
    private getPropagation(): (() => void) {
        return this.getPropagation_serialize()
    }
    private setPropagation(propagation: (() => void)): void {
        const propagation_casted = propagation as ((() => void))
        this.setPropagation_serialize(propagation_casted)
        return
    }
    private getHorizontalAxisValue_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getHorizontalAxisValue(this.peer!.ptr)
        return retval
    }
    private getVerticalAxisValue_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getVerticalAxisValue(this.peer!.ptr)
        return retval
    }
    private getAction_serialize(): AxisAction {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getAction(this.peer!.ptr)
        return TypeChecker.AxisAction_FromNumeric(retval)
    }
    private setAction_serialize(action: AxisAction): void {
        ArkUIGeneratedNativeModule._AxisEvent_setAction(this.peer!.ptr, TypeChecker.AxisAction_ToNumeric(action))
    }
    private getDisplayX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: number): void {
        ArkUIGeneratedNativeModule._AxisEvent_setY(this.peer!.ptr, y)
    }
    private getScrollStep_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getScrollStep(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setScrollStep_serialize(scrollStep: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let scrollStep_type : int32 = RuntimeType.UNDEFINED
        scrollStep_type = runtimeType(scrollStep)
        thisSerializer.writeInt8((scrollStep_type).toChar())
        if ((scrollStep_type) != (RuntimeType.UNDEFINED)) {
            const scrollStep_value  = scrollStep!
            thisSerializer.writeNumber(scrollStep_value)
        }
        ArkUIGeneratedNativeModule._AxisEvent_setScrollStep(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setPropagation_serialize(propagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(propagation)
        ArkUIGeneratedNativeModule._AxisEvent_setPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface ClickEvent {
    displayX: number
    displayY: number
    windowX: number
    windowY: number
    x: number
    y: number
    hand?: InteractionHand | undefined
    preventDefault: (() => void)
}
export class ClickEventInternal extends BaseEventInternal implements MaterializedBase,ClickEvent {
    get displayX(): number {
        return this.getDisplayX()
    }
    set displayX(displayX: number) {
        this.setDisplayX(displayX)
    }
    get displayY(): number {
        return this.getDisplayY()
    }
    set displayY(displayY: number) {
        this.setDisplayY(displayY)
    }
    get windowX(): number {
        return this.getWindowX()
    }
    set windowX(windowX: number) {
        this.setWindowX(windowX)
    }
    get windowY(): number {
        return this.getWindowY()
    }
    set windowY(windowY: number) {
        this.setWindowY(windowY)
    }
    get x(): number {
        return this.getX()
    }
    set x(x: number) {
        this.setX(x)
    }
    get y(): number {
        return this.getY()
    }
    set y(y: number) {
        this.setY(y)
    }
    get hand(): InteractionHand | undefined {
        return this.getHand()
    }
    set hand(hand: InteractionHand | undefined) {
        const hand_NonNull  = (hand as InteractionHand)
        this.setHand(hand_NonNull)
    }
    get preventDefault(): (() => void) {
        return this.getPreventDefault()
    }
    set preventDefault(preventDefault: (() => void)) {
        this.setPreventDefault(preventDefault)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(ClickEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ClickEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): ClickEventInternal {
        return new ClickEventInternal(ptr)
    }
    private getDisplayX(): number {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: number): void {
        const displayX_casted = displayX as (number)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): number {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: number): void {
        const displayY_casted = displayY as (number)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): number {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: number): void {
        const windowX_casted = windowX as (number)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): number {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: number): void {
        const windowY_casted = windowY as (number)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): number {
        return this.getX_serialize()
    }
    private setX(x: number): void {
        const x_casted = x as (number)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): number {
        return this.getY_serialize()
    }
    private setY(y: number): void {
        const y_casted = y as (number)
        this.setY_serialize(y_casted)
        return
    }
    private getHand(): InteractionHand | undefined {
        return this.getHand_serialize()
    }
    private setHand(hand: InteractionHand | undefined): void {
        const hand_casted = hand as (InteractionHand | undefined)
        this.setHand_serialize(hand_casted)
        return
    }
    private getPreventDefault(): (() => void) {
        return this.getPreventDefault_serialize()
    }
    private setPreventDefault(preventDefault: (() => void)): void {
        const preventDefault_casted = preventDefault as ((() => void))
        this.setPreventDefault_serialize(preventDefault_casted)
        return
    }
    private getDisplayX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: number): void {
        ArkUIGeneratedNativeModule._ClickEvent_setY(this.peer!.ptr, y)
    }
    private getHand_serialize(): InteractionHand | undefined {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getHand(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : InteractionHand | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = TypeChecker.InteractionHand_FromNumeric(retvalDeserializer.readInt32())
        }
        const returnResult : InteractionHand | undefined = buffer
        return returnResult
    }
    private setHand_serialize(hand: InteractionHand | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let hand_type : int32 = RuntimeType.UNDEFINED
        hand_type = runtimeType(hand)
        thisSerializer.writeInt8((hand_type).toChar())
        if ((hand_type) != (RuntimeType.UNDEFINED)) {
            const hand_value  = (hand as InteractionHand)
            thisSerializer.writeInt32(TypeChecker.InteractionHand_ToNumeric(hand_value))
        }
        ArkUIGeneratedNativeModule._ClickEvent_setHand(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPreventDefault_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getPreventDefault(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setPreventDefault_serialize(preventDefault: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(preventDefault)
        ArkUIGeneratedNativeModule._ClickEvent_setPreventDefault(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface FocusAxisEvent {
    axisMap: Map<AxisModel, number>
    stopPropagation: (() => void)
}
export class FocusAxisEventInternal extends BaseEventInternal implements MaterializedBase,FocusAxisEvent {
    get axisMap(): Map<AxisModel, number> {
        return this.getAxisMap()
    }
    set axisMap(axisMap: Map<AxisModel, number>) {
        this.setAxisMap(axisMap)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(FocusAxisEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._FocusAxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): FocusAxisEventInternal {
        return new FocusAxisEventInternal(ptr)
    }
    private getAxisMap(): Map<AxisModel, number> {
        return this.getAxisMap_serialize()
    }
    private setAxisMap(axisMap: Map<AxisModel, number>): void {
        const axisMap_casted = axisMap as (Map<AxisModel, number>)
        this.setAxisMap_serialize(axisMap_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getAxisMap_serialize(): Map<AxisModel, number> {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_getAxisMap(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_size : int32 = retvalDeserializer.readInt32()
        let buffer : Map<AxisModel, number> = new Map<AxisModel, number>()
        // TODO: TS map resize
        for (let buffer_i = 0; buffer_i < buffer_size; buffer_i++) {
            const buffer_key : AxisModel = TypeChecker.AxisModel_FromNumeric(retvalDeserializer.readInt32())
            const buffer_value : number = (retvalDeserializer.readNumber() as number)
            buffer.set(buffer_key, buffer_value)
        }
        const returnResult : Map<AxisModel, number> = buffer
        return returnResult
    }
    private setAxisMap_serialize(axisMap: Map<AxisModel, number>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((axisMap.size).toInt())
        for (const pair of axisMap) {
            const axisMap_key = pair[0]
            const axisMap_value = pair[1]
            thisSerializer.writeInt32(TypeChecker.AxisModel_ToNumeric(axisMap_key))
            thisSerializer.writeNumber(axisMap_value)
        }
        ArkUIGeneratedNativeModule._FocusAxisEvent_setAxisMap(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_getStopPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._FocusAxisEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface HoverEvent {
    x?: number | undefined
    y?: number | undefined
    windowX?: number | undefined
    windowY?: number | undefined
    displayX?: number | undefined
    displayY?: number | undefined
    stopPropagation: (() => void)
}
export class HoverEventInternal extends BaseEventInternal implements MaterializedBase,HoverEvent {
    get x(): number | undefined {
        return this.getX()
    }
    set x(x: number | undefined) {
        const x_NonNull  = (x as number)
        this.setX(x_NonNull)
    }
    get y(): number | undefined {
        return this.getY()
    }
    set y(y: number | undefined) {
        const y_NonNull  = (y as number)
        this.setY(y_NonNull)
    }
    get windowX(): number | undefined {
        return this.getWindowX()
    }
    set windowX(windowX: number | undefined) {
        const windowX_NonNull  = (windowX as number)
        this.setWindowX(windowX_NonNull)
    }
    get windowY(): number | undefined {
        return this.getWindowY()
    }
    set windowY(windowY: number | undefined) {
        const windowY_NonNull  = (windowY as number)
        this.setWindowY(windowY_NonNull)
    }
    get displayX(): number | undefined {
        return this.getDisplayX()
    }
    set displayX(displayX: number | undefined) {
        const displayX_NonNull  = (displayX as number)
        this.setDisplayX(displayX_NonNull)
    }
    get displayY(): number | undefined {
        return this.getDisplayY()
    }
    set displayY(displayY: number | undefined) {
        const displayY_NonNull  = (displayY as number)
        this.setDisplayY(displayY_NonNull)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(HoverEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._HoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): HoverEventInternal {
        return new HoverEventInternal(ptr)
    }
    private getX(): number | undefined {
        return this.getX_serialize()
    }
    private setX(x: number | undefined): void {
        const x_casted = x as (number | undefined)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): number | undefined {
        return this.getY_serialize()
    }
    private setY(y: number | undefined): void {
        const y_casted = y as (number | undefined)
        this.setY_serialize(y_casted)
        return
    }
    private getWindowX(): number | undefined {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: number | undefined): void {
        const windowX_casted = windowX as (number | undefined)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): number | undefined {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: number | undefined): void {
        const windowY_casted = windowY as (number | undefined)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getDisplayX(): number | undefined {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: number | undefined): void {
        const displayX_casted = displayX as (number | undefined)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): number | undefined {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: number | undefined): void {
        const displayY_casted = displayY as (number | undefined)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getX_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setX_serialize(x: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let x_type : int32 = RuntimeType.UNDEFINED
        x_type = runtimeType(x)
        thisSerializer.writeInt8((x_type).toChar())
        if ((x_type) != (RuntimeType.UNDEFINED)) {
            const x_value  = x!
            thisSerializer.writeNumber(x_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getY_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setY_serialize(y: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let y_type : int32 = RuntimeType.UNDEFINED
        y_type = runtimeType(y)
        thisSerializer.writeInt8((y_type).toChar())
        if ((y_type) != (RuntimeType.UNDEFINED)) {
            const y_value  = y!
            thisSerializer.writeNumber(y_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowX_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setWindowX_serialize(windowX: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let windowX_type : int32 = RuntimeType.UNDEFINED
        windowX_type = runtimeType(windowX)
        thisSerializer.writeInt8((windowX_type).toChar())
        if ((windowX_type) != (RuntimeType.UNDEFINED)) {
            const windowX_value  = windowX!
            thisSerializer.writeNumber(windowX_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowY_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setWindowY_serialize(windowY: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let windowY_type : int32 = RuntimeType.UNDEFINED
        windowY_type = runtimeType(windowY)
        thisSerializer.writeInt8((windowY_type).toChar())
        if ((windowY_type) != (RuntimeType.UNDEFINED)) {
            const windowY_value  = windowY!
            thisSerializer.writeNumber(windowY_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayX_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setDisplayX_serialize(displayX: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let displayX_type : int32 = RuntimeType.UNDEFINED
        displayX_type = runtimeType(displayX)
        thisSerializer.writeInt8((displayX_type).toChar())
        if ((displayX_type) != (RuntimeType.UNDEFINED)) {
            const displayX_value  = displayX!
            thisSerializer.writeNumber(displayX_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayY_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setDisplayY_serialize(displayY: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let displayY_type : int32 = RuntimeType.UNDEFINED
        displayY_type = runtimeType(displayY)
        thisSerializer.writeInt8((displayY_type).toChar())
        if ((displayY_type) != (RuntimeType.UNDEFINED)) {
            const displayY_value  = displayY!
            thisSerializer.writeNumber(displayY_value)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getStopPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._HoverEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface MouseEvent {
    button: MouseButton
    action: MouseAction
    displayX: number
    displayY: number
    windowX: number
    windowY: number
    x: number
    y: number
    stopPropagation: (() => void)
    rawDeltaX?: number | undefined
    rawDeltaY?: number | undefined
    pressedButtons?: Array<MouseButton> | undefined
}
export class MouseEventInternal extends BaseEventInternal implements MaterializedBase,MouseEvent {
    get button(): MouseButton {
        return this.getButton()
    }
    set button(button: MouseButton) {
        this.setButton(button)
    }
    get action(): MouseAction {
        return this.getAction()
    }
    set action(action: MouseAction) {
        this.setAction(action)
    }
    get displayX(): number {
        return this.getDisplayX()
    }
    set displayX(displayX: number) {
        this.setDisplayX(displayX)
    }
    get displayY(): number {
        return this.getDisplayY()
    }
    set displayY(displayY: number) {
        this.setDisplayY(displayY)
    }
    get windowX(): number {
        return this.getWindowX()
    }
    set windowX(windowX: number) {
        this.setWindowX(windowX)
    }
    get windowY(): number {
        return this.getWindowY()
    }
    set windowY(windowY: number) {
        this.setWindowY(windowY)
    }
    get x(): number {
        return this.getX()
    }
    set x(x: number) {
        this.setX(x)
    }
    get y(): number {
        return this.getY()
    }
    set y(y: number) {
        this.setY(y)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    get rawDeltaX(): number | undefined {
        return this.getRawDeltaX()
    }
    set rawDeltaX(rawDeltaX: number | undefined) {
        const rawDeltaX_NonNull  = (rawDeltaX as number)
        this.setRawDeltaX(rawDeltaX_NonNull)
    }
    get rawDeltaY(): number | undefined {
        return this.getRawDeltaY()
    }
    set rawDeltaY(rawDeltaY: number | undefined) {
        const rawDeltaY_NonNull  = (rawDeltaY as number)
        this.setRawDeltaY(rawDeltaY_NonNull)
    }
    get pressedButtons(): Array<MouseButton> | undefined {
        return this.getPressedButtons()
    }
    set pressedButtons(pressedButtons: Array<MouseButton> | undefined) {
        const pressedButtons_NonNull  = (pressedButtons as Array<MouseButton>)
        this.setPressedButtons(pressedButtons_NonNull)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(MouseEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._MouseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MouseEventInternal {
        return new MouseEventInternal(ptr)
    }
    private getButton(): MouseButton {
        return this.getButton_serialize()
    }
    private setButton(button: MouseButton): void {
        const button_casted = button as (MouseButton)
        this.setButton_serialize(button_casted)
        return
    }
    private getAction(): MouseAction {
        return this.getAction_serialize()
    }
    private setAction(action: MouseAction): void {
        const action_casted = action as (MouseAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): number {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: number): void {
        const displayX_casted = displayX as (number)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): number {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: number): void {
        const displayY_casted = displayY as (number)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): number {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: number): void {
        const windowX_casted = windowX as (number)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): number {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: number): void {
        const windowY_casted = windowY as (number)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): number {
        return this.getX_serialize()
    }
    private setX(x: number): void {
        const x_casted = x as (number)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): number {
        return this.getY_serialize()
    }
    private setY(y: number): void {
        const y_casted = y as (number)
        this.setY_serialize(y_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getRawDeltaX(): number | undefined {
        return this.getRawDeltaX_serialize()
    }
    private setRawDeltaX(rawDeltaX: number | undefined): void {
        const rawDeltaX_casted = rawDeltaX as (number | undefined)
        this.setRawDeltaX_serialize(rawDeltaX_casted)
        return
    }
    private getRawDeltaY(): number | undefined {
        return this.getRawDeltaY_serialize()
    }
    private setRawDeltaY(rawDeltaY: number | undefined): void {
        const rawDeltaY_casted = rawDeltaY as (number | undefined)
        this.setRawDeltaY_serialize(rawDeltaY_casted)
        return
    }
    private getPressedButtons(): Array<MouseButton> | undefined {
        return this.getPressedButtons_serialize()
    }
    private setPressedButtons(pressedButtons: Array<MouseButton> | undefined): void {
        const pressedButtons_casted = pressedButtons as (Array<MouseButton> | undefined)
        this.setPressedButtons_serialize(pressedButtons_casted)
        return
    }
    private getButton_serialize(): MouseButton {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getButton(this.peer!.ptr)
        return TypeChecker.MouseButton_FromNumeric(retval)
    }
    private setButton_serialize(button: MouseButton): void {
        ArkUIGeneratedNativeModule._MouseEvent_setButton(this.peer!.ptr, TypeChecker.MouseButton_ToNumeric(button))
    }
    private getAction_serialize(): MouseAction {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getAction(this.peer!.ptr)
        return TypeChecker.MouseAction_FromNumeric(retval)
    }
    private setAction_serialize(action: MouseAction): void {
        ArkUIGeneratedNativeModule._MouseEvent_setAction(this.peer!.ptr, TypeChecker.MouseAction_ToNumeric(action))
    }
    private getDisplayX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): number {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: number): void {
        ArkUIGeneratedNativeModule._MouseEvent_setY(this.peer!.ptr, y)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getStopPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._MouseEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaX_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setRawDeltaX_serialize(rawDeltaX: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let rawDeltaX_type : int32 = RuntimeType.UNDEFINED
        rawDeltaX_type = runtimeType(rawDeltaX)
        thisSerializer.writeInt8((rawDeltaX_type).toChar())
        if ((rawDeltaX_type) != (RuntimeType.UNDEFINED)) {
            const rawDeltaX_value  = rawDeltaX!
            thisSerializer.writeNumber(rawDeltaX_value)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaY_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setRawDeltaY_serialize(rawDeltaY: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let rawDeltaY_type : int32 = RuntimeType.UNDEFINED
        rawDeltaY_type = runtimeType(rawDeltaY)
        thisSerializer.writeInt8((rawDeltaY_type).toChar())
        if ((rawDeltaY_type) != (RuntimeType.UNDEFINED)) {
            const rawDeltaY_value  = rawDeltaY!
            thisSerializer.writeNumber(rawDeltaY_value)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressedButtons_serialize(): Array<MouseButton> | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getPressedButtons(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : Array<MouseButton> | undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED))
        {
            const buffer__length : int32 = retvalDeserializer.readInt32()
            let buffer_ : Array<MouseButton> = new Array<MouseButton>(buffer__length)
            for (let buffer__i = 0; buffer__i < buffer__length; buffer__i++) {
                buffer_[buffer__i] = TypeChecker.MouseButton_FromNumeric(retvalDeserializer.readInt32())
            }
            buffer = buffer_
        }
        const returnResult : Array<MouseButton> | undefined = buffer
        return returnResult
    }
    private setPressedButtons_serialize(pressedButtons: Array<MouseButton> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        let pressedButtons_type : int32 = RuntimeType.UNDEFINED
        pressedButtons_type = runtimeType(pressedButtons)
        thisSerializer.writeInt8((pressedButtons_type).toChar())
        if ((pressedButtons_type) != (RuntimeType.UNDEFINED)) {
            const pressedButtons_value  = pressedButtons!
            thisSerializer.writeInt32((pressedButtons_value.length).toInt())
            for (let pressedButtons_value_counter_i = 0; pressedButtons_value_counter_i < pressedButtons_value.length; pressedButtons_value_counter_i++) {
                const pressedButtons_value_element : MouseButton = pressedButtons_value[pressedButtons_value_counter_i]
                thisSerializer.writeInt32(TypeChecker.MouseButton_ToNumeric(pressedButtons_value_element))
            }
        }
        ArkUIGeneratedNativeModule._MouseEvent_setPressedButtons(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface TouchEvent {
    type: TouchType
    touches: Array<TouchObject>
    changedTouches: Array<TouchObject>
    stopPropagation: (() => void)
    preventDefault: (() => void)
    getHistoricalPoints(): Array<HistoricalPoint>
}
export class TouchEventInternal extends BaseEventInternal implements MaterializedBase,TouchEvent {
    get type(): TouchType {
        return this.getType()
    }
    set type(type: TouchType) {
        this.setType(type)
    }
    get touches(): Array<TouchObject> {
        return this.getTouches()
    }
    set touches(touches: Array<TouchObject>) {
        this.setTouches(touches)
    }
    get changedTouches(): Array<TouchObject> {
        return this.getChangedTouches()
    }
    set changedTouches(changedTouches: Array<TouchObject>) {
        this.setChangedTouches(changedTouches)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    get preventDefault(): (() => void) {
        return this.getPreventDefault()
    }
    set preventDefault(preventDefault: (() => void)) {
        this.setPreventDefault(preventDefault)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(TouchEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TouchEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): TouchEventInternal {
        return new TouchEventInternal(ptr)
    }
    public getHistoricalPoints(): Array<HistoricalPoint> {
        return this.getHistoricalPoints_serialize()
    }
    private getType(): TouchType {
        return this.getType_serialize()
    }
    private setType(type: TouchType): void {
        const type_casted = type as (TouchType)
        this.setType_serialize(type_casted)
        return
    }
    private getTouches(): Array<TouchObject> {
        return this.getTouches_serialize()
    }
    private setTouches(touches: Array<TouchObject>): void {
        const touches_casted = touches as (Array<TouchObject>)
        this.setTouches_serialize(touches_casted)
        return
    }
    private getChangedTouches(): Array<TouchObject> {
        return this.getChangedTouches_serialize()
    }
    private setChangedTouches(changedTouches: Array<TouchObject>): void {
        const changedTouches_casted = changedTouches as (Array<TouchObject>)
        this.setChangedTouches_serialize(changedTouches_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getPreventDefault(): (() => void) {
        return this.getPreventDefault_serialize()
    }
    private setPreventDefault(preventDefault: (() => void)): void {
        const preventDefault_casted = preventDefault as ((() => void))
        this.setPreventDefault_serialize(preventDefault_casted)
        return
    }
    private getHistoricalPoints_serialize(): Array<HistoricalPoint> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getHistoricalPoints(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_length : int32 = retvalDeserializer.readInt32()
        let buffer : Array<HistoricalPoint> = new Array<HistoricalPoint>(buffer_length)
        for (let buffer_i = 0; buffer_i < buffer_length; buffer_i++) {
            buffer[buffer_i] = HistoricalPoint_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<HistoricalPoint> = buffer
        return returnResult
    }
    private getType_serialize(): TouchType {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getType(this.peer!.ptr)
        return TypeChecker.TouchType_FromNumeric(retval)
    }
    private setType_serialize(type: TouchType): void {
        ArkUIGeneratedNativeModule._TouchEvent_setType(this.peer!.ptr, TypeChecker.TouchType_ToNumeric(type))
    }
    private getTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_length : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(buffer_length)
        for (let buffer_i = 0; buffer_i < buffer_length; buffer_i++) {
            buffer[buffer_i] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setTouches_serialize(touches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((touches.length).toInt())
        for (let touches_counter_i = 0; touches_counter_i < touches.length; touches_counter_i++) {
            const touches_element : TouchObject = touches[touches_counter_i]
            TouchObject_serializer.write(thisSerializer, touches_element)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getChangedTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getChangedTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_length : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(buffer_length)
        for (let buffer_i = 0; buffer_i < buffer_length; buffer_i++) {
            buffer[buffer_i] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setChangedTouches_serialize(changedTouches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((changedTouches.length).toInt())
        for (let changedTouches_counter_i = 0; changedTouches_counter_i < changedTouches.length; changedTouches_counter_i++) {
            const changedTouches_element : TouchObject = changedTouches[changedTouches_counter_i]
            TouchObject_serializer.write(thisSerializer, changedTouches_element)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setChangedTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getStopPropagation(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._TouchEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPreventDefault_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getPreventDefault(this.peer!.ptr)
        throw new Error("Object deserialization is not implemented.")
    }
    private setPreventDefault_serialize(preventDefault: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(preventDefault)
        ArkUIGeneratedNativeModule._TouchEvent_setPreventDefault(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export namespace cursorControl {
    export function setCursor(value: pointer.PointerStyle): void {
        GlobalScope.cursorControl_setCursor(value)
    }
    export function restoreDefault(): void {
        GlobalScope.cursorControl_restoreDefault()
    }
}
export namespace focusControl {
    export function requestFocus(value: string): boolean {
        return GlobalScope.focusControl_requestFocus(value)
    }
}
